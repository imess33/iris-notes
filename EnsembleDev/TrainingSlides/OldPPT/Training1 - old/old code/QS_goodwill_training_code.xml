<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2016.1 (Build 631U)" ts="2016-02-22 16:20:59">
<Class name="Ens.Adapter">
<Description>
Base class for adapters that communicate with external applications</Description>
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>Ensemble</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%RegisteredObject,Ens.Settings</Super>
<System>4</System>
<TimeChanged>63920,75703</TimeChanged>
<TimeCreated>59259,48721.795</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="BusinessHost">
<Type>Ens.Host</Type>
</Property>

<Property name="KeepaliveInterval">
<Description>
Frequency with which to wake up and call OnKeepalive() method
(not supported for InProc Operations)</Description>
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
</Property>

<UDLText name="T">
<Content><![CDATA[
/* (Override with a subclass if the Adapter needs extended credentials) *
 * (Add this to SETTINGS string for the subclass if it uses credentials) */
]]></Content>
</UDLText>

<Property name="Credentials">
<Description>
This is the ID name of the set of credentials values to be used to access the external system</Description>
<Type>%String</Type>
</Property>

<Property name="%CredentialsObj">
<Description>
This is the credentials object containing the values to be used to access the datasouce</Description>
<Type>Ens.Config.Credentials</Type>
</Property>

<Property name="%WarnedLatest">
<Description>
Flag whether we have already warned about the class being recompiled</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Transient>1</Transient>
</Property>

<Property name="RegistryID">
<Description><![CDATA[
ID of External Service Registry entry<br>
Leave blank if you are not using the external registry<br>
This will be used to find values to be applied to the Adapter and Host settings<br>]]></Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="260"/>
</Property>

<Method name="CredentialsSet">
<FormalSpec>pInVal:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; (Re)Set the Credentials object; do it always because we never know if the source row fields might have been updated
	#; make sure to instantiate even if re-setting to the InitialExpression string
	Set ..%CredentialsObj=$$$NULLOREF

	Set tClassname=$zobjmethod($this,"%ClassName",1) ; call subclass
	Set tClass = $$$comMemberKeyGet(tClassname,$$$cCLASSproperty,"%CredentialsObj",$$$cPROPtype)
	If ""'=tClass {
		Set tSC=##Class(Ens.Config.Credentials).GetCredentialsObj(.tObj,tClassname,tClass,pInVal)
		If $$$ISOK(tSC) { Set ..%CredentialsObj=tObj }
		ElseIf '$$$StatusEquals(tSC,$$$EnsErrNoCallerCredentials) {
			$$$LOGSTATUS(tSC)
		}
	}
	Set i%Credentials=pInVal
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnInit">
<Description>
This user callback method is called just after %OnNew()</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnTearDown">
<Description>
This user callback method is called just before %OnClose()</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnKeepalive">
<Description>
This method is called from the Host.OnTask() method. It will be called within KeepaliveInterval of the last return from OnTask() or OnKeepalive().</Description>
<FormalSpec>pStatus:%Status=$$$OK</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If '..BusinessHost.%WarnedLatest&&'..BusinessHost.%ClassIsLatestVersion() {
		$$$LOGWARNING("Host Class "_$classname(..BusinessHost)_" has been recompiled; continuing to run using code from previous version")
		Set ..BusinessHost.%WarnedLatest=1
	}
	If '..%WarnedLatest&&'..%ClassIsLatestVersion() {
		$$$LOGWARNING("Adapter Class "_$classname()_" has been recompiled; continuing to run using code from previous version")
		Set ..%WarnedLatest=1
	}
	Quit ..BusinessHost.OnKeepalive(pStatus)
]]></Implementation>
</Method>

<Method name="ClearRuntimeAppData">
<Description>
Clear runtime data for a config item. This is normally used to store
adapter error status for input files, and is cleared automatically
each time the item restarts.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pConfigName:%String</FormalSpec>
<Implementation><![CDATA[	Kill $$$EnsRuntimeAppData(pConfigName)
]]></Implementation>
</Method>

<Method name="ClearStaticAppData">
<Description>
Clear static data for a config item. This is normally used to store
already-processed status for input files, and other persistent values related
to adapters, such as the %LastId for the SQL Inbound Adapter.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pConfigName:%String</FormalSpec>
<Implementation><![CDATA[	Kill $$$EnsStaticAppData(pConfigName)
]]></Implementation>
</Method>

<Method name="ClearAllAppData">
<Description>
Clear both static and runtime App Data</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pConfigName:%String</FormalSpec>
<Implementation><![CDATA[
	Do ..ClearRuntimeAppData(pConfigName)
	Do ..ClearStaticAppData(pConfigName)
]]></Implementation>
</Method>
</Class>


<Class name="Ens.AlertRequest">
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Request</Super>
<System>4</System>
<TimeChanged>63920,75703</TimeChanged>
<TimeCreated>59310,24841.312</TimeCreated>

<Property name="SourceConfigName">
<Description>
Name of the business host that is sending the alert</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
</Property>

<Property name="AlertText">
<Description>
Text of the alert message</Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="AlertDestination">
<Description>
Field for designating the external destination of this alert message</Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="AlertTime">
<Description>
Time at which the alert was created.</Description>
<Type>Ens.DataType.UTC</Type>
<InitialExpression>$$$timeUTC</InitialExpression>
</Property>

<Property name="SessionId">
<Description>
The session in which the Alert occurred.</Description>
<Type>%Integer</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>initvalue:%CacheString</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..SourceConfigName=$lg($g(initvalue),1)
	Set ..AlertText = $lg($g(initvalue),2)
	Set ..AlertDestination = $lg($g(initvalue),3)
	Set ..SessionId = $get($$$JobSessionId)
	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>AlertRequestDefaultData</DefaultData>
<Data name="AlertRequestDefaultData">
<Subscript>"AlertRequest"</Subscript>
<Value name="1">
<Value>AlertText</Value>
</Value>
<Value name="2">
<Value>SourceConfigName</Value>
</Value>
<Value name="3">
<Value>AlertDestination</Value>
</Value>
<Value name="4">
<Value>AlertTime</Value>
</Value>
<Value name="5">
<Value>SessionId</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Ens.BP.Context">
<Description><![CDATA[
This holds the (generated) properties defined by the BPL <context>]]></Description>
<ClassType>persistent</ClassType>
<IncludeCode>Ensemble,EnsCompiler</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,%XML.Adaptor</Super>
<System>4</System>
<TimeChanged>63920,75703</TimeChanged>
<TimeCreated>59280,37074.433</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="%ResponseHandlers">
<Description>
This holds the registered ResponseHandlers</Description>
<Type>%String</Type>
<Collection>array</Collection>
<SqlFieldName>_ResponseHandlers</SqlFieldName>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="%Context">
<Description>
This holds the reference to the context object</Description>
<Type>Ens.BP.Context</Type>
<Calculated>1</Calculated>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="%Process">
<Description>
This holds the reference to the process object</Description>
<Type>Ens.BusinessProcess</Type>
<Parameter name="XMLPROJECTION" value="none"/>
</Property>

<Property name="%LastError">
<Description>
This holds last exception</Description>
<Type>%Status</Type>
<InitialExpression>$$$OK</InitialExpression>
</Property>

<Property name="%LastFault">
<Description>
This holds the last thrown fault</Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Parameter name="XMLTYPE">
<Description>
Prevent this class from having the same default XML Type and Name as any of its subclasses that have the short classname "Context".</Description>
<Type>%String</Type>
<Default>BP_Context</Default>
</Parameter>

<Parameter name="XMLINCLUDEINGROUP">
<Description>
Prevent the XML Type and Name of classes derived from this class from interfering with one another if they have the same short classname.</Description>
<Type>%Boolean</Type>
<Default>0</Default>
</Parameter>

<Method name="%ContextGet">
<Description>
Accessor for the %Context property</Description>
<ReturnType>Ens.BP.Context</ReturnType>
<Implementation><![CDATA[	Quit $this
]]></Implementation>
</Method>

<Method name="SetResponseHandler">
<Description>
This method updates the Response Handlers collection by adding a new Response Handler name</Description>
<FormalSpec>pResponseHandlerName:%String,pCompletionKey:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	do {
		Do ..%ResponseHandlers.SetAt(pResponseHandlerName,pCompletionKey)
	} while (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="%OnNew">
<Description>
Initialize the %Process property on construction</Description>
<FormalSpec>initvalue:%CacheString</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..%Process=initvalue
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%GetContentType">
<Description><![CDATA[
This method is called by the Management Portal to determine
the content type that will be returned by the <method>%ShowContents</method>
method.
The return value is a string containing an HTTP content type.]]></Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit "text/xml"
]]></Implementation>
</Method>

<Method name="%ShowContents">
<Description><![CDATA[
This method is called by the Management Portal to 
display a message-specific content viewer.<br>
This method displays its content by writing out to the current device.
The content should match the type returned by the 
<method>%GetContentType</method> method.<br>]]></Description>
<FormalSpec>pZenOutput:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	// show contents as XML
	&html<<?xml version="1.0" ?>
	<!-- type: #($classname())#  id: #(..%Id())# -->
	>
	Do $method($this,"XMLExport")
]]></Implementation>
</Method>

<Method name="%ShowContentsHead">
<Description><![CDATA[
This method is called by the Management Portal to 
display a portion of the HEAD section of a
message-specific content viewer.<br>]]></Description>
<FormalSpec>pZenOutput:%Boolean=0</FormalSpec>
</Method>

<Method name="EnterActivity">
<Description>
This is invoked when a thread enters an activity</Description>
<FormalSpec>pActivity:%Integer,pSubActivity:%Integer,pActivityID:%Integer</FormalSpec>
</Method>

<Method name="LeaveActivity">
<Description>
This is invoked when a thread leaves an activity</Description>
<FormalSpec>pActivity:%Integer,pSubActivity:%Integer,pActivityID:%Integer</FormalSpec>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Ens.BP.ContextD</DataLocation>
<DefaultData>ContextDefaultData</DefaultData>
<IdLocation>^Ens.BP.ContextD</IdLocation>
<IndexLocation>^Ens.BP.ContextI</IndexLocation>
<StreamLocation>^Ens.BP.ContextS</StreamLocation>
<Data name="%ResponseHandlers">
<Attribute>%ResponseHandlers</Attribute>
<Structure>subnode</Structure>
<Subscript>"%ResponseHandlers"</Subscript>
</Data>
<Data name="ContextDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>%Process</Value>
</Value>
<Value name="3">
<Value>%LastError</Value>
</Value>
<Value name="4">
<Value>%LastFault</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Ens.BP.Thread">
<Description>
This class represents a thread of control with a business process </Description>
<ClassType>persistent</ClassType>
<IncludeCode>Ensemble,EnsCompiler</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent</Super>
<System>4</System>
<TimeChanged>63920,75703</TimeChanged>
<TimeCreated>59241,33906.984</TimeCreated>

<Property name="%Process">
<Description>
This holds a reference to the process</Description>
<Type>Ens.BusinessProcess</Type>
<Private>1</Private>
</Property>

<Index name="%Process">
<Properties>%Process</Properties>
</Index>

<Property name="%Context">
<Description>
This holds a reference to the context</Description>
<Type>Ens.BP.Context</Type>
<Calculated>1</Calculated>
<Private>1</Private>
</Property>

<Property name="%PendingResponses">
<Description>
This holds a collection of pending responses that this thread is waiting for</Description>
<Type>%String</Type>
<Collection>array</Collection>
<SqlFieldName>_PendingResponses</SqlFieldName>
</Property>

<Property name="%SyncResponses">
<Description>
This holds a collection of responses that this thread has received</Description>
<Type>%Library.Persistent</Type>
<Collection>array</Collection>
<SqlFieldName>_SyncResponses</SqlFieldName>
</Property>

<Property name="%NextState">
<Description>
This holds the next state of the thread</Description>
<Type>%String</Type>
<Final>1</Final>
<InitialExpression>"S1"</InitialExpression>
<Private>1</Private>
</Property>

<Property name="%Status">
<Description>
This holds the run status of this machine</Description>
<Type>Ens.DataType.RunStatus</Type>
<InitialExpression>$$$eRunStatusRunning</InitialExpression>
</Property>

<Property name="%Wait">
<Description>
Set this property to 1 to suspend this thread and to
allow other threads to run</Description>
<Type>%Boolean</Type>
<Final>1</Final>
<InitialExpression>0</InitialExpression>
<Private>1</Private>
<Transient>1</Transient>
</Property>

<Property name="%ChildThreads">
<Description>
This holds the (possibly empty) set of child threads that this process is waiting on</Description>
<Type>%String</Type>
<Collection>array</Collection>
<SqlFieldName>_ChildThreads</SqlFieldName>
</Property>

<Property name="%SyncTimedOut">
<Description><![CDATA[
This holds the timeout status of the most recent <SYNC> call and may be 0, 1 or 2
0 - The call did not timeout
1 - The call timed out
2 - The call was interrupted]]></Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="%PendingTimeout">
<Description>
This holds the name of the pending timeout call</Description>
<Type>%String</Type>
</Property>

<Property name="%PendingAlarmHandle">
<Description>
This holds the handle the pending alarm request</Description>
<Type>%String</Type>
</Property>

<Property name="%SyncName">
<Description><![CDATA[
This holds the name attribute of the <sync> tag]]></Description>
<Type>%String</Type>
</Property>

<Property name="%SubroutineStack">
<Description>
This holds the callstack for compensation handlers</Description>
<Type>%String</Type>
</Property>

<Property name="%HandlerStack">
<Description>
This holds the callstack for faulthanders</Description>
</Property>

<Property name="%ActivityStack">
<Description>
This holds the activitystack for locating an activity at runtime</Description>
</Property>

<Method name="%ContextGet">
<Description>
Accessor for the %Context property</Description>
<ReturnType>Ens.BP.Context</ReturnType>
<Implementation><![CDATA[	Quit ..%Process.%Context
]]></Implementation>
</Method>

<Method name="StartThread">
<Description>
Start Thread, creates a new instance of the specified thread class, stores it's Id in
the collection of child threads. Consequently the thread becomes runnable at the next
state switch</Description>
<FormalSpec>pThreadClass:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	do {
	
		$$$ASSERT(pThreadClass'="")
		
		#; Create an instance of the thread class
		Set tThread=$zobjclassmethod(pThreadClass,"%New",..%Process)
		$$$ASSERT($IsObject(tThread))
		
		#; Save it, to get the thread id
		Set tSC=tThread.%Save()
		If $$$ISERR(tSC) Quit
		
		#; Store the Id of the newly created thread in the array of child threads
		Do ..%ChildThreads.SetAt($$$eRunStatusRunning,tThread.%Id())
		
		$$$ASSERT(..%ChildThreads.Count())
		
	} while (0)	
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="IsResponsePending">
<Description>
Determine if a CompletionKey exists in this threads pending responses</Description>
<FormalSpec>pCompletionKey:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tIsResponsePending=0
	
	Set tResponse=..%PendingResponses.Next("")
	While tResponse'="" {
		If tResponse=pCompletionKey Set tIsResponsePending=1 Quit
		Set tResponse=..%PendingResponses.Next(tResponse)
	}
	
	Quit tIsResponsePending
]]></Implementation>
</Method>

<Method name="SwitchState">
<Description>
Run the thread by handling responses,executing child threads, and calling the method
indicated by the NextState property.</Description>
<FormalSpec>*pStatus:Ens.DataType.RunStatus,request:%Library.Persistent,response:%Library.Persistent,pCompletionKey:%String,pResumingPostErroredResponse:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	do {
		
		If pCompletionKey'="" {
			
			#; We have received a response
			
			#; Test to see if the response is a timeout message
			If $Extract(pCompletionKey,1,8)="_Timeout" {
				
				#; Yes, is the timeout for this thread?
				If pCompletionKey=..%PendingTimeout {
					
					#; Yes, We have timed out on a sync, first update the process-wide collection of 
					#; synchronized responses.
					Set tResponse=..%PendingResponses.Next("")
					While tResponse'="" {
						If tResponse'=pCompletionKey Do ..%Process.%SynchronizedResponses.SetAt("",tResponse)
						Set tResponse=..%PendingResponses.Next(tResponse)
					}
					
					#; Clear out this threads pending responses, the pending timeout and set the timed out flag 
					Do ..%PendingResponses.Clear() Set ..%PendingTimeout="",..%PendingAlarmHandle="",..%SyncName=""
					
					#; May be 0,1 or 2
					Set ..%SyncTimedOut=1+''..%Process.%IsTimerInterrupted
					
				} Else {
					
					#; The timeout is not applicable to this thread, must give any child threads the chance
					#; to process
				}
			} else {
				
				#; No, it's a regular response, not a timeout
				
				#; If we are resuming following a call response which has errored
			    If pResumingPostErroredResponse {

					#; If there is a handler active
					If ..HandlerActive() {

						#; If the error is a response to a request made by THIS thread
						If ..IsResponsePending(pCompletionKey) {
							
							#; There is a handler for this thread, set the next state to the beginning of the handler and unwind the activities	    
							Set ..%NextState=$$$Top(..%HandlerStack),$ZE="" 
							
							$$$ASSERT(..%NextState'="")
							
							Do ..UnwindActivities()
							
							#; Need to Pop the Handler Stack once the next state has been determined
							$$$Pop(..%HandlerStack)
						}
					}
				}

				#; We have synchronized on this key, so this key is no longer pending for this thread
				Do ..%PendingResponses.RemoveAt(pCompletionKey)
				
				#; This Thread has synchronized on this response
				Do ..%SyncResponses.SetAt(response,pCompletionKey)
				
				#; Add the response to the process wide collection of synchronized responses
				Do ..%Process.%SynchronizedResponses.SetAt("",pCompletionKey)
				
				#; If a timeout is only thing left that we are waiting for, remove it too
				If ..%PendingResponses.Count()=1 {
					Set tNext=..%PendingResponses.Next("")
					If $Extract(tNext,1,8)="_Timeout" {
						Do ..%PendingResponses.Clear()
						Do ..%Process.%SynchronizedResponses.SetAt("",tNext)
					}
				}
			}
		}
			
		#; Need to make sure that the Child threads are only scheduled with the pResumingPostErroredResponse flag once		
		Set tLoopCount=0
		
		#; While not indicated to stop, switch states
		While((..%Status=$$$eRunStatusRunning||(..%Status=$$$eRunStatusWaiting))) {
	
			If tLoopCount Set pResumingPostErroredResponse = 0
			
			Set ..%Status=$$$eRunStatusRunning,tThreadsWaiting=0
			
			If ..%ChildThreads.Count() {
				
				#; Run the child threads until ALL of them are waiting
				while (tThreadsWaiting'=..%ChildThreads.Count()) {
					
					Set tChildThreadId=..%ChildThreads.Next("")
					while (tChildThreadId'="") {
			
						#; pick out the thread status
						Set tStatus=..%ChildThreads.GetAt(tChildThreadId)
						
						If tStatus=$$$eRunStatusRunning||(tStatus=$$$eRunStatusWaiting) {
							
							Set tThread=##class(Ens.BP.Thread).%OpenId(tChildThreadId,,.tSC)
							If $$$ISERR(tSC) Quit
							
							$$$ASSERT($IsObject(tThread))
							
							#; Found a runnable thread, so run it
							Set tSC1=tThread.SwitchState(.tStatus,request,.response,pCompletionKey,pResumingPostErroredResponse)
							
							If tStatus=$$$eRunStatusCompleted {
								Do ..%ChildThreads.RemoveAt(tChildThreadId)
							} else {
								
								#; Update the status recorded in the child list
								Do ..%ChildThreads.SetAt(tStatus,tChildThreadId)
							}
								
							#; Must Save the Thread's new State
							Set tSC=tThread.%Save() If $$$ISERR(tSC) Quit
							
							#; If a thread has errored then by defintion, this parent thread has errored
							If tStatus=$$$eRunStatusErrored {
								
								Set ..%Status=$$$eRunStatusErrored
								$$$ASSERT($$$ISERR(tSC1))
							
								Quit
							}
							
							#; Increment the count of waiting threads
							If tStatus=$$$eRunStatusWaiting Set tThreadsWaiting=tThreadsWaiting+1
							
						}	
						Set tChildThreadId=..%ChildThreads.Next(tChildThreadId)
					}
					
					#; If a child thread has errored or the BPL runtime has errored then 
					#; don't attempt to schedule any more child threads
					If (..%Status=$$$eRunStatusErrored)||$$$ISERR(tSC) Quit
				}
			}
			
			#; Increment the loop count
			Set tLoopCount = tLoopCount + 1
			
			If ..%Status'=$$$eRunStatusErrored,tThreadsWaiting {
				
				#; This thread should wait because it's children are waiting
				Set ..%Wait=0,..%Status=$$$eRunStatusWaiting
				Quit
			}
			
			#; If there has been an error in the BPL runtime then quit
			If $$$ISERR(tSC) Quit
			
			#; If a child thread has errored
			If ..%Status=$$$eRunStatusErrored {
				
				#; Clean up the child threads they musn't be allowed to run again
				Do ..%ChildThreads.Clear()
					
				#; If there is an error handler defined, transfer control to it
				If $$$Top(..%HandlerStack)'="" {
					
					Set tCurrState=$$$Top(..%HandlerStack),..%NextState=""
					
					#; Error is beeing handled, this thread is now running again
					Set ..%Status=$$$eRunStatusRunning
				} else {
					
					#; If we are the top level thread and the error has not been
					#; handled then must report the error
					
					$$$ASSERT($$$ISERR(tSC1))
					
					Set tSC=tSC1	
					Quit
				}
			} else {
		
				$$$ASSERT(..%Status=$$$eRunStatusRunning)
				
				#; Now execute this thread
				Set tCurrState=..%NextState,..%NextState=""
			}
			
			#; Execute the method representing the next state
			Set tSC=$zobjmethod($this,tCurrState,..%Process,..%Context,..%SyncTimedOut,..%SyncResponses,request,.response)
			If $$$ISERR(tSC) Set ..%Status=$$$eRunStatusErrored Quit
				
			If ..%Wait=1 {
				
				#; This thread should wait
				Set ..%Wait=0,..%Status=$$$eRunStatusWaiting
				Quit
			}
			
			#; If the next state is 'Stop' this thread has run to completion
			If ..%NextState="Stop" {
				Set ..%Status=$$$eRunStatusCompleted
			}
		}
		
	} while (0)
Exit
	#; Assign the output
	Set pStatus=..%Status
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="%OnNew">
<Description>
This initializes the thread with the owning process</Description>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>initvalue:%CacheString</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do %code.WriteLine(" Set ..%Process=initvalue")
	Do %code.WriteLine(" Set ..%NextState=""S1""")
	Do %code.WriteLine(" Quit $$$OK")
]]></Implementation>
</Method>

<Method name="SyncThreads">
<Description>
Synchronize threads</Description>
<FormalSpec>*pComplete:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	do {
		Set pComplete=0
		If ..%ChildThreads.Count()=0 {
			
			#; No more threads in my collection, they are all complete
			Set pComplete=1
		}
	} while (0)	
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="MakeAsyncCall">
<Description>
Make an Asynchronous call to the specified class, if a non-empty response handler is specified,
that response handler will be called when the response is received</Description>
<FormalSpec>pResponseHandlerName:%String,pClassName:%String,pRequest:%Library.Persistent,pCompletionKey:%String,pResponseRequired:%Boolean,pIsTimer:%Boolean=0,pDescription:%String="",pSimSync:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	do {
		#; Update the name of the request handler
		If pResponseHandlerName'="" {
			Do ..%Context.SetResponseHandler(pResponseHandlerName,pCompletionKey)
		}
		
		#; Do the call
		Set tSC=..%Process.SendRequestAsyncInternal(pClassName,pRequest,pResponseRequired,pCompletionKey,pIsTimer,,pDescription,pSimSync)
		If $$$ISERR(tSC) Quit
		
	} while (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="MakeSyncCall">
<Description>
Make a synchronous call to the specified class. If a non-empty response handler is specified,
the response handler is called inline</Description>
<FormalSpec>pResponseHandlerName:%String,pClassName:%String,request:%Library.Persistent,response:%Library.Persistent,callrequest:%Library.Persistent,pDescription:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	do {
		#; Make the request
		Set tSC=..%Process.SendRequestSync(pClassName,callrequest,.tCallResponse,,pDescription)
		If $$$ISERR(tSC) Quit
		
		#; Execute the handler inline
		If pResponseHandlerName'="" {
			Set tSC=$zobjmethod(..%Context,pResponseHandlerName,..%Process,..%Context,request,.response,callrequest,tCallResponse)
		}
	} while (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="UpdateSynchronizedResponses">
<Description>
Update the Synchronized Response array</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	do {
		#; Walk through the list of child threads
		Set tChildThreadId=..%ChildThreads.Next("")
		While (tChildThreadId'="") {
			
			Set tThread=##class(Ens.BP.Thread).%OpenId(tChildThreadId,,.tSC)
			If $$$ISERR(tSC) Quit
			
			$$$ASSERT($IsObject(tThread))
		
			#; Recurse	
			Set tSC=tThread.UpdateSynchronizedResponses()
			If $$$ISERR(tSC)
								
			Set tChildThreadId=..%ChildThreads.Next(tChildThreadId)
		}
		
		If $$$ISERR(tSC) Quit
		
		#; Walk through pending responses and update the processes synchronized 
		#; responses array
		Set tResponse=..%PendingResponses.Next("")
		While tResponse'="" {
			Do ..%Process.%SynchronizedResponses.RemoveAt(tResponse)	
			Set tResponse=..%PendingResponses.Next(tResponse)
		}
	} while (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="GoSub">
<Description>
This is invoked by a compensate activity when it wants to call a compensation handler</Description>
<FormalSpec>pGoSubState:%String,pReturnState:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK,$ZT="Trap"
	do {	
		#; Push the state onto the stack
		$$$Push(pReturnState,..%SubroutineStack)
		
		#; Set the next state to switch to
		Set ..%NextState=pGoSubState
	} while (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="Return">
<Description>
This is invoked by a compensation handler when it wants to return to the caller</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK,$ZT="Trap"
	do {
		#; Get the return state
		Set ..%NextState=$$$Top(..%SubroutineStack)
	
		#; Pop the state off the stack
		$$$Pop(..%SubroutineStack)
		
	} while (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="SatisfyPendingResponses">
<Description><![CDATA[
This is invoked when a <sync> for 'any' is satisfied. The remaining pending responses
need to removed from the master pending response list of the process. This ensures that
delayed responses from a prior calls donot interfere with the current <sync>.]]></Description>
<Implementation><![CDATA[
	Set tName=..%PendingResponses.Next("")
	While tName'="" {
		Do ..%Process.RemovePendingResponse(tName)
		Set tName=..%PendingResponses.Next(tName)
	}
	If ..%PendingTimeout'="" Do ..%Process.RemovePendingResponse(..%PendingTimeout)
]]></Implementation>
</Method>

<Method name="EnterActivity">
<Description>
This is invoked when a thread enters an activity</Description>
<FormalSpec>pActivity:%Integer,pSubActivity:%Integer,pActivityID:%Integer</FormalSpec>
<Implementation><![CDATA[
	#; Each entry on the stack is a $List of activity,subactivity and unique ( for this BP ) activity ID
	$$$Push($ListBuild(pActivity,pSubActivity,pActivityID),..%ActivityStack)
]]></Implementation>
</Method>

<Method name="LeaveActivity">
<Description>
This is invoked when a thread leaves an activity</Description>
<FormalSpec>pActivity:%Integer,pSubActivity:%Integer,pActivityID:%Integer</FormalSpec>
<Implementation><![CDATA[	$$$Pop(..%ActivityStack)
]]></Implementation>
</Method>

<Method name="UnwindActivities">
<Description>
This is invoked when control is transferred to a fault handler</Description>
<Implementation><![CDATA[
	#; Unwind the activity stack until a scope block is encountered
	If $ListLength(..%ActivityStack) {
		
		for tI=$ListLength(..%ActivityStack):1:-1 {
	
			If $List($List(..%ActivityStack,tI),1)=$$$ActivityScope
			{
				Set ..%ActivityStack=$List(..%ActivityStack,1,tI-1)
				Quit
			}
		}
	}
]]></Implementation>
</Method>

<Method name="HandlerActive">
<Description>
Does this thread have a fault handler active?</Description>
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[($$$Top(..%HandlerStack)'="")
]]></Implementation>
</Method>

<Method name="AnyHandlerActive">
<Description>
Does this thread or any of its children have a fault handler active?</Description>
<FormalSpec><![CDATA[&pActive:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK 
	Do {
		#; Check for this thread being active
		Set pActive=..HandlerActive() If pActive Quit
	
		#; Now check the children	
		Set tChildThreadId=..%ChildThreads.Next("")
		while (tChildThreadId'="") {

			#; Open the thread
			Set tThread=##class(Ens.BP.Thread).%OpenId(tChildThreadId,,.tSC)
			If $$$ISERR(tSC) Quit
		
			#; Test to see if it has a handler active
			Set tSC=tThread.AnyHandlerActive(.pActive)
			If $$$ISERR(tSC) || pActive Quit
			
			#; Get the next
			Set tChildThreadId=..%ChildThreads.Next(tChildThreadId)
		}
		
	} while (0)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="ManageState">
<Internal>1</Internal>
<FormalSpec>pStatus:%Status</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; If an error is indicated
	If $$$ISERR(pStatus) {
	    
	    #; Record the errored status
	    Set ..%Context.%LastError=pStatus
	    
	    #; Test to see if there is an handler on the Stack
	    If ..HandlerActive() {
		    		    
		  	#; There is a handler, set the next state to the beginning of the handler and unwind the activities	    
	       	Set pStatus=$$$OK,..%NextState=$$$Top(..%HandlerStack),$ZE="" 
	       	
	       	$$$ASSERT(..%NextState'="")
	       	
	       	Do ..UnwindActivities()
	       	
	       	#; Need to Pop the Handler Stack once the next state has been determined
	       	$$$Pop(..%HandlerStack)
	    }
	}
	Quit pStatus
]]></Implementation>
</Method>

<Method name="ManageStatus">
<FormalSpec>pStatus:%Status,pMethodName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If $ZE'["<ZTHRO>" { 
		If ..HandlerActive() { 
			Set pStatus=$$$ERROR($$$CacheError,$ZE) 
		} else { 
			Set pStatus=##class(Ens.Util.Error).EnsSystemError(..%ClassName(),pMethodName)
		}
	} 
	Quit pStatus
]]></Implementation>
</Method>

<Method name="Fault">
<FormalSpec>pFault:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If $System.Status.Equals(..%Context.%LastError,$$$EnsErrBPLThrownFault) {
		Quit ($System.Status.GetOneStatusText(..%Context.%LastError,1)=pFault)
	}
	Quit 0
]]></Implementation>
</Method>

<Method name="PerformXSLT">
<Description>
This method performs an XSLT transformation as specified by the BPL XSLT Activity</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pXSLURL:%String,pSource:%Stream.Object,&pTarget:%Stream.Object,&pParameters:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK,$ZT="Trap"
	do {
		#; Parse the given URL
		Do ##class(%Net.URLParser).Parse(pXSLURL,.tComponents)
		
		Set tSC=##class(Ens.Util.URLStream).GetURLStream(pXSLURL,.tXSL)
		If $$$ISERR(tSC) Quit
		
		Set tSC=##class(%XML.XSLT.Transformer).TransformStream(pSource,tXSL,.pTarget,,.pParameters)
		
	} while (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Ens.BP.ThreadD</DataLocation>
<DefaultData>ThreadDefaultData</DefaultData>
<IdLocation>^Ens.BP.ThreadD</IdLocation>
<IndexLocation>^Ens.BP.ThreadI</IndexLocation>
<StreamLocation>^Ens.BP.ThreadS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="%ChildThreads">
<Attribute>%ChildThreads</Attribute>
<Structure>subnode</Structure>
<Subscript>"%ChildThreads"</Subscript>
</Data>
<Data name="%PendingResponses">
<Attribute>%PendingResponses</Attribute>
<Structure>subnode</Structure>
<Subscript>"%PendingResponses"</Subscript>
</Data>
<Data name="%SyncResponses">
<Attribute>%SyncResponses</Attribute>
<Structure>subnode</Structure>
<Subscript>"%SyncResponses"</Subscript>
</Data>
<Data name="ThreadDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>%NextState</Value>
</Value>
<Value name="3">
<Value>%Process</Value>
</Value>
<Value name="4">
<Value>%Status</Value>
</Value>
<Value name="5">
<Value>%SyncTimedOut</Value>
</Value>
<Value name="6">
<Value>%PendingTimeout</Value>
</Value>
<Value name="7">
<Value>%CallStack</Value>
</Value>
<Value name="8">
<Value>%SubroutineStack</Value>
</Value>
<Value name="9">
<Value>%FaultHandler</Value>
</Value>
<Value name="10">
<Value>%FaultHandlerStack</Value>
</Value>
<Value name="11">
<Value>%HandlerStack</Value>
</Value>
<Value name="12">
<Value>%ActivityStack</Value>
</Value>
<Value name="13">
<Value>%PendingAlarmHandle</Value>
</Value>
<Value name="14">
<Value>%SyncName</Value>
</Value>
<Value name="15">
<Value>%LastFault</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Ens.BPLJanitor">
<Super>%Projection.AbstractProjection</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>63116,35846.311493</TimeCreated>

<Method name="RemoveProjection">
<Description><![CDATA[
This method is called by the Class Compiler whenever an associated 
class is either a) about to be recompiled, or b) about to be deleted.
<var>classname</var> contains the name of the associated class while 
<var>parameters</var> contains an array of the projection parameters 
subscripted by parameter name.  Also the special parameter value
parameters("%qstruct") contains a merge of the qstruct array this projection is being
compiled with. <var>recompile</var> is true (1) if the
associated class is about to be recompiled. The <var>modified</var>
for an incremental compile will contain the comma separated list of methods that
were modified and will be blank for a full compiler.<BR>
Any errors reported by this method are reported by the Class Compiler but
do not effect class compilation in any way.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,recompile:%Boolean,modified:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #; Don't run on the base class
    If classname'="Ens.BusinessProcessBPL" {
        If recompile=0 Do $System.OBJ.DeletePackage(classname,$get(parameters("%qstruct")))
    }
    QUIT $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Ens.BusinessOperation">
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>%sySystem</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Host,Ens.Util.IOLogger</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59262,38857.002</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="%RequestHeader">
<Type>Ens.MessageHeader</Type>
</Property>

<Property name="ReplyCodeActions">
<Description><![CDATA[
<p>A comma-separated list of codes specifying what action this Operation will take on various reply status conditions. 
The format of the list is: <br/> &lt;code&gt;=&lt;actions&gt;,(&lt;code&gt;,&lt;code&gt;)=&lt;actions&gt;,...<br/>
Types of reply status condition are identified by a specification code:
<ul style="list-style-type: none;">
<li><b>E</b> - Error status returned from message handler</li>
<li><b>E#&lt;statuscode&gt;</b> - Error status returned from message handler has status code equal to &lt;statuscode&gt;</li>
<li><b>E*&lt;text&gt;</b> - Error status returned from message handler contains text string &lt;text&gt;</li>
<li><b>X</b> - there is no reply message at all</li>
</ul></p>
<p>The following values for &lt;actions&gt; may be used alone or in combinations: 
<ul style="list-style-type: none;">
<li><b>C</b> - Treat the message as Completed OK.</li>
<li><b>W</b> - Log a warning. If no other non-warning &lt;actions&gt; are triggered, the message will be treated as Completed OK.</li>
<li><b>R</b> - Retry the message according to the configured RetryInterval and FailureTimeout; finally Fail unless a 
different action is also specified.</li>
<li><b>S</b> - Suspend the message, log an error, and move on to try the next message.</li>
<li><b>D</b> - Disable the Operation, log an error and restore the message to the front of the Operation's queue.</li>
<li><b>F</b> - Fail with an error and move on to try the next message from the Operation's queue.</li></ul>
An example of a valid ReplyCodeActions specification is 'E#6301=R,E#&lt;Ens&gt;ErrGeneral=RD,E=F'. This specification will result in a 
retry when error code 6301 is encountered. When error code &lt;Ens&gt;ErrGeneral is encountered, the Operation first retries to send 
the message until FailureTimeout and then, if the error continues, it disables the Operation instead of failing. Any other errors will 
cause the Operation to fail processing of the current message and return the error status to the caller, without retrying first.</p>
<p><b>The default behavior is 'E=F'.</b> Thus any error status will result in the error being logged and returned to the caller,
no retries will be attempted, and the Operation will move on to try the next message from its queue.</p>
<p>All codes where &lt;actions&gt; consists of only 'W' (for 'log a Warning') will be evaluated, and a warning will be
generated for each matching &lt;code&gt;. Other &lt;code&gt; values will be evaluated in left-to-right order, executing the
first matching &lt;code&gt; that has a non-warning &lt;actions&gt; value. As noted in the details for the 'W' flag, an error
that only triggers 'W' &lt;actions&gt; will be treated as Completed OK.</p>]]></Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="RetryInterval">
<Description>
How frequently to retry access to the output system</Description>
<Type>%Numeric</Type>
<InitialExpression>5</InitialExpression>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="AlertRetryGracePeriod">
<Description>
When AlertOnError is True, and the Operation is retrying,
refrain from alerting if the Operation succeeds within this number of seconds after an error</Description>
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="FailureTimeout">
<Description><![CDATA[
How long to keep retrying before giving up and returning an error code. <br/>
-1 means never give up.]]></Description>
<Type>%Numeric</Type>
<InitialExpression>15</InitialExpression>
<Parameter name="MINVAL" value="-1"/>
</Property>

<Property name="QueueCountAlert">
<Description><![CDATA[
Number of messages on this item's queue needed to trigger an Alert message to be sent. Note that no further
alerts will be sent unless the number of messages on the queue drops below 80% of this number and then rises again to this number. <br/>
Note that this alert will be sent even if AlertOnError is False. <br/>
Zero means no alerts of this type will be sent.]]></Description>
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="QueueWaitAlert">
<Description><![CDATA[
The number of seconds a message at the front of the queue may have waited since being queued before an alert is triggered.<br/>
Only one alert will be raised per host item per sequential trigger of the queue wait threshold. <br/>
Note that this alert will be sent even if AlertOnError is False. <br/>
Zero means no alerts of this type will be sent.]]></Description>
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="SendSuperSession">
<Description>
Generate SuperSessions property</Description>
<Type>%Boolean</Type>
</Property>

<Parameter name="SETTINGS">
<Default>ReplyCodeActions,RetryInterval,AlertRetryGracePeriod:Alerting,FailureTimeout,QueueCountAlert:Alerting,QueueWaitAlert:Alerting,SendSuperSession</Default>
</Parameter>

<UDLText name="T">
<Content><![CDATA[/* Add this property to your SETTINGS list if your Adapter has a property 'Connected' and you want to expose this feature */
]]></Content>
</UDLText>

<Property name="NoFailWhileDisconnected">
<Description><![CDATA[
Suspend counting seconds toward FailureTimeout while disconnected.<br/>
Does not apply if FailureTimeout=-1 or StayConnected=0.]]></Description>
<Type>%Boolean</Type>
</Property>

<Property name="Retry">
<Description>
Set this property to 1 if you want to retry the current message again</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SuspendMessage">
<Description>
Set this property to 1 if you want to mark the current message as "Suspended"</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="DeferResponse">
<Description>
Set this property to 1 if you want to defer the response to the current message so that it can be completed asynchronously at a later time by a other code (usually a business service).</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="%AlertStartTime">
<Description>
Time from which to start Alert retry grace period</Description>
<Type>%String</Type>
</Property>

<Property name="RetryCount">
<Description>
how many times have we retried?</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="%ActionHint">
<Description>
Subclasses can store hint values here for use in determining what ReplyCodeAction to apply</Description>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="MessageHeaderHandler">
<Internal>1</Internal>
<FormalSpec>pRequestHeader:Ens.MessageHeader,*pResponseHeader:Ens.MessageHeader</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $EC="",(tSC,tSCSuspend)=$$$OK, tAborted=0, pResponseHeader=$$$NULLOREF, tDoAlert=""
	try {
#If ..#INVOCATION="InProc"
		Set tParentHeaderId = $get($$$JobCurrentHeaderId)
#EndIf
		Set ..%RequestHeader=pRequestHeader, $$$JobCurrentHeaderId = pRequestHeader.%Id()
		If pRequestHeader.MessageBodyClassName'="" {
			Set tRequest = $classmethod(pRequestHeader.MessageBodyClassName,"%OpenId",pRequestHeader.MessageBodyId,,.tSC)
			If '$IsObject(tRequest) Set tSC=$$$ERROR($$$EnsErrGeneral,"Could not open MessageBody "_pRequestHeader.MessageBodyId_" for MessageHeader #"_pRequestHeader.%Id()_" with body class "_pRequestHeader.MessageBodyClassName_":"_$$$StatusDisplayString(tSC))  Quit
		} Else {
			Set tRequest=$$$NULLOREF, tSC=$$$ERROR($$$EnsErrGeneral,"No MessageBody classname for MessageHeader #"_pRequestHeader.%Id())  Quit
		}
		Do ##class(Ens.Util.Statistics).InitStats(..%ConfigName)
		Set tConfigName = ..%ConfigName, tResponse = $$$NULLOREF
		Do pRequestHeader.SetStatus($$$eMessageStatusDelivered)
		Set (..%SessionId,$$$JobSessionId) = pRequestHeader.SessionId
		Set (..%SuperSession,$$$JobSuperSession)=pRequestHeader.SuperSession

		Set (tEndTime,..%LastReportedError)="", ..RetryCount=1, (..Retry,..SuspendMessage,..DeferResponse,..%AlertStartTime,tFailureTimedOut,tTerminate)=0
		While 1 { ; Retry loop
			Set tTimeCalled=$ZH, tDoAlert=""
			Set:'tEndTime tEndTime = tTimeCalled + ..FailureTimeout

			#; Handle message body
			If $D($$$EnsCrashedMessage(pRequestHeader.%Id())) {
				Kill $$$EnsCrashedMessage(pRequestHeader.%Id())
				Set tSC=$$$EnsError($$$EnsErrPreviouslyCrashedMessage,pRequestHeader.%Id())
			} Else {
				Set tSC=..MessageHandler(tRequest,.tResponse)
			}
			If $$$ISERR(tSC) {
				Set $EC=""  try {
					$$$sysTRACE("calling OnError R")
					Set tDoAlert=..OnError(.tSC)
				} catch {
					Set tSC=$$$ADDSC(tSC,$$$EnsSystemError), tDoAlert=1
				}
				If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after OnError() R; committing before proceeding")
			}
			Set $EC=""  try {
				Set tMHSC=tSC
				Set tAction=..OnGetReplyAction(tRequest,.tResponse,.tSC)
				Set:""'=tAction tSC=..doReplyAction(tAction, tRequest,.tResponse,tSC)
				If tSC'=tMHSC&&$$$ISERR(tSC) {
					$$$sysTRACE("calling OnError A")
					Set tDoAlert=..OnError(.tSC)
				}
			} catch {
				Set tSC=$$$ADDSC(tSC,$$$EnsSystemError), tDoAlert=1
			}
			If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after ReplyAction OnError() A; committing before proceeding")
			If ..SuspendMessage {
				Set tSCSuspend=tSC
				Set tSC=$$$ERROR($$$EnsErrSuspending,pRequestHeader.%Id(),$$$StatusDisplayString(tSC))
				Quit
			}
			Quit:..DeferResponse
			Quit:'..Retry
			Set ..Retry=0

			If $$$ISERR(tSC) {
				Set tTxt=$P($$$StatusDisplayString(tSC)," -- ") ; strip off "logged as" varying text
				Set:'..%AlertStartTime&&..AlertOnError&&..AlertRetryGracePeriod&&(tTxt'=..%LastReportedError) ..%AlertStartTime=$ZH
				If ..%AlertStartTime {
					If $ZH>=(..%AlertStartTime+..AlertRetryGracePeriod) {
						Set ..%AlertStartTime=0
						If tTxt'=..%LastReportedError { $$$LOGERROR("Alerting at expiration of retry grace period ("_..AlertRetryGracePeriod_") for "_tTxt) }
						Else { $$$LOGINFO("Alerting at expiration of retry grace period ("_..AlertRetryGracePeriod_") for "_tTxt) }
					} Else {
						Set tDoAlert=0
						If tTxt'=..%LastReportedError { $$$LOGERROR("Not Alerting during retry grace period ("_..AlertRetryGracePeriod_") for "_tTxt) }
						Else { $$$LOGINFO("Not Alerting during retry grace period ("_..AlertRetryGracePeriod_") for "_tTxt) }
					}
				} Else {
					If tTxt'=..%LastReportedError { $$$LOGSTATUS(tSC) }
					Else { Set tDoAlert=0 }
				}
				Do:tDoAlert&&..AlertOnError ..SendAlert(##class(Ens.AlertRequest).%New($LB(..%ConfigName,$$$StatusDisplayString(tSC))))
				Set tDoAlert=0
			} Else { Set ..%AlertStartTime=0, tTxt="" }
			Set ..%LastReportedError=tTxt

			If ..%QuitTask { Set tTerminate=1 }
			Else {
				If ..FailureTimeout'=-1 {
					Set tNow=$ZH
					If ..NoFailWhileDisconnected {
						try { Set tStayConnected=..Adapter.StayConnected }
						catch { Set tStayConnected=1 }
						If tStayConnected {
							try { Set tConnected=..Adapter.Connected }
							catch { Set tConnected=1 }
							If 'tConnected {
								If tNow>tEndTime $$$sysTRACE("Ignoring FailureTimeout while disconnected")
								Set:$G(tLast) tEndTime=tEndTime+(tNow-tLast) ; keep up with our disconnected time
								Set tLast=tNow
							} ElseIf $G(tLast) {
								#; give it time for at least one retry so we don't die immediately on reconnecting
								Set tMinInterval=..RetryInterval+1  Set:..FailureTimeout<..RetryInterval&&(..FailureTimeout>0) tMinInterval=..FailureTimeout+1
								If tEndTime-tNow<tMinInterval $$$sysTRACE("Extending FailureTimeout by "_(tNow+tMinInterval-tEndTime)_" after reconnecting")  Set tEndTime=tNow+tMinInterval
								Kill tLast
							}
						}
					}
					If tNow>tEndTime {
						Set tFailureTimedOut=1, tSC=$$$ERROR($$$EnsErrFailureTimeout, ..FailureTimeout, $$$StatusDisplayString(tSC), $$$CurrentClass), tDoAlert=""
						Set $EC=""  try {
							Set tMHSC=tSC
							Set tDoDefault=..OnFailureTimeout(tRequest,.tResponse,.tSC)
							Set:tDoDefault tSC=$S(""=tAction:tSC,1:..finalReplyAction(tAction,tSC,1))
							Set:tSC'=tMHSC&&$$$ISERR(tSC) tDoAlert=""
						} catch {
							Set tSC=$$$ADDSC(tSC,$$$EnsSystemError), tDoAlert=""
						}
						If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after OnFailureTimeout(); committing before proceeding")
						Set:..SuspendMessage tSCSuspend=tSC
						Quit:'..%QuitTask
					}
				}
				If ..%QuitTask { Set tTerminate=1 }
				Else {
					$$$SetHostMonitor(tConfigName,$$$eMonitorStatus,"Retry")
#If ..#INVOCATION="Queue"
					$$$SetJobMonitor(tConfigName,$$$SystemName_":"_$Job,$$$eMonitorStatus,"Retry")
#EndIf
					Set tWaitTime = tTimeCalled + ..RetryInterval - $ZH
					Set tSC1=##class(Ens.Queue).DeQueue("SystemSignal:"_$Job,,$S(tWaitTime<0:0, 1:tWaitTime),,0)  If $$$ISERR(tSC1) Set tSC=$$$ADDSC(tSC,tSC1)  Quit
					Set tTerminate=##class(Ens.Job).ShouldTerminate()
				} ; %QuitTask
			} ; %QuitTask
			Set tSBQ=##class(Ens.Job).ShouldBeQuiescent()
			If tSBQ || tTerminate {
				If pRequestHeader.Priority>$$$eMessagePrioritySync||tTerminate {
					Set tTerminate=1
					If 'tFailureTimedOut||(..%QuitTask>1) {
						#; blow away the original error (prevent error response) if self-disabling or shutting down while retrying
						Set tSCx=tSC, tSC=##class(Ens.Queue).PutBackToQueue(pRequestHeader)
						$$$LOGINFO("Retry loop exited due to shutdown request for message "_..%RequestHeader.%Id()_" ; re-queueing"_$S($$$ISOK(tSCx):"",1:" - original error: "_$$$StatusDisplayString(tSCx)))
					} Else {
						$$$LOGINFO("Retry loop exited due to shutdown request for message "_..%RequestHeader.%Id()_" ; quitting with status "_$$$StatusDisplayString(tSC))
					}
					Quit
				}
				$$$LOGINFO("Ignoring "_$S(tSBQ:"Quiescent",1:"Terminate")_" request while processing high priority (i.e. synchronous) request "_..%RequestHeader.%Id())
			}
			If ##class(Ens.Job).ShouldAbort() {
				$$$LOGWARNING("Message "_..%RequestHeader.%Id()_" aborted as requested by signal for job "_$J_$S($$$ISOK(tSC):"",1:" - original error: "_$$$StatusDisplayString(tSC)))
				Set tSC=$$$OK, tAborted=1
				Quit
			}
			If ##class(Ens.Job).ShouldSuspend() {
				$$$LOGWARNING("Message "_pRequestHeader.%Id()_" suspended as requested by signal for job "_$J_$S($$$ISOK(tSC):"", 1:" - original error: "_$$$StatusDisplayString(tSC)))
				Set tSC=$$$OK, ..SuspendMessage=1
				Quit
			}
			Set ..RetryCount=..RetryCount+1
			$$$SetJobMonitor(tConfigName,$$$SystemName_":"_$Job,$$$eMonitorRetry,..RetryCount)
			$$$sysTRACE("Retrying Request Header Id "_pRequestHeader.%Id()_" - try #"_..RetryCount)
		} ; Retry loop

		$$$SetJobMonitor(tConfigName,$$$SystemName_":"_$Job,$$$eMonitorRetry,"")

		If $$$ISERR(tSC) {
			If ""=tDoAlert {
				Set $EC=""  try {
					$$$sysTRACE("calling OnError E")
					Set tDoAlert=..OnError(.tSC)
				} catch {
					Set tSC=$$$ADDSC(tSC,$$$EnsSystemError), tDoAlert=1
				}
				If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after OnError() E; committing before proceeding")
			}
			Quit:'..SuspendMessage&&'..DeferResponse
		}
		Quit:tTerminate

		#; update global statistics
		Set tConfigName=..%ConfigName
		$$$IncHostCounterTime(tConfigName)

		#; local stats
#If ..#INVOCATION="Queue"
		$$$IncJobCounterTime(tConfigName,$$$SystemName_":"_$Job)
#EndIf
		If tAborted {
			Do pRequestHeader.SetStatus($$$eMessageStatusAborted)
			Quit
		}
		If ..SuspendMessage {
			Do pRequestHeader.SetStatus($$$eMessageStatusSuspended)
			If $$$ISERR(tSC) {
				If $$$ISERR(tSCSuspend) { $$$LOGSTATUS(tSC) }
				Else { $$$LOGWARNING($$$StatusText(tSC)) }
			}
			Set tSC=$$$OK
			Quit
		}
		If ..DeferResponse {
			Do pRequestHeader.SetStatus($$$eMessageStatusDeferred)
			If $$$ISERR(tSC) {
				$$$LOGWARNING("Deferring Response to Request "_pRequestHeader.%Id()_"; Operation returned error "_$$$StatusDisplayString(tSC))
				Set tSC=$$$OK
			} Else {
				$$$sysTRACE("Deferring Response to Request "_pRequestHeader.%Id())
			}
			Quit
		}
		Do pRequestHeader.SetStatus($$$eMessageStatusCompleted)

		If $$$ISOK(tSC) && pRequestHeader.needsReply() {
			Set tSC=pRequestHeader.NewResponseMessage(.pResponseHeader,tResponse)
		}
	} catch {
		Set tSC=$$$EnsSystemError, tDoAlert=1
	}
	If $$$ISERR(tSC) {
		Set:(tDoAlert="") tDoAlert = ..OnError(tSC)
		Set tTxt=$P($$$StatusDisplayString(tSC)," -- ") ; strip off "logged as" varying text
		If tTxt'=..%LastReportedError { $$$LOGSTATUS(tSC) }
		Set ..%LastReportedError=tTxt

		Set tConfigName=..%ConfigName
		$$$SetHostMonitor(tConfigName,$$$eMonitorStatus,"Error")
#If ..#INVOCATION="Queue"
		$$$SetJobMonitor(tConfigName,$$$SystemName_":"_$Job,$$$eMonitorStatus,"Error")
#EndIf
		Do:'tAborted pRequestHeader.SetStatus($$$eMessageStatusError)
		Do:tDoAlert&&..AlertOnError ..SendAlert(##class(Ens.AlertRequest).%New($LB(..%ConfigName,$$$StatusDisplayString(tSC))))
	} ElseIf ..SuspendMessage&&$$$ISERR(tSCSuspend) {
		Do:tDoAlert&&..AlertOnError ..SendAlert(##class(Ens.AlertRequest).%New($LB(..%ConfigName,$$$StatusDisplayString(tSCSuspend))))
	}
	Set ..%SessionId=""
	Set ..%SuperSession=""
	Do ##class(Ens.Util.Statistics).RecordStats($$$eHostTypeOperation,..%ConfigName)
#If ..#INVOCATION="Queue"
	Kill $$$JobSessionId
	Kill $$$JobSuperSession
	Kill $$$JobCurrentHeaderId
#ElseIf ..#INVOCATION="InProc"
	Set $$$JobCurrentHeaderId = $get(tParentHeaderId)
#EndIf
	Set ..%RequestHeader=$$$NULLOREF
	Quit tSC
cleanNum(str)
	Set f=0  For { Set f=$F(str,"#",f)  Quit:'f
		For i=f:1 { Quit:$E(str,i)'?1N  Set $E(str,i)="",i=i-1 }
	}
	Quit str
]]></Implementation>
</Method>

<Method name="OnGetReplyAction">
<Description>
Construct and return an Action string consisting of supported action code letters, based on criteria in the ReplyCodeActions setting value and qualities of the current Request, Response, and Error Status.</Description>
<FormalSpec><![CDATA[pRequest:%Library.Persistent,&pResponse:%Library.Persistent,&pSC:%Status]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 	Set (tFullAction,tText)="", nActions=$S(""=$ZStrip(..ReplyCodeActions,"<>W"):0, 1:$L(..ReplyCodeActions,","))
	For i=1:1:nActions { Set tType=$P(..ReplyCodeActions,",",i)  Continue:""=tType
		Set tAction="", tCode=$ZStrip($P(tType,"="),"<>W"), tCodeU=$ZCVT(tCode,"U")
		Set tKnown=$Case($E(tCodeU)
						,"E":$Case($E(tCode,2)
								,"#":1
								,"*":1
								,"":1
								,:0)
						,"X":$Case($E(tCode,2),"":1, :0)
						,:0
						)
		If 'tKnown {
			$$$LOGWARNING("Unrecognized reply code:'"_tType_"'")
			Continue
		}
		Set tMatch=$Case($E(tCodeU)
						,"E":$$$ISERR(pSC)
						,"X":'$$$IsdefObject(pResponse)
						,:0)
				 && $Case($E(tCode,2)
						,"#":$$$StatusEquals(pSC,$E(tCode,3,*))
						,"*":$$$StatusDisplayString(pSC)[$E(tCode,3,*)
						,:1)
		If tMatch {
			If $E(tCodeU)="X" {
				Set tMatchText="Empty Response object matched ReplyCodeAction "_i_" : ':"_tType_"'"
			} Else {
				Set tMatchText="Status '"_$$$StatusDisplayString(pSC)_"' matched ReplyCodeAction "_i_" : '"_tType_"'"
			}
			Set tAction=$ZCVT($ZStrip($P(tType,"=",2),"<>W"),"U")
			Set:tAction'?1.(1"R",1"C",1"W",1"S",1"D",1"F") tAction=""
			If ""=tAction {
				$$$LOGWARNING("Unrecognized reply code action:'"_tType_"'")
				Continue
			}
			#; Make sure tFullAction has no more than 1 'W' in it; Quit if it is not just 'W'
			Set:""'=tMatchText tText=tText_$S(""'=tText:" and ",1:"")_tMatchText
			Set:tAction["W" tFullAction=""
			Set tFullAction=tAction_$S(tAction["W":"",1:tFullAction)
			Quit:tFullAction'?1."W"
		}
	}
	Set:""'=tText ..%ActionHint("CodeReason")=
		"Message body "_pRequest_" / "_pRequest.%Id()_" because "_
		$S('$IsObject(pResponse):"",1:"response "_pResponse_$S(""=pResponse.%Id():"",1:" / "_pResponse.%Id())_" ")_
		tText_" resulting in Action code "_tFullAction
	Quit tFullAction
]]></Implementation>
</Method>

<Method name="doReplyAction">
<Description>
Do the specified action for taking care of the message currently being processed</Description>
<Internal>1</Internal>
<FormalSpec><![CDATA[pAction:%String,pRequest:%Library.Persistent,pResponse:%Library.Persistent,&pSC:%Status]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tText=$G(..%ActionHint("CodeReason"))
	Set:""=tText tText="Message body "_pRequest_" / "_pRequest.%Id()_" because response '"_$G(pResponse)_$S($$$IsdefObject(pResponse)&&(""'=pResponse.%Id()):"' / "_pResponse.%Id(),1:"'")_" and error '"_$$$StatusDisplayString(pSC)_"' resulted in action code '"_pAction_"'"

	Set tActionDesc=$S(pAction["R":"Retrying", pAction["S":"Suspending", pAction["D":"Disabling on", pAction["F":"Quitting with error on", 1:"Accepting as Completed")
	If "Accepting as Completed"=tActionDesc {
		If pAction["W" {
			$$$LOGWARNING("Warning on "_tText)
		} Else {
			$$$sysTRACE("Accepting as Completed "_tText)
		}
		Set ..Retry=0, ..SuspendMessage=0
		Quit $$$OK ; suppress any error
	}
	Set tSC=$$$ERROR($$$EnsErrGeneral,tActionDesc_" "_tText)
	If pAction["R" {
		Set ..Retry=1
	} Else {
		Set tSC=..finalReplyAction(pAction,tSC,0)
		Set pAction="" ; clear because we just did it
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="finalReplyAction">
<Description>
Do the action specified for when all configured retries have been exhausted</Description>
<Internal>1</Internal>
<FormalSpec>pAction:%String,pSC:%Status,pFixError:%Boolean</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If pAction["S" {
		Set ..SuspendMessage=1, tActionDesc="Suspending on"
	} ElseIf pAction["D" {
#If ..#INVOCATION="InProc"
		$$$LOGWARNING("InProc '"_..%ConfigName_"' cannot invoke action 'D' (Disable)")
#Else
		Set:($ZS<$$$MAXBBSZ) $ZS=$$$MAXBBSZ
		Set tActionDesc="Disabling on"
		Do ##class(Ens.Job).Stop($Job)
		Do ##Class(Ens.Director).EnableConfigItem(..%ConfigName,0,0)
		Do ..SendRequestAsync("Ens.ScheduleHandler",$$$NULLOREF)
		Set ..%QuitTask=1+(pAction'["F"), ..Retry=1 ; we are quitting but the retry flag will force us to requeue the current message
#EndIf
	} ElseIf pAction["F" {
		// No work required here ; just quit with error
		Set tActionDesc="Discarding message on"
		Set ..SuspendMessage=0
	} Else { ; ??
		$$$LOGWARNING($$$StatusDisplayString(pSC))
		Set pSC=$$$OK, pFixError=0
	}
	Set:pFixError pSC=$$$ERROR($$$EnsErrGeneral,tActionDesc_" "_$$$StatusDisplayString(pSC))
	Quit pSC
]]></Implementation>
</Method>

<Method name="OnKeepalive">
<Description>
This method will be called within KeepaliveInterval of the last return from OnTask() or OnKeepalive().
It is called via the Adapter's OnKeepalive() method, which is called from the Host.OnTask() method;
if there is no Adapter there is no keepalive call.</Description>
<FormalSpec>pAdapterStatus:%Status</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=pAdapterStatus
	If $$$ISERR(tSC) {
		$$$sysTRACE("calling OnError K")
		Set tDoAlert=..OnError(.tSC)
		If $$$ISERR(tSC) {
			Set tTxt=$P($$$StatusDisplayString(tSC)," -- ") ; strip off "logged as" varying text
			Set:'..%AlertStartTime&&..AlertOnError&&..AlertRetryGracePeriod&&(tTxt'=..%LastReportedError) ..%AlertStartTime=$ZH
			If ..%AlertStartTime {
				If $ZH>=(..%AlertStartTime+..AlertRetryGracePeriod) {
					Set ..%AlertStartTime=0
					If tTxt'=..%LastReportedError { $$$LOGERROR("Alerting at expiration of retry grace period ("_..AlertRetryGracePeriod_") for "_tTxt) }
					Else { $$$LOGINFO("Alerting at expiration of retry grace period ("_..AlertRetryGracePeriod_") for "_tTxt) }
				} Else {
					Set tDoAlert=0
					If tTxt'=..%LastReportedError { $$$LOGERROR("Not Alerting during retry grace period ("_..AlertRetryGracePeriod_") for "_tTxt) }
					Else { $$$LOGINFO("Not Alerting during retry grace period ("_..AlertRetryGracePeriod_") for "_tTxt) }
				}
			} Else {
				If tTxt'=..%LastReportedError { $$$LOGSTATUS(tSC) }
				Else { Set tDoAlert=0 }
			}
			Do:tDoAlert&&..AlertOnError ..SendAlert(##class(Ens.AlertRequest).%New($LB(..%ConfigName,$$$StatusDisplayString(tSC))))

			Set tConfigName=..%ConfigName
			$$$SetHostMonitor(tConfigName,$$$eMonitorStatus,"Error")
#If ..#INVOCATION="Queue"
			$$$SetJobMonitor(tConfigName,$$$SystemName_":"_$Job,$$$eMonitorStatus,"Error")
#EndIf
			Set:'..%QuitTask tSC=$$$OK
		} Else { Set ..%AlertStartTime=0, tTxt="" }
	} Else { Set ..%AlertStartTime=0, tTxt="" }
	Set ..%LastReportedError=tTxt
	Quit tSC
]]></Implementation>
</Method>

<Method name="MessageHandler">
<Description>
This method dispatches requests to the methods according to the message map</Description>
<Internal>1</Internal>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pRequest:%Library.Persistent,*pResponse:%Library.Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do %code.WriteLine(" Set $ZT=""Trap"",$EC="""",tSC=$$$OK")
	Do %code.WriteLine(" do {")
	Set tSC=$$$OK
	Do {
		Kill %EnsBPCompile(%ISCName,"MessageMap",%class.Name)
		#; Find and save the first arg type of the OnMessage() method for the current subclass
		Set tIndex = %compiledclass.Methods.FindObjectId(%class.Name_"||OnMessage")
		If ""'=tIndex,%compiledclass.Methods.GetAt(tIndex).Origin'="Ens.BusinessOperation" {
			Set tFormalSpec = %compiledclass.Methods.GetAt(tIndex).FormalSpec
			Set tMessageType=$P($P(tFormalSpec,",",1),":",2)
			Set tResponseType=$P($P(tFormalSpec,",",2),":",2)
			Set %EnsBPCompile(%ISCName,"MessageMap",%class.Name,0)=$lb(tMessageType,tResponseType)
		}
		Set tSC=$$resolveMessageMap(.tMappedMessages,%class,%compiledclass) Quit:$$$ISERR(tSC)
		Set iItem=0
		For tMessageCount=1:1:$g(tMappedMessages) {
			Set tMessageType=$li(tMappedMessages(tMessageCount),1)
			Set tActionMethod=$li(tMappedMessages(tMessageCount),2)
			Set tIndex = %compiledclass.Methods.FindObjectId(%class.Name_"||"_tActionMethod)
			If ""'=tIndex {
				Set tFormalSpec = %compiledclass.Methods.GetAt(tIndex).FormalSpec
				#; TODO: Check that the 1st arg type of the referenced method matches the MapItem MessageType and that it exists
				Set tResponseType=$P($P(tFormalSpec,",",2),":",2)
			} Else {
				Set tSC=$$$ERROR($$$GeneralError,"Method "_tActionMethod_" referenced in MessageMap does not exist")
				Quit
			}
			// Make sure to expand any omitted package using the current classes package
			Set:tMessageType'["." tMessageType = $P(%class.Name,".",1,$L(%class.Name,".")-1) _ "." _ tMessageType
			
			Set %EnsBPCompile(%ISCName,"MessageMap",%class.Name,$I(iItem))=$lb(tMessageType,tResponseType)
			Do %code.WriteLine(" If pRequest.%IsA("""_tMessageType_""") {")
			Do %code.WriteLine("  $$$NEWOUTIOLOGENTRY($$$OK,"""","""_tActionMethod_""",pRequest)")
			Do %code.WriteLine("  $$$SetJobMonitor(..%ConfigName,$$$SystemName_"":""_$Job,$$$eMonitorMethod,"""_tActionMethod_""")")
			Do %code.WriteLine("  Set tSC=.."_tActionMethod_"(.pRequest,.pResponse)")
			Do %code.WriteLine("  $$$SetJobMonitor(..%ConfigName,$$$SystemName_"":""_$Job,$$$eMonitorMethod,"""")")
			Do %code.WriteLine("  $$$sysTRACE("""_tActionMethod_"() returned with status ""_$$$StatusDisplayString(tSC)_"", Retry=""_..Retry_"", SuspendMessage=""_..SuspendMessage_"", DeferResponse=""_..DeferResponse_"", Response=""_$S('$$$IsdefObject(pResponse):"""", 1:pResponse_""/""_$S('pResponse.%Extends(""%Persistent""):"""", 1:pResponse.%Id())))")
			Do %code.WriteLine("  $$$CLOSEIOLOGENTRY(tSC,"""",$G(pResponse))")
			Do %code.WriteLine("  Quit")
			Do %code.WriteLine(" }")
		}
		Quit:$$$ISERR(tSC)
		;
		Do %code.WriteLine(" $$$NEWOUTIOLOGENTRY($$$OK,"""",""OnMessage"",pRequest)")
		Do %code.WriteLine(" $$$SetJobMonitor(..%ConfigName,$$$SystemName_"":""_$Job,$$$eMonitorMethod,""OnMessage"")")
		Do %code.WriteLine(" Set tSC=..OnMessage(.pRequest,.pResponse)")
		Do %code.WriteLine(" $$$SetJobMonitor(..%ConfigName,$$$SystemName_"":""_$Job,$$$eMonitorMethod,"""")")
		Do %code.WriteLine(" $$$sysTRACE(""OnMessage() returned with status ""_$$$StatusDisplayString(tSC)_"", Retry=""_..Retry_"", SuspendMessage=""_..SuspendMessage_"", DeferResponse=""_..DeferResponse_"", Response=""_$S('$$$IsdefObject(pResponse):"""", 1:pResponse_""/""_$S('pResponse.%Extends(""%Persistent""):"""", 1:pResponse.%Id())))")
		Do %code.WriteLine(" $$$CLOSEIOLOGENTRY(tSC,"""",pResponse)")
	} While 0
	;
	Do %code.WriteLine(" } While 0")
	Do %code.WriteLine("Exit")
	Do %code.WriteLine(" If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_"" open user transaction""_$S(tTL>1:""s"",1:"""")_"" found after BO MessageHandler method; committing before proceeding"")")
	Do %code.WriteLine(" Quit tSC")
	Do %code.WriteLine("Trap")
	Do %code.WriteLine(" Set $ZT="""",tSC=$$$SystemError")
	Do %code.WriteLine(" Goto Exit")
	;
	Quit tSC

resolveMessageMap(pMessages,pClassDefinition,pCompiledClass)
	If '$IsObject(pClassDefinition) Quit $$$OK
	If pClassDefinition.Name="Ens.BusinessOperation" Quit $$$OK
	New %tMapItems,%tCount,%tItem,%tSuperCount,%tSC,%tSuper
	Set %tSC=##class(Ens.Util.XML.Reader).ObjectsFromXData(.%tMapItems,pClassDefinition,"MessageMap","Ens.Config.MessageMap")
	If $$$ISERR(%tSC),$$$StatusEquals(%tSC,$$$EnsErrXDataBlockNotDefined) Set %tSC=$$$OK
	If $$$ISERR(%tSC) Quit %tSC
	If $IsObject(%tMapItems) {
		For %tCount=1:1:%tMapItems.Count() {
			Set %tItem=%tMapItems.GetAt(%tCount)
			If %tItem.MessageType="" Continue
			Set pMessages($i(pMessages))=$lb(%tItem.MessageType,%tItem.ActionMethod)
		}
	}
	If '$IsObject(pCompiledClass) Quit $$$OK
	For %tSuperCount=$l(pCompiledClass.Super,","):-1:1 {
		Set %tSuper=$piece(pCompiledClass.Super,",",%tSuperCount)
		If %tSuper'="" Set %tSC=$$resolveMessageMap(.pMessages,##class(%Dictionary.ClassDefinition).%OpenId(%tSuper),##class(%Dictionary.CompiledClass).%OpenId(%tSuper)) Quit:$$$ISERR(%tSC)
	}
	Quit %tSC
	;
]]></Implementation>
</Method>

<Method name="OnMessage">
<Description>
This is the default message handler.  All request types not declared in the message map are delivered here</Description>
<FormalSpec>pRequest:%Library.Persistent,*pResponse:%Library.Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$EnsError($$$EnsErrRequestNotHandled,pRequest)
]]></Implementation>
</Method>

<Method name="SendRequestSync">
<Description>
Use this method to dispatch an Ensemble business invocation synchronously</Description>
<FormalSpec><![CDATA[pTargetDispatchName:%String,pRequest:%Library.Persistent,&pResponse:%Library.Persistent,pTimeout:%Numeric=-1,pDescription:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$sysTRACE("call to "_pTargetDispatchName)
	Set tZH=$ZH
	Set tTargetConfigName = $get($$$DispatchNameToConfigName(pTargetDispatchName)) If tTargetConfigName="" Quit $$$EnsError($$$EnsErrBusinessDispatchNameNotRegistered,pTargetDispatchName)
	Set tTargetBusinessClass = $$$ConfigClassName(tTargetConfigName)
	Set tSC=$classmethod(tTargetBusinessClass,"acceptRequestSync",..%ConfigName,tTargetConfigName,.pRequest,.pResponse,..%SessionId,pTimeout,,pDescription)
	$$$catTRACE("timing","duration of sync call: "_($ZH-tZH))
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendRequestAsync">
<Description>
Use this method to dispatch an Ensemble business invocation asynchronously</Description>
<FormalSpec>pTargetDispatchName:%String,pRequest:%Library.Persistent,pDescription:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$sysTRACE("call to "_pTargetDispatchName)
	Set tZH=$ZH
	Set tTargetConfigName = $get($$$DispatchNameToConfigName(pTargetDispatchName)) If tTargetConfigName="" Quit $$$EnsError($$$EnsErrBusinessDispatchNameNotRegistered,pTargetDispatchName)
	Set tTargetBusinessClass = $$$ConfigClassName(tTargetConfigName)
	Set tSC=$classmethod(tTargetBusinessClass,"acceptRequestAsync",..%ConfigName,tTargetConfigName,.pRequest,$$$eMessagePriorityAsync,"",..%SessionId,"",,pDescription)
	$$$catTRACE("timing","duration of async call: "_($ZH-tZH))
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnFailureTimeout">
<Description><![CDATA[
Override this method to provide custom handling of retry / failure timeout.<p/>
Set ..Retry=1 to override normal error return and re-evaluate flag properties.<p/>
Return 0 to skip further (default) FailureTimeout processing, 1 to perform default processing.]]></Description>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[pRequest:%Library.Persistent,*pResponse:%Library.Persistent,&pSC:%Status]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[1
]]></Implementation>
</Method>

<Method name="OnError">
<Description>
Override this method to provide custom error handling. Return 0 means skip standard AlertOnError behavior.</Description>
<FormalSpec><![CDATA[&pStatus:%Status]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit 1
]]></Implementation>
</Method>

<Method name="SendAlert">
<Description>
Use this method to send an alert message</Description>
<FormalSpec>pAlertRequest:Ens.AlertRequest</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	
	If ($$$JobConfigName="Ens.Alert") {
		#; To avoid infinite loop, no SendAlert from Ens.Alert
		$$$LOGALERT("From Ens.Alert: "_pAlertRequest.AlertText)
	} ElseIf (""=$G($$$DispatchNameToConfigName("Ens.Alert"))) {
		$$$LOGALERT(pAlertRequest.AlertText)
	} Else {
		Do pAlertRequest.%Save()
		$$$LOGALERT(pAlertRequest.AlertText_" (alert request ID="_pAlertRequest.%Id()_")")
		Set tSC = ..SendRequestAsync("Ens.Alert",pAlertRequest)
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="DeferResponse">
<Description>
This method returns the deferred response token, and marks the current message handling to be deferred</Description>
<FormalSpec><![CDATA[&pToken:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..DeferResponse=1
	Set pToken=..GetDeferredResponseToken(..%RequestHeader)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetMessageList">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..GetRequestClassList()
]]></Implementation>
</Method>

<Method name="GetRequestClassList">
<Description>
Return a collection in $List format of all Request classes found in OnMessage and in the Message Map method signatures</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>MessageHandler</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set i="" For {
		Set i=$Order(%EnsBPCompile(%ISCName,"MessageMap",%class.Name,i)) Quit:i=""
		Set tRequestClass=$li(%EnsBPCompile(%ISCName,"MessageMap",%class.Name,i),1)
		Set tMessageClassList(tRequestClass)=""
	}
	If $$$comMemberKeyGet(%class,$$$cCLASSmethod,"OnMessage",$$$cMETHrunnable) {
		// Check the OnMessage signature for additional request types
		Set tSignature=$$$comMemberKeyGet(%class.Name,$$$cCLASSmethod,"OnMessage",$$$cMETHformalspecparsed)
		Set tRequestClass=$lg($lg(tSignature,1),2)
		Set tMessageClassList(tRequestClass)=""
	}
	;
	If %class.Name="Ens.BusinessOperation" {
		Do %code.WriteLine(" Quit """"")
	} Else {
		Do %code.WriteLine(" Set tList=""""")
		Set tRequestClass="" For { Set tRequestClass=$o(tMessageClassList(tRequestClass))  Quit:tRequestClass=""
			Do %code.WriteLine(" Set tList=tList_$lb("""_tRequestClass_""")")
		}
		Do %code.WriteLine(" Quit tList")
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetResponseClassList">
<Description>
Return a collection in $List format of all Response classes found in OnMessage and in the Message Map method signatures</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pRequest:%String=""</FormalSpec>
<GenerateAfter>GetRequestClassList</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If %class.Name="Ens.BusinessOperation" {
		Do %code.WriteLine(" Quit """"")
	} Else {
		Set i="" For { Set i=$Order(%EnsBPCompile(%ISCName,"MessageMap",%class.Name,i))  Quit:i=""
			Set tRequestClass=$li(%EnsBPCompile(%ISCName,"MessageMap",%class.Name,i),1)
			Set tResponseClass=$li(%EnsBPCompile(%ISCName,"MessageMap",%class.Name,i),2)
			Set tMessageClassList(tRequestClass,tResponseClass)=""
		}
		If $$$comMemberKeyGet(%class,$$$cCLASSmethod,"OnMessage",$$$cMETHrunnable) {
			// Check the OnMessage signature for additional request/response types
			Set tSignature=$$$comMemberKeyGet(%class.Name,$$$cCLASSmethod,"OnMessage",$$$cMETHformalspecparsed)
			Set tRequestClass=$lg($lg(tSignature,1),2)
			Set tResponseClass=$lg($lg(tSignature,2),2)
			Set tMessageClassList(tRequestClass,tResponseClass)=""
		}
		Set (tRequestClass,tFullResponseClassList)="" For { Set tRequestClass=$o(tMessageClassList(tRequestClass))  Quit:tRequestClass=""
			Set (tResponseClass,tResponseClassList)="" For { Set tResponseClass=$o(tMessageClassList(tRequestClass,tResponseClass))  Quit:tResponseClass=""
				Set tResponseClassList=tResponseClassList_","""_tResponseClass_""""
			}
			Set tFullResponseClassList=tFullResponseClassList_tResponseClassList
			If ""'=tResponseClassList {
				Set tResponseClassList="$lb("_$e(tResponseClassList,2,*)_")"
				Do %code.WriteLine(" If pRequest="""_tRequestClass_""" Quit "_tResponseClassList)
			}
		}
		If ""'=tFullResponseClassList {
			Set tFullResponseClassList="$lb("_$e(tFullResponseClassList,2,*)_")"
			Do %code.WriteLine(" If pRequest="""" Quit "_tFullResponseClassList)
		}
		Do %code.WriteLine(" Quit """"")
	}
	Kill %EnsBPCompile(%ISCName,"MessageMap",%class.Name)
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Ens.BusinessProcess">
<ClassType>persistent</ClassType>
<IncludeCode>%sySystem</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,Ens.Host,Ens.Settings</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59268,43369.482</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="ReplyCodeActions">
<Description><![CDATA[
<p>A comma-separated list of codes specifying what action this Process will take on various reply status conditions.
The format of the list is: <br /> &lt;code&gt;=&lt;actions&gt;,(&lt;code&gt;,&lt;code&gt;)=&lt;actions&gt;,...<br/>
Types of reply status condition are identified by a specification code:
<ul style="list-style-type: none;">
<li><b>E</b> - Error status returned from message handler</li>
<li><b>E#&lt;statuscode&gt;</b> - Error status returned from message handler has status code equal to &lt;statuscode&gt;</li>
<li><b>E*&lt;text&gt;</b> - Error status returned from message handler contains text string &lt;text&gt;</li>
<li><b>X</b> - there is no reply message at all</li>
</ul></p>
<p>The following values for &lt;actions&gt; may be used alone or in combinations:
<ul style="list-style-type: none;">
<li><b>C</b> - Treat the message as Completed OK.</li>
<li><b>W</b> - Log a warning. If no other non-warning &lt;actions&gt; are triggered, the message will be treated as Completed OK.</li>
<li><b>R</b> - Retry the message according to the configured RetryInterval and FailureTimeout; finally Fail unless a 
different action is also specified.</li>
<li><b>S</b> - Suspend the message, log an error, and move on to try the next message.</li>
<li><b>D</b> - Disable the Process, log an error and restore the original incoming message to the front of the Process's queue.</li>
<li><b>F</b> - Fail with an error and move on to try the next message from the Process's queue.</li></ul>
<b>NOTE:</b> the D action can only immediately stop all instances of a Business Process if the BP is configured with PoolSize=1.
If PoolSize=0 this action will disable all Business Processes that share the Actor pool.</p>
<p>An example of a valid ReplyCodeActions specification is 'E#6301=R,E#&lt;Ens&gt;ErrGeneral=RD,E=F'. This specification will result in a 
retry when error code 6301 is encountered. When error code &lt;Ens&gt;ErrGeneral is encountered, the Operation first retries to send 
the message until FailureTimeout and then, if the error continues, it disables the Operation instead of failing. Any other errors will 
cause the Operation to fail processing of the current message and return the error status to the caller, without retrying first.</p>
<p><b>The default behavior is 'E=F'.</b> Thus any error status will result in the error being logged and returned to the caller, 
no retries will be attempted, and the Process will move on to try the next message from its queue.</p>
<p>All codes where &lt;actions&gt; consists of only 'W' (for 'log a Warning') will be evaluated, and a warning will be
generated for each matching &lt;code&gt;. Other &lt;code&gt; values will be evaluated in left-to-right order, executing the
first matching &lt;code&gt; that has a non-warning &lt;actions&gt; value. As noted in the details for the 'W' flag, an error
that only triggers 'W' &lt;actions&gt; will be treated as Completed OK.</p>]]></Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="RetryInterval">
<Description>
How frequently to retry access to the output system</Description>
<Type>%Numeric</Type>
<InitialExpression>5</InitialExpression>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="AlertRetryGracePeriod">
<Description>
When AlertOnError is True and the Process is retrying, refrain from alerting if the Process succeeds within this number of seconds after an error</Description>
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="FailureTimeout">
<Description><![CDATA[
How long to keep retrying before giving up and returning an error code. <br/>
-1 means never give up.]]></Description>
<Type>%Numeric</Type>
<InitialExpression>15</InitialExpression>
<Parameter name="MINVAL" value="-1"/>
</Property>

<Property name="QueueCountAlert">
<Description><![CDATA[
Number of messages on this item's queue needed to trigger an Alert message to be sent. Note that no further
alerts will be sent unless the number of messages on the queue drops below 80% of this number and then rises again to this number. <br/>
Note that this alert will be sent even if AlertOnError is False. <br/>
Zero means no alerts of this type will be sent.]]></Description>
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="QueueWaitAlert">
<Description><![CDATA[
The number of seconds a message at the front of the queue may have waited since being queued before an alert is triggered.<br/>
Only one alert will be raised per host item per sequential trigger of the queue wait threshold. <br/>
Note that this alert will be sent even if AlertOnError is False. <br/>
Zero means no alerts of this type will be sent.]]></Description>
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="MINVAL" value="0"/>
</Property>

<Parameter name="SETTINGS">
<Default>-ThrottleDelay,ReplyCodeActions,RetryInterval,AlertRetryGracePeriod:Alerting,FailureTimeout,QueueCountAlert:Alerting,QueueWaitAlert:Alerting</Default>
</Parameter>

<UDLText name="T">
<Content><![CDATA[/* override as transient - not used in BP */
]]></Content>
</UDLText>

<Property name="ThrottleDelay">
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
<Transient>1</Transient>
</Property>

<Parameter name="SKIPMESSAGEHISTORY">
<Description>
If this parameter is TRUE, then arrays %MessagesSent and %MessagesReceived will not be populated.</Description>
<Type>BOOLEAN</Type>
<Default>0</Default>
</Parameter>

<Property name="%request">
<Description>
non-protected properties to be used by subclass methods</Description>
<Type>%Library.Persistent</Type>
<Calculated>1</Calculated>
</Property>

<Property name="%response">
<Description>
non-protected properties to be used by subclass methods</Description>
<Type>%Library.Persistent</Type>
<Calculated>1</Calculated>
</Property>

<Property name="%responseId">
<Type>%String</Type>
<Parameter name="COLLATION" value="EXACT"/>
<Parameter name="MAXLEN"/>
</Property>

<Property name="%responseClassName">
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
</Property>

<Property name="%PrimaryRequestHeader">
<Description>
protected properties</Description>
<Type>Ens.MessageHeader</Type>
</Property>

<Property name="%CurrentResponseHeader">
<Type>Ens.MessageHeader</Type>
<Transient>1</Transient>
</Property>

<Property name="%MasterPendingResponses">
<Type>%String</Type>
<Collection>list</Collection>
<SqlFieldName>MasterPendingResponses</SqlFieldName>
<Parameter name="MAXLEN"/>
</Property>

<Property name="%IsCompleted">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="%PrimaryResponseHeader">
<Type>Ens.MessageHeader</Type>
</Property>

<Property name="%RepliedStatus">
<Type>%Integer</Type>
<InitialExpression>$$$eRepliedStatusNotCalled</InitialExpression>
</Property>

<Property name="%TimeCreated">
<Type>Ens.DataType.UTC</Type>
</Property>

<Property name="%TimeCompleted">
<Type>Ens.DataType.UTC</Type>
</Property>

<Property name="%IsTimerInterrupted">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="%IsTerminated">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="%StatusCode">
<Type>%Status</Type>
<InitialExpression>$$$OK</InitialExpression>
</Property>

<Property name="%MessagesSent">
<Type>%String</Type>
<Collection>list</Collection>
<SqlFieldName>MessagesSent</SqlFieldName>
<Parameter name="MAXLEN"/>
</Property>

<Property name="%MessagesReceived">
<Type>%String</Type>
<Collection>list</Collection>
<SqlFieldName>MessagesReceived</SqlFieldName>
<Parameter name="MAXLEN"/>
</Property>

<Property name="%MasterPendingResponsesOld">
<Description>
This property maps to the old storage location of %MasterPendingResponses</Description>
<Type>%String</Type>
<Collection>list</Collection>
<Parameter name="MAXLEN"/>
</Property>

<Property name="%MessagesSentOld">
<Description>
This property maps to the old storage location of %MessagesSent</Description>
<Type>%String</Type>
<Collection>list</Collection>
<Parameter name="MAXLEN"/>
</Property>

<Property name="%MessagesReceivedOld">
<Description>
This property maps to the old storage location of %MessagesReceived</Description>
<Type>%String</Type>
<Collection>list</Collection>
<Parameter name="MAXLEN"/>
</Property>

<Property name="%ActionHint">
<Description>
Subclasses can store hint values here for use in determining what ReplyCodeAction to apply</Description>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
<Transient>1</Transient>
</Property>

<Index name="TimeCreated">
<Properties>%TimeCreated</Properties>
</Index>

<Index name="SessionId">
<Properties>%SessionId</Properties>
</Index>

<Property name="Retry">
<Description>
Set this property to 1 if you want to retry the current message again</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="SuspendMessage">
<Description>
Set this property to 1 if you want to mark the current message as "Suspended"</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="SendRequestSync">
<Description><![CDATA[
Use this method to dispatch an Ensemble business invocation synchronously
WARNING: Using this method can make your Business Process subject to deadlock if you use this method to invoke another BP and both BPs share the production's common Actor Pool. To avoid such a deadlock, structure your code to use SendRequestAsync() instead of this method, and handle response messages in the OnResponse() callback method.  Alternatively, configure the called BP(s) with their own PoolSize > 0 so the main BP won't compete with them for Pool jobs.]]></Description>
<FormalSpec><![CDATA[pTargetDispatchName:%String,pRequest:%Library.Persistent,&pResponse:%Library.Persistent,pTimeout:%Numeric=-1,pDescription:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$sysTRACE("call to "_pTargetDispatchName)
	Set tZH=$zh
	Set tTargetConfigName = $get($$$DispatchNameToConfigName(pTargetDispatchName))  Quit:""=tTargetConfigName $$$EnsError($$$EnsErrBusinessDispatchNameNotRegistered,pTargetDispatchName)
	Set tTargetBusinessClass = $$$ConfigClassName(tTargetConfigName)
	Set tSC = $classmethod(tTargetBusinessClass,"acceptRequestSync",..%ConfigName,tTargetConfigName,.pRequest,.pResponse,..%SessionId,pTimeout,.tRequestHeader,pDescription,..%SuperSession)
	If '..#SKIPMESSAGEHISTORY Do:$$$ISOK(tSC) ..%MessagesSent.Insert(tRequestHeader.%Id())
	$$$catTRACE("timing","duration of sync call: "_($zh-tZH))
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendRequestAsync">
<Description>
Use this method to dispatch an Ensemble business invocation asynchronously</Description>
<FormalSpec>pTargetDispatchName:%String,pRequest:Request,pResponseRequired:%Boolean=1,pCompletionKey:%String="",pDescription:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$sysTRACE("call to "_pTargetDispatchName)
	Set tZH=$zh
	Set tSC = ..SendRequestAsyncInternal(pTargetDispatchName, pRequest, pResponseRequired, pCompletionKey,0,pDescription)
	$$$catTRACE("timing","duration of async call: "_($zh-tZH))
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendAlert">
<Description>
Use this method to send an alert message</Description>
<FormalSpec>pAlertRequest:Ens.AlertRequest</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	
	If ($$$JobConfigName="Ens.Alert") {
		#; To avoid infinite loop, no SendAlert from Ens.Alert
		$$$LOGALERT("From Ens.Alert: "_pAlertRequest.AlertText)
	} ElseIf (""=$G($$$DispatchNameToConfigName("Ens.Alert"))) {
		$$$LOGALERT(pAlertRequest.AlertText)
	} Else {
		Do pAlertRequest.%Save()
		$$$LOGALERT(pAlertRequest.AlertText_" (alert request ID="_pAlertRequest.%Id()_")")
		Set tSC = ..SendRequestAsync("Ens.Alert",pAlertRequest)
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="SetTimer">
<Description>
This method set up a timer for how long to wait for pending asynchronous responses</Description>
<FormalSpec>pTimeout:%String,pCompletionKey:%String="",pControlledCompletionKeys:%String="*",*pAlarmHandle:%String,pDescription:%String="",pIsTimer=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tAlarmRequest = ##class(Ens.AlarmRequest).%New()
	$$$ASSERT($IsObject(tAlarmRequest))
	Set tAlarmRequest.Timeout = pTimeout
	Set tSC=tAlarmRequest.%Save() Quit:$$$ISERR(tSC) tSC
	Set pAlarmHandle = tAlarmRequest.%Id()
	Quit ..SendRequestAsyncInternal("Ens.Alarm",tAlarmRequest,1,pCompletionKey,pIsTimer,pControlledCompletionKeys,pDescription)
]]></Implementation>
</Method>

<Method name="SendRequestAsyncInternal">
<Internal>1</Internal>
<FormalSpec>pTargetDispatchName:%String,pRequest:Request,pResponseRequired:%Boolean=1,pCompletionKey:%String="",pIsTimer:%Boolean,pControlledCompletionKeys:%String="",pDescription:%String="",pSimSync:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tTargetConfigName = $get($$$DispatchNameToConfigName(pTargetDispatchName)) Quit:""=tTargetConfigName $$$EnsError($$$EnsErrBusinessDispatchNameNotRegistered,pTargetDispatchName)
	Set tTargetBusinessClass=$$$ConfigClassName(tTargetConfigName)
	Set tPriority=$s(pSimSync:$$$eMessagePrioritySimSync,1:$$$eMessagePriorityAsync)
	#; elevate the priority level the at least that of ..%PrimaryRequestHeader
	If ((pResponseRequired)&&(..%RepliedStatus'=$$$eRepliedStatusSent)&&(..%PrimaryRequestHeader.Priority<tPriority)) {
		Set tPriority=..%PrimaryRequestHeader.Priority
	}
	If pResponseRequired {
		Set tBPID=..%Id()  Set:""=tBPID tSC=..%Save(), tBPID=..%Id() ; ensure that we have a return address
		Set tSC=$classmethod(tTargetBusinessClass,"acceptRequestAsync",..%ConfigName,tTargetConfigName,pRequest,tPriority,..QueueName(),..%SessionId,tBPID,.tRequestHeader,pDescription,..%SuperSession)
		Do:$$$ISOK(tSC) ..%MasterPendingResponses.Insert($lb(tRequestHeader.%Id(),pCompletionKey,pIsTimer,pControlledCompletionKeys))
	} Else {
		Set tSC=$classmethod(tTargetBusinessClass,"acceptRequestAsync",..%ConfigName,tTargetConfigName,pRequest,tPriority,"",..%SessionId,..%Id(),.tRequestHeader,pDescription,..%SuperSession)
	}
	If '..#SKIPMESSAGEHISTORY Do:$$$ISOK(tSC) ..%MessagesSent.Insert(tRequestHeader.%Id())
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnTask">
<Internal>1</Internal>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$ASSERT(0_"BP's OnTask should never be called, Actor's should")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="MessageHeaderHandler">
<Description>
This method is for internal use - called for InProc from inprocRequest() or for Queued BPs from the Actor's MessageHeaderHandler()</Description>
<Internal>1</Internal>
<FormalSpec>pRequestHeader:Ens.MessageHeader,*pResponseHeader:Ens.MessageHeader,*pResponseIsError</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Set tSC=$$$OK, pResponseIsError=""
 Set $EC=""  try {
	If '..#SKIPMESSAGEHISTORY Do ..%MessagesReceived.Insert(pRequestHeader.%Id())
	If pRequestHeader.Type = $$$eMessageTypeRequest {
		$$$ASSERT(..%PrimaryRequestHeader=$$$NULLOREF)
		Set ..%PrimaryRequestHeader=pRequestHeader, $$$JobCurrentHeaderId=pRequestHeader.%Id()
		Set ..%Concurrency=4
		Set tSC=..%Save()  Quit:$$$ISERR(tSC)
		Set (..%SessionId,$$$JobSessionId)=pRequestHeader.SessionId
		Set (..%SuperSession,$$$JobSuperSession)=pRequestHeader.SuperSession

		Set ..%TimeCreated = $$$timeUTC
		Do pRequestHeader.SetStatus($$$eMessageStatusDelivered)
		Set tResponse=$$$NULLOREF

		If $D($$$EnsCrashedMessage(pRequestHeader.%Id())) {
			Kill $$$EnsCrashedMessage(pRequestHeader.%Id())
			Set tSC=$$$EnsError($$$EnsErrPreviouslyCrashedMessage,pRequestHeader.%Id())
		} Else {
			Set $EC=""  try {
				Set tSC=..OnRequest(..%request,.tResponse)
			} catch {
				Set tSC=$$$EnsSystemError
			}
			If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after OnRequest(); committing before proceeding")
		}
		Set:$$$ISOK(tSC) tSC=..%responseSet(tResponse)
		Quit:$$$ISERR(tSC)
	} ElseIf pRequestHeader.Type = $$$eMessageTypeTerminate {
		Set $$$JobCurrentHeaderId=pRequestHeader.%Id()
		Do pRequestHeader.SetStatus($$$eMessageStatusDelivered)
		Do ..%MasterPendingResponses.Clear()
		Set ..%IsTerminated=1
		Set tSC=$classmethod(pRequestHeader.MessageBodyClassName,"%OpenId",pRequestHeader.MessageBodyId).StringValue
	} Else {
		Set ..%CurrentResponseHeader=pRequestHeader, $$$JobCurrentHeaderId=pRequestHeader.%Id()
		Set $$$JobSessionId=..%SessionId
		Set $$$JobSuperSession=..%SuperSession
		#; deal with a response, pRequestHeader should have .Type=$$$eMessageTypeResponse
		#; ignore the response once the RunStatus is completed
		If ..%IsCompleted {
			$$$sysTRACE("Discarding response '"_pRequestHeader.%Id()_"' to already-completed process "_..%Id())
			Do pRequestHeader.SetStatus($$$eMessageStatusDiscarded)
			Quit
		}
		#; search the pending sync list for this message body
		Set tCallRequestHeader = ##class(Ens.MessageHeader).%OpenId(pRequestHeader.CorrespondingMessageId)
		If tCallRequestHeader.MessageBodyClassName'="" {
			Set tCallRequest = $classmethod(tCallRequestHeader.MessageBodyClassName,"%OpenId",tCallRequestHeader.MessageBodyId,,.tSC)
			If '$IsObject(tCallRequest) Set tSC=$$$ERROR($$$EnsErrGeneral,"Could not open callrequest MessageBody "_tCallRequestHeader.MessageBodyId_" for MessageHeader #"_tCallRequestHeader.%Id()_" with body class "_tCallRequestHeader.MessageBodyClassName_":"_$$$StatusDisplayString(tSC))  Quit
		} Else {
			Set tCallRequest=$$$NULLOREF
		}
		Set tIndex=0 For i=1:1:..%MasterPendingResponses.Count() {
			Set tEntry=..%MasterPendingResponses.GetAt(i)
			If $li(tEntry,1)=pRequestHeader.CorrespondingMessageId Set tIndex=i,tCompletionKey=$li(tEntry,2),tIsTimer=$li(tEntry,3),pControlledCompletionKeys=$li(tEntry,4) Quit
		}
		#; if response is not in the pending sync list, ignore it
		If tIndex=0 {
			$$$sysTRACE("Discarding response '"_pRequestHeader.%Id()_"' belonging to message '"_pRequestHeader.CorrespondingMessageId_"' while in process "_..%Id())
			Do pRequestHeader.SetStatus($$$eMessageStatusDiscarded)
			Quit
		}
		#; set status to be 'delivered'
		Do pRequestHeader.SetStatus($$$eMessageStatusDelivered)

		#; an asynchronous call responded with an error - call OnError
		Set pResponseIsError = pRequestHeader.IsError
		If pResponseIsError {
			Set tResponse=..%response

			Set tErroredResponseStatus=pRequestHeader.ErrorStatus
			Set $EC=""  try {
				#; Returning $$$OK from this method causes the BusinessProcess to recover from this error
				Set tSC=..OnError(..%request,.tResponse,tCallRequest,tErroredResponseStatus,tCompletionKey)

				#; If we are prepared to handle the errored response (BPL Business Processes do this)
				If ..WillHandleErroredResponse() {
					#; The BP is willing to handle an errored response, prevent exit at this point; pResponseIsError will be tested and acted upon below
					Set tSC=$$$OK
				} Else {
					#; The OnError method 'handled' the error
					Set:$$$ISOK(tSC) pResponseIsError=0
				}
			} catch {
				Set tSC=$$$EnsSystemError, pResponseIsError="" ; new tSC for which OnError() has not been called
			}
			If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after OnError(); committing before proceeding")
			Quit:$$$ISERR(tSC)
			Set tSC=..%responseSet(tResponse)  If $$$ISERR(tSC) Set pResponseIsError=""  Quit
		}
		#; Remove this entry
		Do ..%MasterPendingResponses.RemoveAt(tIndex)

		#; Handle Timer timeout
		If tIsTimer {
			Set tResponse=..%response
			$$$catTRACE("bproc","calling OnTimeout")
			Set $EC=""  try {
				Set tSC=..OnTimeout(..%request,.tResponse,tCallRequest,tCompletionKey)
			} catch {
				Set tSC=$$$EnsSystemError
			}
			If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after OnTimeout(); committing before proceeding")
			$$$catTRACE("bproc","returned from OnTimeout")
			Set:$$$ISOK(tSC) tSC=..%responseSet(tResponse)
			Quit:$$$ISERR(tSC)

			For i=..%MasterPendingResponses.Count():-1:1 {
				Set tEntry=..%MasterPendingResponses.GetAt(i)
				If (pControlledCompletionKeys="*")||$listfind(pControlledCompletionKeys,$li(tEntry,2)) {
					Do ..%MasterPendingResponses.RemoveAt(i)
					Set tRequestHeader=##class(Ens.MessageHeader).%OpenId($li(tEntry,1))
					If tRequestHeader.MessageBodyClassName'="" {
						Set tMessageBody=$classmethod(tRequestHeader.MessageBodyClassName,"%OpenId",tRequestHeader.MessageBodyId,,.tSC1)
						If '$IsObject(tMessageBody) {
							$$$LOGWARNING("Could not open pending MessageBody "_tRequestHeader.MessageBodyId_" for MessageHeader #"_tRequestHeader.%Id()_" with body class "_tRequestHeader.MessageBodyClassName_":"_$$$StatusDisplayString(tSC1))
						} Else {
							$$$catTRACE("bproc","calling body %OnTimeout")
							Set $EC=""  try {
								Set tSC1 = tMessageBody.%OnTimeout()
								If $$$ISERR(tSC1) $$$LOGSTATUS(tSC1)
								$$$catTRACE("bproc","returned from body %OnTimeout")
							} catch ex {
								If ex.Name '= "<METHOD DOES NOT EXIST>" Do $$$EnsSystemError
							}
							If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after body %OnTimeout(); committing before proceeding")
						}
					}
				}
			}
		}
		#; clear the pending request list if timer is the only thing left
		If ..%MasterPendingResponses.Count()>0 {
			Set tHasNonTimer=0
			For i=1:1:..%MasterPendingResponses.Count() {
				Set tEntry=..%MasterPendingResponses.GetAt(i)
				If $li(tEntry,3)=0 Set tHasNonTimer=1 Quit
			}
			If tHasNonTimer=0 Do ..%MasterPendingResponses.Clear()
		}
		#; call OnResponse if the response is not an error
		#; we can get here when user chooses to ignore an error response
		If 'pResponseIsError {
			Set tResponse=..%response, pResponseIsError="" ; new tSC coming up for which OnError() has not been called
			#; Open message body of original Request and pass it to OnResponse()
			If pRequestHeader.MessageBodyClassName'="" {
				Set tMessageBody = $classmethod(pRequestHeader.MessageBodyClassName,"%OpenId",pRequestHeader.MessageBodyId,,.tSC)
				If '$IsObject(tMessageBody) Set tSC=$$$ERROR($$$EnsErrGeneral,"Could not open request MessageBody "_pRequestHeader.MessageBodyId_" for MessageHeader #"_pRequestHeader.%Id()_" with body class "_pRequestHeader.MessageBodyClassName_":"_$$$StatusDisplayString(tSC))  Quit
				Set:tIsTimer ..%IsTimerInterrupted=tMessageBody.IsInterrupted
			} Else {
				Set tMessageBody = $$$NULLOREF
			}
			If $D($$$EnsCrashedMessage(pRequestHeader.%Id())) {
				Kill $$$EnsCrashedMessage(pRequestHeader.%Id())
				Set tSC=$$$EnsError($$$EnsErrPreviouslyCrashedMessage,pRequestHeader.%Id())
			} Else {
				$$$catTRACE("bproc","calling OnResponse")
				Set $EC=""  try {
					Set tSC=..OnResponse(..%request,.tResponse,tCallRequest,tMessageBody,tCompletionKey)
				} catch {
					Set tSC=$$$EnsSystemError
				}
			If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after OnResponse(); committing before proceeding")
				$$$catTRACE("bproc","returned from OnResponse")
			}
			Set:$$$ISOK(tSC) tSC=..%responseSet(tResponse)
		} Else {
			#; This is executed when the BP is willing to handle an error returned from a call.
			#; Currently implemented by all BPL Business processes. The callresponse will not be available.
			Set tResponse=..%response
			$$$catTRACE("bproc","calling OnErroredResponse")
			Set $EC=""  try {
				Set tSC=..OnErroredResponse(tErroredResponseStatus,..%request,.tResponse,tCompletionKey)
				Set pResponseIsError=$$$ISERR(tSC)
			} catch {
				Set tSC=$$$EnsSystemError, pResponseIsError="" ; new tSC for which OnError() has not been called
			}
			If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after OnErroredResponse(); committing before proceeding")
			$$$catTRACE("bproc","returned from OnErroredResponse")
			Quit:$$$ISERR(tSC)
			Set tSC=..%responseSet(tResponse)
		}
		Quit:$$$ISERR(tSC)
	} ; Else
	Do pRequestHeader.SetStatus($$$eMessageStatusCompleted)
	
	If ..%MasterPendingResponses.Count()=0 {
		Set tResponse=..%response

		$$$catTRACE("bproc","calling OnComplete")
		Set $EC=""  try {
			Set tSC=..OnComplete(..%request,.tResponse)
		} catch {
			Set tSC=$$$EnsSystemError
		}
		If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after OnComplete(); committing before proceeding")
		$$$catTRACE("bproc","returned from OnComplete")
		Set:$$$ISOK(tSC) tSC=..%responseSet(tResponse)
		Quit:$$$ISERR(tSC)

		#; if OnComplete() adds more async calls, the process is not complete
		If ..%MasterPendingResponses.Count()=0 {
			Set ..%IsCompleted = 1, ..%TimeCompleted = $$$timeUTC
			If ..%RepliedStatus=$$$eRepliedStatusNotCalled Set tSC=..Reply(..%response)
#If ..#INVOCATION="InProc"			
			Try {
				Set tBPConfigName=..%PrimaryRequestHeader.TargetConfigName
				If tBPConfigName="" Set tBPConfigName=..%ConfigName
				If ##class(Ens.Util.Statistics).StatsActive(tBPConfigName) {
					Do ##class(Ens.Util.Statistics).RecordStats($$$eHostTypeProcess,tBPConfigName,"",1,1,$SYSTEM.SQL.DATEDIFF("second",..%TimeCreated,..%TimeCompleted))
				}
			} Catch {}
#EndIf
		}
	}
 } catch {
	Set tSC=$$$EnsSystemError
 }
 Quit tSC
]]></Implementation>
</Method>

<Method name="inprocRequest">
<Description>
This method is for internal use.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pSourceConfigName:%String,pTargetConfigName:%String,pRequest:%Library.Persistent,&pResponse:%Library.Persistent,pReturnQueueName:%String,&pSessionId:%String,pBusinessProcessId:%String,&pRequestHeader:Ens.MessageHeader,pDescription:%String="",pPriority:Ens.DataType.MessagePriority=$$$eMessagePrioritySync]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Set pResponse=$$$NULLOREF
 Set tSC = ##class(Ens.MessageHeader).NewRequestMessage(.pRequestHeader,pRequest,.pSessionId)  Quit:$$$ISERR(tSC) tSC
 Set pRequestHeader.SourceConfigName = pSourceConfigName
 Set pRequestHeader.TargetConfigName = pTargetConfigName
 Set pRequestHeader.SourceBusinessType = $$$ConfigBusinessType($$$DispatchNameToConfigName(pSourceConfigName))
 Set pRequestHeader.TargetBusinessType = $$$ConfigBusinessType($$$DispatchNameToConfigName(pTargetConfigName))
 Set pRequestHeader.TargetQueueName = ""
 Set pRequestHeader.ReturnQueueName = pReturnQueueName
 Set pRequestHeader.BusinessProcessId = pBusinessProcessId
 Set pRequestHeader.Priority = pPriority
 Set pRequestHeader.Invocation = $$$eMessageInvocationInProc
 Set pRequestHeader.Description = pDescription

 Set tSC=pRequestHeader.%Save()  If $$$ISERR(tSC) $$$LOGSTATUS(tSC)  Quit tSC

 Set ($$$EnsJobStatus($$$SystemName,$Job,$$$eJobGuestConfigName),$$$EnsJobLocal("GuestConfigName"))=pTargetConfigName
 Do ##class(Ens.Util.Trace).SetTraceOptimizer()

 Set tSC=$$$OK, tRetryCount=1, (tEndTime,tDoAlert)="", (tAborted,tAlertStartTime,tTerminate)=0, tResponseHeader=$$$NULLOREF
 Set $EC=""  try {
	Set tOldBP=$G($$$EnsJobLocal("%Process"))
	While 1 { ; Retry loop
		Set tSC=..findCachedObject(pTargetConfigName,.tBP)  Quit:$$$ISERR(tSC)
		$$$ASSERT($IsObject(tBP))
		Set tOldBP=$G($$$EnsJobLocal("%Process")), $$$EnsJobLocal("%Process")=tBP 
		$$$catTRACE("bproc","Begin processing "_$S(1=tRetryCount:"",1:"try "_tRetryCount_" of ")_"message "_pRequestHeader.%Id()_"; %MasterPendingResponses contains "_tBP.%MasterPendingResponses.Count()_" element(s)")
		For i=1:1:tBP.%MasterPendingResponses.Count() $$$catTRACE("bproc","%MasterPendingResponses contains completion key: "_$LI(tBP.%MasterPendingResponses.GetAt(i),2))
		Set tTimeCalled=$ZH
		Set:""=tEndTime tEndTime = tTimeCalled + tBP.FailureTimeout
		While 1 { ; InProc loop
			Set tSC=tBP.MessageHeaderHandler(pRequestHeader,.tResponseHeader,.tHandledError)
			If ""=tHandledError && $$$ISERR(tSC) {
				Set $EC=""  try {
					Set tSC=tBP.OnError($$$NULLOREF,$$$NULLOREF,$$$NULLOREF,tSC,"")
				} catch {
					Set tSC=$$$EnsSystemError
				}
				If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after inProc OnError(); committing before proceeding")
				Set tDoAlert=$$$ISERR(tSC)
			}
			Quit:tBP.%IsCompleted||$$$ISERR(tSC)
			For { ; While new InProc response message found and this BP is not completed
				Set tSC=##class(Ens.Queue).DeQueue(tBP.QueueName(),.pRequestHeader,,,0)  Quit:$$$ISERR(tSC)
				Continue:'$IsObject(pRequestHeader)
				Quit:tBP.%Id()=pRequestHeader.BusinessProcessId

				$$$sysTRACE("Out-of-band message '"_pRequestHeader.%Id()_"' discarded")
				Do pRequestHeader.SetStatus($$$eMessageStatusDiscarded)
			} Quit:$$$ISERR(tSC)
		}
		If $IsObject(tOldBP) { Set $$$EnsJobLocal("%Process")=tOldBP } Else { Kill $$$EnsJobLocal("%Process") }
		Continue:'tBP.%IsCompleted&&$$$ISOK(tSC)

		Set tRequest=tBP.%request, tResponse=tBP.%response
		Set $EC=""  try {
			Set tMHSC=tSC
			Set tAction=tBP.OnGetReplyAction(tRequest,.tResponse,.tSC)
			Set:""'=tAction tSC=tBP.doReplyAction(tAction,tRequest,.tResponse,tSC)
			If tSC'=tMHSC&&$$$ISERR(tSC) {
				$$$sysTRACE("calling OnError A")
					Set tSC=tBP.OnError($$$NULLOREF,$$$NULLOREF,$$$NULLOREF,tSC,"")
			}
		} catch {
			Set tSC=$$$EnsSystemError
		}
		If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after ReplyAction OnError(); committing before proceeding")
		Set:""=tDoAlert tDoAlert=$$$ISERR(tSC)
		If tBP.SuspendMessage {
			Set tSC=$$$ERROR($$$EnsErrGeneral,"Can't suspend InProc "_pRequestHeader.%Id()_" in BP for job "_$J_$S($$$ISOK(tSC):"", 1:" - original error: "_$$$StatusDisplayString(tSC)))
			Quit
		}
		Quit:'tBP.Retry

		If $$$ISERR(tSC) {
			Set tTxt=$$cleanNum($P($$$StatusDisplayString(tSC)," -- ")) ; strip off "logged as" varying text and remove digits following a number sign
			Set:'tAlertStartTime&&tBP.AlertOnError&&tBP.AlertRetryGracePeriod&&(tTxt'=tBP.%LastReportedError) tAlertStartTime=$ZH
			If tAlertStartTime {
				If $ZH>=(tAlertStartTime+tBP.AlertRetryGracePeriod) {
					Set tAlertStartTime=0
					If tTxt'=tBP.%LastReportedError { $$$LOGERROR("Alerting at expiration of retry grace period ("_tBP.AlertRetryGracePeriod_") for "_tTxt) }
					Else { $$$LOGINFO("Alerting at expiration of retry grace period ("_tBP.AlertRetryGracePeriod_") for "_tTxt) }
				} Else {
					Set tDoAlert=0
					If tTxt'=tBP.%LastReportedError { $$$LOGERROR("Not Alerting during retry grace period ("_tBP.AlertRetryGracePeriod_") for "_tTxt) }
					Else { $$$LOGINFO("Not Alerting during retry grace period ("_tBP.AlertRetryGracePeriod_") for "_tTxt) }
				}
			} Else {
				If tTxt'=tBP.%LastReportedError { $$$LOGSTATUS(tSC) }
				Else { Set tDoAlert=0 }
			}
			Do:tDoAlert&&tBP.AlertOnError tBP.SendAlert(##class(Ens.AlertRequest).%New($LB(tBP.%ConfigName,$$$StatusDisplayString(tSC))))
			Set tDoAlert=""
		} Else { Set tAlertStartTime=0, tTxt="" }
		Set tBP.%LastReportedError=tTxt

		If tBP.FailureTimeout'=-1 {
			Set tNow=$ZH
			If tNow>tEndTime {
				Set tFailureTimedOut=1, tSC=$$$ERROR($$$EnsErrFailureTimeout, tBP.FailureTimeout, $$$StatusDisplayString(tSC), $$$CurrentClass)
				Set $EC=""  try {
					Set tDoDefault=tBP.OnFailureTimeout(tRequest,.tResponse,.tSC)
					Set:tDoDefault tSC=$S(""=tAction:tSC,1:tBP.finalReplyAction(tAction,tSC,1))
				} catch {
					Set tSC=$$$EnsSystemError
				}
				If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after OnFailureTimeout(); committing before proceeding")
				Set:""=tDoAlert tDoAlert=$$$ISERR(tSC)
				Set:tBP.SuspendMessage tSC=$$$ERROR($$$EnsErrGeneral,"Can't suspend InProc "_pRequestHeader.%Id()_" as requested by signal for job "_$J_$S($$$ISOK(tSC):"", 1:" - original error: "_$$$StatusDisplayString(tSC)))
				Quit
			}
		}
		$$$SetHostMonitor(tConfigName,$$$eMonitorStatus,"Retry")
		Set tWaitTime = tTimeCalled + tBP.RetryInterval - $ZH
		Set tSC1=##class(Ens.Queue).DeQueue("SystemSignal:"_$Job,,$S(tWaitTime<0:0, 1:tWaitTime),,0)  If $$$ISERR(tSC1) Set tSC=$$$ADDSC(tSC,tSC1)  Quit
		Set tTerminate=##class(Ens.Job).ShouldTerminate()
		Set tSBQ=##class(Ens.Job).ShouldBeQuiescent()
		If tSBQ || tTerminate {
			If pRequestHeader.Priority>$$$eMessagePrioritySync||tTerminate {
				Set tTerminate=1
				$$$LOGINFO("Retry loop exited due to shutdown request for message "_tBP.%PrimaryRequestHeader.%Id()_" ; re-queueing"_$S($$$ISOK(tSC):"",1:" - original error: "_$$$StatusDisplayString(tSC)))
				Set tSC1=##class(Ens.Queue).PutBackToQueue(pRequestHeader)
				If $$$ISERR(tSC1) { Set tSC=$$$ADDSC(tSC1,tSC) }
				Else { If 'tFailureTimedOut Set tSC=$$$OK } ; blow away the original error
				Quit
			}
			$$$LOGINFO("Ignoring "_$S(tSBQ:"Quiescent",1:"Terminate")_" request while processing high priority (i.e. synchronous) request "_tBP.%PrimaryRequestHeader.%Id())
		}
		If ##class(Ens.Job).ShouldAbort() {
			$$$LOGWARNING("Message "_tBP.%PrimaryRequestHeader.%Id()_" aborted as requested by signal for job "_$J_$S($$$ISOK(tSC):"",1:" - original error: "_$$$StatusDisplayString(tSC)))
			Set tSC=$$$OK, tAborted=1
			Quit
		}
		If ##class(Ens.Job).ShouldSuspend() {
			Set tSC=$$$ERROR($$$EnsErrGeneral,"Can't suspend inproc "_pRequestHeader.%Id()_" as requested by signal for job "_$J_$S($$$ISOK(tSC):"", 1:" - original error: "_$$$StatusDisplayString(tSC)))
			Set tBP.SuspendMessage=1
			Quit
		}
		Set tRetryCount=tRetryCount+1
		$$$SetJobMonitor(tConfigName,$$$SystemName_":"_$Job,$$$eMonitorRetry,tRetryCount)
		$$$sysTRACE("Retrying Request Header Id "_pRequestHeader.%Id()_" - try #"_tRetryCount)
		Set pRequestHeader=tBP.%PrimaryRequestHeader ; try again from the top
	} ; Retry loop
	While $IsObject(tBP) { ; not really a loop, just a quittable If
		Set:$D(tResponse) tBP.%response=tResponse

		If tBP.%RepliedStatus=$$$eRepliedStatusConstructed {
			Set tResponseHeader=tBP.%PrimaryResponseHeader, tBP.%PrimaryResponseHeader=$$$NULLOREF
			Set tBP.%RepliedStatus=$$$eRepliedStatusSent
		}
SaveExit
		Set tBP.%StatusCode=tSC
		Set $EC=""  try {
			Set:""=tHandledError&&$$$ISERR(tSC) tSC=tBP.OnError($$$NULLOREF,$$$NULLOREF,$$$NULLOREF,tSC,"")
		} catch {
			Set tSC=$$$EnsSystemError
		}
		If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after inProc OnError() 2; committing before proceeding")
		Set:""=tDoAlert tDoAlert=$$$ISERR(tSC)
		If $$$ISERR(tSC) {
			If tBP.%RepliedStatus=$$$eRepliedStatusNotCalled {
				Set tSC2=tBP.%PrimaryRequestHeader.NewErrorResponse(.tResponseHeader,tSC)  Set:$$$ISERR(tSC2) tSC=$$$ADDSC(tSC,tSC2)
				Set tBP.%response=$$$NULLOREF
				Set tBP.%PrimaryResponseHeader=$$$NULLOREF
				Set tBP.%RepliedStatus=$$$eRepliedStatusSent
			} Elseif tBP.%RepliedStatus=$$$eRepliedStatusConstructed {
				Set tResponseHeader=tBP.%PrimaryResponseHeader, tBP.%PrimaryResponseHeader=$$$NULLOREF
				Set tBP.%RepliedStatus=$$$eRepliedStatusSent
			} Else {
				#; nothing to do if tBP.%RepliedStatus=$$$eRepliedStatusSent
			}
			Set tBP.%IsCompleted=1, tBP.%TimeCompleted = $$$timeUTC
			$$$LOGSTATUS($$$ERROR($$$EnsErrBPTerminated,tBP.%ConfigName,tBP.%Id(),$$$StatusDisplayString(tSC)))
		}
		If '$G(tSaveFailed) {
			Set tSC3=tBP.%Save() If $$$ISERR(tSC3) {
				Set tSaveFailed=1, tSC=$$$ADDSC(tSC3,tSC)
				$$$LOGSTATUS(tSC)
				GoTo SaveExit
			}
		} Else {
			#; Try to save BP with only status and state changes
			Set ttId=tBP.%Id()
			Set tRepliedStatus = tBP.%RepliedStatus
			 , tPrimaryResponseHeader = tBP.%PrimaryResponseHeader
			 , tRepliedStatus = tBP.%RepliedStatus
			 , tIsCompleted = tBP.%IsCompleted
			 , tTimeCompleted = tBP.%TimeCompleted

			&sql(UPDATE Ens.BusinessProcess
				 SET %RepliedStatus = :tRepliedStatus
				 , %PrimaryResponseHeader = :tPrimaryResponseHeader
				 , %IsCompleted = :tIsCompleted
				 , %TimeCompleted = :tTimeCompleted
				 WHERE %ID = :ttId)
		}
		$$$catTRACE("bproc","Exit BP "_pRequestHeader.%Id()_"; %MasterPendingResponses contains "_tBP.%MasterPendingResponses.Count()_" element(s)")
		For i=1:1:tBP.%MasterPendingResponses.Count() $$$catTRACE("bproc","%MasterPendingResponses contains completion key: "_$li(tBP.%MasterPendingResponses.GetAt(i),2))

		If $IsObject(tResponseHeader) {
			If tResponseHeader.TargetQueueName'="" {
				Set tSC4 = ##class(Ens.Queue).EnQueue(tResponseHeader)  If $$$ISERR(tSC4) Set tSC=$$$ADDSC(tSC,tSC4)  Quit
			} Else {
				Set tSC4=tResponseHeader.%Save()  If $$$ISERR(tSC4) Set tSC=$$$ADDSC(tSC,tSC4)  Quit
				If tResponseHeader.MessageBodyClassName'="" {
					Set pResponse = $classmethod(tResponseHeader.MessageBodyClassName,"%OpenId",tResponseHeader.MessageBodyId,,.tSC4)
					If '$IsObject(pResponse) Set tSC4=$$$EnsError($$$EnsErrGeneral,"Could not open response MessageBody "_tResponseHeader.MessageBodyId_" for MessageHeader #"_tResponseHeader.%Id()_" with body class "_tResponseHeader.MessageBodyClassName_":"_$$$StatusDisplayString(tSC4)), tSC=$$$ADDSC(tSC,tSC5)  Quit
				}
				Do tResponseHeader.SetStatus($$$eMessageStatusCompleted)
			}
		} Else {
			Set pResponse=$$$NULLOREF
		}
		Quit
	} ; end If/While
 } catch {
	Set tSC=$$$ADDSC(tSC,$$$EnsSystemError)
	If $IsObject(tOldBP) { Set $$$EnsJobLocal("%Process")=tOldBP } Else { Kill $$$EnsJobLocal("%Process") }
 }
 Set $EC=""  try {
	If $$$ISERR(tSC) {
		$$$LOGSTATUS(tSC)
		Do:'tAborted pRequestHeader.SetStatus($$$eMessageStatusError)
	}
	If $$$IsdefObject(tBP) {
		Set tBPConfigName=tBP.%ConfigName
		If $$$ISERR(tSC) {
			$$$SetHostMonitor(tBPConfigName,$$$eMonitorStatus,"Error")
			Do:tDoAlert&&tBP.AlertOnError tBP.SendAlert(##class(Ens.AlertRequest).%New($LB(tBPConfigName,$$$StatusDisplayString(tSC))))
		}
	}
	#; Clear guest config - note this will be useless but harmless if tBP does not exist (i.e. discarded response for completed BP)
	Kill $$$EnsJobStatus($$$SystemName,$Job,$$$eJobGuestConfigName), $$$EnsJobLocal("GuestConfigName"), $$$EnsJobLocal("CurrentXPATHDoc")
	Do ##class(Ens.Util.Trace).SetTraceOptimizer()
 } catch {
	Set tSC=$$$ADDSC(tSC,$$$EnsSystemError)
 }
 Quit tSC

cleanNum(str)
	Set f=0  For { Set f=$F(str,"#",f)  Quit:'f
		For i=f:1 { Quit:$E(str,i)'?1N  Set $E(str,i)="",i=i-1 }
	}
	Quit str
]]></Implementation>
</Method>

<Method name="%requestGet">
<Internal>1</Internal>
<Implementation><![CDATA[
	If ..%PrimaryRequestHeader.MessageBodyClassName'="" {
		Quit $classmethod(..%PrimaryRequestHeader.MessageBodyClassName,"%OpenId",..%PrimaryRequestHeader.MessageBodyId)
	} Else {
		Quit $$$NULLOREF
	}
]]></Implementation>
</Method>

<Method name="%responseGet">
<Internal>1</Internal>
<Implementation><![CDATA[
	If ..%responseClassName="" {
		If ..%responseId'="" {
			Quit ..%responseId
		}
		Quit $$$NULLOREF
	} Else {
		Quit $classmethod(..%responseClassName,"%OpenId",..%responseId)
	}
]]></Implementation>
</Method>

<Method name="%responseSet">
<Internal>1</Internal>
<FormalSpec>pResponse:%Library.Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	If '$IsObject(pResponse) {
		Set ..%responseClassName=""
		Set ..%responseId=pResponse
	} Else {
		Set ..%responseClassName=$classname(pResponse)
		Set:pResponse.%IsA("%Library.Persistent")||pResponse.%IsA("%Stream.Object") tSC=pResponse.%Save()
		Set:$$$ISOK(tSC) tSC=pResponse.%GetSwizzleObject(0,.tOID)
		If $$$ISERR(tSC) Set ..%responseId=""  Quit tSC
		Set ..%responseId=$$$oidPrimary(tOID)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="findCachedObject">
<Description>
Override to ensure that each time the BusinessProcess is invoked inproc, a new business process object is created.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTargetDispatchName:%String,pInstance:Ens.Host</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pInstance=..%New($$$DispatchNameToConfigName(pTargetDispatchName))
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnRequest">
<Description>
Handle a 'Request'</Description>
<FormalSpec>request:%Library.Persistent,*response:%Library.Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Subclass responsibility
	Quit $$$EnsError($$$NotImplemented)
]]></Implementation>
</Method>

<Method name="OnResponse">
<Description>
Handle a 'Response'</Description>
<FormalSpec><![CDATA[request:%Library.Persistent,&response:%Library.Persistent,callrequest:%Library.Persistent,callresponse:%Library.Persistent,pCompletionKey:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Subclass responsibility
	Quit $$$EnsError($$$NotImplemented)
]]></Implementation>
</Method>

<Method name="OnErroredResponse">
<Description>
Handle an errored 'Response'. This is an internal API and should not be overriden by user defined classes</Description>
<Internal>1</Internal>
<FormalSpec><![CDATA[pErroredResponseStatus:%Status,request:%Library.Persistent,&response:%Library.Persistent,pCompletionKey:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnComplete">
<Description>
Called when all the Async responses are received, or timeout has occurred</Description>
<FormalSpec><![CDATA[request:%Library.Persistent,&response:%Library.Persistent]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Subclass responsibility
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnError">
<Description>
This method is called when an error response is received
Returning the same error will cause the BusinessProcess to set its status to error and close down
Returning $$$OK from this method causes the BusinessProcess to recover from this error</Description>
<FormalSpec><![CDATA[request:%Library.Persistent,&response:%Library.Persistent,callrequest:%Library.Persistent,pErrorStatus:%Status,pCompletionKey:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit pErrorStatus
]]></Implementation>
</Method>

<Method name="OnTimeout">
<FormalSpec><![CDATA[request:%Library.Persistent,&response:%Library.Persistent,callrequest:%Library.Persistent,pCompletionKey:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Subclass responsibility
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnGetReplyAction">
<Description>
Construct and return an Action string consisting of supported action code letters, based on criteria in the ReplyCodeActions setting value and qualities of the current Request, Response, and Error Status.</Description>
<FormalSpec><![CDATA[pRequest:%Library.Persistent,&pResponse:%Library.Persistent,&pSC:%Status]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 	Set (tFullAction,tText)="", nActions=$S(""=$ZStrip(..ReplyCodeActions,"<>W"):0, 1:$L(..ReplyCodeActions,","))
	For i=1:1:nActions { Set tType=$P(..ReplyCodeActions,",",i)  Continue:""=tType
		Set tAction="", tCode=$ZStrip($P(tType,"="),"<>W"), tCodeU=$ZCVT(tCode,"U")
		Set tKnown=$Case($E(tCodeU)
						,"E":$Case($E(tCode,2)
								,"#":1
								,"*":1
								,"":1
								,:0)
						,"X":$Case($E(tCode,2),"":1, :0)
						,:0
						)
		If 'tKnown {
			$$$LOGWARNING("Unrecognized reply code:'"_tType_"'")
			Continue
		}
		Set tMatch=$Case($E(tCodeU)
						,"E":$$$ISERR(pSC)
						,"X":'$$$IsdefObject(pResponse)
						,:0)
				 && $Case($E(tCode,2)
						,"#":$$$StatusEquals(pSC,$E(tCode,3,*))
						,"*":$$$StatusDisplayString(pSC)[$E(tCode,3,*)
						,:1)
		If tMatch {
			If $E(tCodeU)="X" {
				Set tMatchText="Empty Response object matched ReplyCodeAction "_i_" : ':"_tType_"'"
			} Else {
				Set tMatchText="Status '"_$$$StatusDisplayString(pSC)_"' matched ReplyCodeAction "_i_" : '"_tType_"'"
			}
			Set tAction=$ZCVT($ZStrip($P(tType,"=",2),"<>W"),"U")
			Set:tAction'?1.(1"R",1"C",1"W",1"S",1"D",1"F") tAction=""
			If ""=tAction {
				$$$LOGWARNING("Unrecognized reply code action:'"_tType_"'")
				Continue
			}
			#; Make sure tFullAction has no more than 1 'W' in it; Quit if it is not just 'W'
			Set:""'=tMatchText tText=tText_$S(""'=tText:" and ",1:"")_tMatchText
			Set:tAction["W" tFullAction=""
			Set tFullAction=tAction_$S(tAction["W":"",1:tFullAction)
#If ..#INVOCATION="InProc"
			If (tFullAction["D") Set tFullAction=$TR(tFullAction,"D") $$$LOGWARNING("InProc "_..%ConfigName_" can not invoke action 'D' (Disable)")
#EndIf
			Quit:tFullAction'?1."W"
		}
	}
	Set:""'=tText ..%ActionHint("CodeReason")=
		"Message body "_pRequest_" / "_pRequest.%Id()_" because "_
		$S('$IsObject(pResponse):"",1:"response "_pResponse_$S(""=pResponse.%Id():"",1:" / "_pResponse.%Id())_" ")_
		tText_" resulting in Action code "_tFullAction
	Quit tFullAction
]]></Implementation>
</Method>

<Method name="doReplyAction">
<Description>
Do the specified action for taking care of the message currently being processed</Description>
<Internal>1</Internal>
<FormalSpec><![CDATA[pAction:%String,pRequest:%Library.Persistent,pResponse:%Library.Persistent,&pSC:%Status]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tText=$G(..%ActionHint("CodeReason"))
	Set:""=tText tText="Message body "_pRequest_" / "_pRequest.%Id()_" because response '"_$G(pResponse)_$S($$$IsdefObject(pResponse)&&(""'=pResponse.%Id()):"' / "_pResponse.%Id(),1:"'")_" and error '"_$$$StatusDisplayString(pSC)_"' resulted in action code '"_pAction_"'"

	Set tActionDesc=$S(pAction["R":"Retrying", pAction["S":"Suspending", pAction["D":"Disabling on", pAction["F":"Quitting with error on", 1:"Accepting as Completed")
	If "Accepting as Completed"=tActionDesc {
		If pAction["W" {
			$$$LOGWARNING("Warning on "_tText)
		} Else {
			$$$sysTRACE("Accepting as Completed "_tText)
		}
		Set ..Retry=0, ..SuspendMessage=0
		Quit $$$OK ; suppress any error
	}
	Set tSC=$$$ERROR($$$EnsErrGeneral,tActionDesc_" "_tText)
	If pAction["R" {
		Set ..Retry=1
	} Else {
		Set tSC=..finalReplyAction(pAction,tSC,0)
		Set pAction="" ; clear because we just did it
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="finalReplyAction">
<Description>
Do the action specified for when all configured retries have been exhausted</Description>
<Internal>1</Internal>
<FormalSpec>pAction:%String,pSC:%Status,pFixError:%Boolean</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If pAction["S" {
		Set ..SuspendMessage=1, tActionDesc="Suspending on"
	} ElseIf pAction["D" {
		Set:($ZS<$$$MAXBBSZ) $ZS=$$$MAXBBSZ
		Set ..SuspendMessage=0, tActionDesc="Disabling on"
		Do ##class(Ens.Job).Stop($Job)
		Do ##Class(Ens.Director).EnableConfigItem(..%ConfigName,0,0)
		Do ..SendRequestAsync("Ens.ScheduleHandler",$$$NULLOREF,0,,"actualize self-disable")
		Set ..%QuitTask=1, ..Retry=1 ; we are quitting but the retry flag will force us to requeue the current message
	} ElseIf pAction["F" {
		// No work required here ; just quit with error
		Set tActionDesc="Discarding message on"
		Set ..SuspendMessage=0
	} Else { ; ??
		$$$LOGWARNING($$$StatusDisplayString(pSC))
		Set pSC=$$$OK, pFixError=0
	}
	Set:pFixError pSC=$$$ERROR($$$EnsErrGeneral,tActionDesc_" "_$$$StatusDisplayString(pSC))
	Quit pSC
]]></Implementation>
</Method>

<Method name="OnFailureTimeout">
<Description><![CDATA[
Override this method to provide custom handling of retry / failure timeout.<p/>
Set ..Retry=1 to override normal error return and re-evaluate flag properties.<p/>
Return 0 to skip further (default) FailureTimeout processing, 1 to perform default processing.]]></Description>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[pRequest:%Library.Persistent,*pResponse:%Library.Persistent,&pSC:%Status]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[1
]]></Implementation>
</Method>

<Method name="Reply">
<Description>
Call this method to send the response to the primary request before the process is finished</Description>
<FormalSpec>response:%Library.Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Set $EC=""  try {
		If ..%RepliedStatus'=$$$eRepliedStatusNotCalled Quit
		Set ..%response=response
		Set tSC=..%PrimaryRequestHeader.NewResponseMessage(.tResponseHeader,..%response) Quit:$$$ISERR(tSC)
		If ..%PrimaryRequestHeader.Invocation=$$$eMessageInvocationInProc {
			Set ..%response=$$$NULLOREF
			Set ..%PrimaryResponseHeader=tResponseHeader
			Set ..%RepliedStatus=$$$eRepliedStatusConstructed
		} Else {
			If tResponseHeader.TargetQueueName'="" Set tSC = ##class(Ens.Queue).EnQueue(tResponseHeader) Quit:$$$ISERR(tSC)
			Set ..%response=$$$NULLOREF
			Set ..%PrimaryResponseHeader=$$$NULLOREF
			Set ..%RepliedStatus=$$$eRepliedStatusSent
		}
		If '..#SKIPMESSAGEHISTORY Do ..%MessagesSent.Insert(tResponseHeader.%Id())
		Do ..%PrimaryRequestHeader.SetStatus($$$eMessageStatusCompleted)
	} catch {
		Set tSC=$$$EnsSystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ReplyError">
<Description>
Call this method to send an error status to the primary request before the process is finished</Description>
<FormalSpec>pStatus:%Status</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Set $EC=""  try {
		If ..%RepliedStatus'=$$$eRepliedStatusNotCalled Quit
		Set tSC=..%PrimaryRequestHeader.NewErrorResponse(.tResponseHeader,pStatus)  Quit:$$$ISERR(tSC)
		If ..%PrimaryRequestHeader.Invocation=$$$eMessageInvocationInProc {
			Set ..%response=$$$NULLOREF
			Set ..%PrimaryResponseHeader=tResponseHeader
			Set ..%RepliedStatus=$$$eRepliedStatusConstructed
		} Else {
			If tResponseHeader.TargetQueueName'="" Set tSC = ##class(Ens.Queue).EnQueue(tResponseHeader) Quit:$$$ISERR(tSC)
			Set ..%response=$$$NULLOREF
			Set ..%PrimaryResponseHeader=$$$NULLOREF
			Set ..%RepliedStatus=$$$eRepliedStatusSent
		}
		Do ..%PrimaryRequestHeader.SetStatus($$$eMessageStatusCompleted)
	} catch {
		Set tSC=$$$EnsSystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="IsResponsePending">
<Description>
Determine if a CompletionKey exists in the %MasterPendingResponses</Description>
<FormalSpec>pCompletionKey:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tIsResponsePending=0
	For tI=1:1:..%MasterPendingResponses.Count() {
		Set tEntry=..%MasterPendingResponses.GetAt(tI)
		If $li(tEntry,2)=pCompletionKey {
			Set tIsResponsePending=1 Quit
		}
	}
	Quit tIsResponsePending
]]></Implementation>
</Method>

<Method name="RemovePendingResponse">
<Description>
remove from %MasterPendingResponses with a CompletionKey</Description>
<FormalSpec>pCompletionKey:%String</FormalSpec>
<Implementation><![CDATA[
	For tI=..%MasterPendingResponses.Count():-1:1 {
		Set tEntry=..%MasterPendingResponses.GetAt(tI)
		If $li(tEntry,2)=pCompletionKey {
			Do ..%MasterPendingResponses.RemoveAt(tI)
			Set tRequestHeader=##class(Ens.MessageHeader).%OpenId($li(tEntry,1))
			If tRequestHeader.MessageBodyClassName'="" {
				Set tMessageBody=$classmethod(tRequestHeader.MessageBodyClassName,"%OpenId",tRequestHeader.MessageBodyId,,.tSC1)
				If '$IsObject(tMessageBody) {
					$$$LOGWARNING("Could not remove pending response MessageBody "_tRequestHeader.MessageBodyId_" for MessageHeader #"_tRequestHeader.%Id()_" with body class "_tRequestHeader.MessageBodyClassName_":"_$$$StatusDisplayString(tSC1))
				} Else {
						Set $EC=""  try {
						Set tSC = tMessageBody.%OnTimeout()
						If $$$ISERR(tSC) $$$LOGSTATUS(tSC)
					} catch ex {
						If ex.Name '= "<METHOD DOES NOT EXIST>" Do $$$EnsSystemError
					}
					If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after body %OnTimeout(); committing before proceeding")
				}
			}
		}
	}
	Quit
]]></Implementation>
</Method>

<Method name="ClearAllPendingResponses">
<Description>
clear %MasterPendingResponses</Description>
<Implementation><![CDATA[
	For tI=..%MasterPendingResponses.Count():-1:1 {
		Set tEntry=..%MasterPendingResponses.GetAt(tI)
		Do ..%MasterPendingResponses.RemoveAt(tI)
		Set tRequestHeader=##class(Ens.MessageHeader).%OpenId($li(tEntry,1))
		If tRequestHeader.MessageBodyClassName'="" {
			Set tMessageBody=$classmethod(tRequestHeader.MessageBodyClassName,"%OpenId",tRequestHeader.MessageBodyId,,.tSC1)
			If '$IsObject(tMessageBody) {
				$$$LOGWARNING("Could not open pending response MessageBody "_tRequestHeader.MessageBodyId_" for MessageHeader #"_tRequestHeader.%Id()_" with body class "_tRequestHeader.MessageBodyClassName_":"_$$$StatusDisplayString(tSC1))
			} Else {
				Set $EC=""  try {
					Set tSC = tMessageBody.%OnTimeout()
					If $$$ISERR(tSC) $$$LOGSTATUS(tSC)
				} catch ex {
					If ex.Name '= "<METHOD DOES NOT EXIST>" Do $$$EnsSystemError
				}
				If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after clear body %OnTimeout(); committing before proceeding")
			}
		}
	}
	Quit
]]></Implementation>
</Method>

<Method name="WillHandleErroredResponse">
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[0
]]></Implementation>
</Method>

<Method name="GetMessageList">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..GetRequestClassList()
]]></Implementation>
</Method>

<Method name="GetRequestClassList">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>OnRequest</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSignature=$$$comMemberKeyGet(%class.Name,$$$cCLASSmethod,"OnRequest",$$$cMETHformalspecparsed)
	Set tClass=$lg($lg(tSignature,1),2)
	Do %code.WriteLine(" Quit $lb("""_tClass_""")")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetResponseClassList">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pRequest:%String=""</FormalSpec>
<GenerateAfter>OnRequest</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSignature=$$$comMemberKeyGet(%class.Name,$$$cCLASSmethod,"OnRequest",$$$cMETHformalspecparsed)
	Set tRequestClass=$lg($lg(tSignature,1),2)
	Set tClass=$lg($lg(tSignature,2),2)
	Do %code.WriteLine(" If pRequest=""""||(pRequest="""_tRequestClass_""") Quit $lb("""_tClass_""")")
	Do %code.WriteLine(" Quit """"")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnAddToSaveSet">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%AddToSaveSet</METHOD> method to 
provide notification that the current object is being included in a SaveSet, either
because %Save() was invoked on this object or an object that references this object.

<P>If this method returns an error status then %Save() will fail and the transaction
will be rolled back.]]></Description>
<Internal>1</Internal>
<FormalSpec>depth:%Integer=3,insert:%Integer=0,callcount:%Integer=0</FormalSpec>
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Discard local copy of primary request & response headers because other jobs may have saved changes to them and we don't want to overwrite them
	Do ..%PrimaryRequestHeaderSetModified(0)
	Do ..%PrimaryResponseHeaderSetModified(0)
	
	#; Ensure a save of the %response body because our storage model doesn't make it happen automatically. We might be doing %Save() to sleep while waiting for a response to a call to get more information to populate the %response object.
	Set tResponse=..%response
	Quit:'$IsObject(tResponse) $$$OK
	Quit tResponse.%AddToSaveSet(depth)
]]></Implementation>
</Method>

<Method name="Purge">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pDeletedCount:%Integer,pDaysToKeep:%Integer=7,pKeepIntegrity:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New %tDoNotDeleteDate,%tClass,%tID Set %tID="", %tDoNotDeleteDate = $$$timeUTCHtoUTC($s($ztimezone'<0:($H-pDaysToKeep+1)_","_($ztimezone*60),1:($H-pDaysToKeep)_","_($ztimezone*60+86400)))
	Set tSC=$$$OK, SQLCODE=0, pDeletedCount=0
	If pKeepIntegrity {
		&sql(DECLARE ISCC1 CURSOR FOR
			Select BP.ID, $Piece(BP.x__ClassName,'~',$Length(BP.x__ClassName,'~')-1) As Class Into :%tID,:%tClass
				From
					Ens.BusinessProcess BP
				Where
					BP.ID<=(Select MAX(BP2.ID) From Ens.BusinessProcess BP2 Where BP2.%TimeCreated < :%tDoNotDeleteDate) 
					AND
					( (BP.%IsCompleted=1)
					OR 
					(BP.%TimeCreated IS NULL) )
			)
		&sql(OPEN ISCC1) For { &sql(FETCH ISCC1)  Quit:SQLCODE
			Set tExists=$G(aClass(%tClass))
			If 0'=tExists {
				try {
					Set tSC1=$classmethod(%tClass,"%DeleteId",%tID)
					Set:""=tExists aClass(%tClass)=1, tExists=1
				} catch ex {
					Set:""=tExists aClass(%tClass)=0  
					if ex.Name = "<CLASS DOES NOT EXIST>" {
						Set tSC1 = $$$ERROR($$$ClassDoesNotExist, %tClass)
					} else {
						Set:'$G(aClass(%tClass,"doneErr")) tSC1=$$$SystemError
					}
				}
				If $$$ISERR(tSC1)&&'$G(aClass(%tClass,"doneErr")) {
					Set tOK=$$$StatusEquals(tSC1,$$$DeleteObjectNotFound,$$$FileCanNotDelete,$$$NotAnInstanceError,$$$ClassDoesNotExist)
					If 'tOK { Set aClass(%tClass,"doneErr")=1, tSC=$$$ADDSC(tSC,tSC1)  $$$LOGWARNING("Failed to purge ID "_%tID_", Class='"_%tClass_"':"_$$$StatusDisplayString(tSC1)) }
				}
				Set pDeletedCount=pDeletedCount+$$$ISOK(tSC1)
			}
		} Set tCode=SQLCODE &sql(CLOSE ISCC1) Set:'SQLCODE SQLCODE=tCode
	} Else {
		&sql(DECLARE ISCC2 CURSOR FOR
			Select ID, $Piece(x__ClassName,'~',$Length(x__ClassName,'~')-1) As Class Into :%tID,:%tClass
				From Ens.BusinessProcess Where %TimeCreated < :%tDoNotDeleteDate)
		&sql(OPEN ISCC2) For { &sql(FETCH ISCC2)  Quit:SQLCODE
			Set tExists=$G(aClass(%tClass))
			If 0'=tExists {
				try {
					Set tSC1=$classmethod(%tClass,"%DeleteId",%tID)
					Set:""=tExists aClass(%tClass)=1, tExists=1
				} catch ex {
					Set:""=tExists aClass(%tClass)=0  
					if ex.Name = "<CLASS DOES NOT EXIST>" {
						Set tSC1 = $$$ERROR($$$ClassDoesNotExist, %tClass)
					} else {
						Set:'$G(aClass(%tClass,"doneErr")) tSC1=$$$SystemError
					}
				}
				If $$$ISERR(tSC1)&&'$G(aClass(%tClass,"doneErr")) {
					Set tOK=$$$StatusEquals(tSC1,$$$DeleteObjectNotFound,$$$FileCanNotDelete,$$$NotAnInstanceError,$$$ClassDoesNotExist)
					If 'tOK { Set aClass(%tClass,"doneErr")=1, tSC=$$$ADDSC(tSC,tSC1)  $$$LOGWARNING("Failed to purge ID "_%tID_", Class='"_%tClass_"':"_$$$StatusDisplayString(tSC1)) }
				}
				Set pDeletedCount=pDeletedCount+$$$ISOK(tSC1)
			}
		} Set tCode=SQLCODE &sql(CLOSE ISCC2) Set:'SQLCODE SQLCODE=tCode
	}
	Set:SQLCODE&&(SQLCODE'=100) tSC=$$$ADDSC(tSC,$$$ERROR($$$EnsErrGeneral,"Purge error at ID "_%tID_"; SQLCODE = "_SQLCODE))
	Quit tSC
]]></Implementation>
</Method>

<Method name="getId">
<Description>
The same as %Id(), but allocates the Id even if the object hasn't been saved already</Description>
<Internal>1</Internal>
<CodeMode>generator</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	$$$GENERATE(" If ..%Id()="""" Do ..%IdSet($increment("_$$$EXTidlocation($$$pEXT,%class)_"))")
	$$$GENERATE(" Quit ..%Id()")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnOpen">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%Open</METHOD> method to 
provide notification that the object specified by <VAR>oid</VAR> is being opened.

<P>If this method returns an error then the object will not be opened.]]></Description>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	For i=1:1:..%MasterPendingResponsesOld.Count() Do ..%MasterPendingResponses.Insert(..%MasterPendingResponsesOld.GetAt(i))
	Do ..%MasterPendingResponsesOld.Clear()
	For i=1:1:..%MessagesSentOld.Count() Do ..%MessagesSent.Insert(..%MessagesSentOld.GetAt(i))
	Do ..%MessagesSentOld.Clear()
	For i=1:1:..%MessagesReceivedOld.Count() Do ..%MessagesReceived.Insert(..%MessagesReceivedOld.GetAt(i))
	Do ..%MessagesReceivedOld.Clear()
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="DeferResponse">
<Description>
This method returns the deferred response token, and marks the current message handling to be deferred
After the message is deferred, the current BS will become complete even without the response to be sent</Description>
<FormalSpec><![CDATA[&pToken:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pToken=..GetDeferredResponseToken(..%PrimaryRequestHeader)
	Set ..%RepliedStatus=$$$eRepliedStatusDeferred
	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Ens.BusinessProcessD</DataLocation>
<DefaultData>BusinessProcessDefaultData</DefaultData>
<IdLocation>^Ens.BusinessProcessD</IdLocation>
<IndexLocation>^Ens.BusinessProcessI</IndexLocation>
<StreamLocation>^Ens.BusinessProcessS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="%MasterPendingResponses">
<Attribute>%MasterPendingResponses</Attribute>
<Structure>subnode</Structure>
<Subscript>"pending"</Subscript>
</Data>
<Data name="%MessagesReceived">
<Attribute>%MessagesReceived</Attribute>
<Structure>subnode</Structure>
<Subscript>"received"</Subscript>
</Data>
<Data name="%MessagesSent">
<Attribute>%MessagesSent</Attribute>
<Structure>subnode</Structure>
<Subscript>"sent"</Subscript>
</Data>
<Data name="BusinessProcessDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>%ConfigQueueName</Value>
</Value>
<Value name="3">
<Value>%IsCompleted</Value>
</Value>
<Value name="4">
<Value>%MasterPendingResponsesOld</Value>
</Value>
<Value name="6">
<Value>%PrimaryRequestHeader</Value>
</Value>
<Value name="7">
<Value>%PrimaryResponseHeader</Value>
</Value>
<Value name="8">
<Value>%RepliedStatus</Value>
</Value>
<Value name="9">
<Value>%responseId</Value>
</Value>
<Value name="10">
<Value>Adapter</Value>
</Value>
<Value name="11">
<Value>%SessionId</Value>
</Value>
<Value name="12">
<Value>%TimeCompleted</Value>
</Value>
<Value name="13">
<Value>%TimeCreated</Value>
</Value>
<Value name="14">
<Value>%ConfigName</Value>
</Value>
<Value name="15">
<Value>%QuitTask</Value>
</Value>
<Value name="16">
<Value>AlertOnError</Value>
</Value>
<Value name="17">
<Value>%responseClassName</Value>
</Value>
<Value name="18">
<Value>%IsTimerInterrupted</Value>
</Value>
<Value name="19">
<Value>%IsTerminated</Value>
</Value>
<Value name="20">
<Value>%StatusCode</Value>
</Value>
<Value name="21">
<Value>%MessagesReceivedOld</Value>
</Value>
<Value name="22">
<Value>%MessagesSentOld</Value>
</Value>
<Value name="23">
<Value>ReplyCodeActions</Value>
</Value>
<Value name="24">
<Value>RetryInterval</Value>
</Value>
<Value name="25">
<Value>AlertRetryGracePeriod</Value>
</Value>
<Value name="26">
<Value>FailureTimeout</Value>
</Value>
<Value name="27">
<Value>Retry</Value>
</Value>
<Value name="28">
<Value>SuspendMessage</Value>
</Value>
<Value name="29">
<Value>QueueCountAlert</Value>
</Value>
<Value name="30">
<Value>QueueWaitAlert</Value>
</Value>
<Value name="31">
<Value>InactivityTimeout</Value>
</Value>
<Value name="32">
<Value>BusinessPartner</Value>
</Value>
<Value name="33">
<Value>AlertGroups</Value>
</Value>
<Value name="34">
<Value>%SuperSession</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Ens.BusinessProcessBPL">
<ClassType>persistent</ClassType>
<IncludeCode>Ensemble</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessProcess</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59268,43369.482</TimeCreated>

<Property name="%Thread">
<Description>
This property holds the instance of the initial thread of this process</Description>
<Type>Ens.BP.Thread</Type>
</Property>

<Property name="%Context">
<Description>
This property holds the context object</Description>
<Type>Ens.BP.Context</Type>
</Property>

<Property name="%Counter">
<Description>
This property holds the counter for delays and timeouts</Description>
<Type>%Integer</Type>
</Property>

<Property name="%SynchronizedResponses">
<Description>
This property holds the collection of synchronised responses</Description>
<Type>%String</Type>
<Collection>array</Collection>
<SqlFieldName>_SynchronizedResponses</SqlFieldName>
</Property>

<Projection name="Janitor">
<Description>
BPL Janitor will remove related classes</Description>
<Type>Ens.BPLJanitor</Type>
</Projection>

<Property name="RuleLogging">
<Description><![CDATA[
This set of flags controls the logging performed by the rule engine whenever a Rule activity is executed.
The following flags are available:
<ul><li>'e' - log errors only. All errors will be logged irrespective of other flags, so 
setting the value to 'e' or leaving the value empty will only log errors.</li>
<li>'r' - log return values. This is the default value for the setting, and is 
also automatic whenever the 'd' or 'c' flags are specified.</li>
<li>'d' - log user-defined debug actions in the rule. This will also include 'r'.</li>
<li>'c' - log details of the conditions that are evaluated in the rule. This will also include 'r'.</li>
<li>'a' - log all available information. This is equivalent to 'rcd'.</li></ul>]]></Description>
<Type>%String</Type>
<InitialExpression>$$$eRuleLogTypeReturn</InitialExpression>
</Property>

<Parameter name="SETTINGS">
<Default>RuleLogging:Dev</Default>
</Parameter>

<Method name="RuleLoggingSet">
<Description><![CDATA[
Ensure that the value of <property>RuleLogging</property> is normalized at the time that it is set.]]></Description>
<FormalSpec>pRuleLogging:%String=$$$eRuleLogTypeReturn</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%RuleLogging = ##class(Ens.Rule.Definition).NormalizeRuleLogTypes(pRuleLogging)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnCompile">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<Implementation><![CDATA[
    Set tSC=$$$OK
    do {
        #; Don't run this method on the base class
        If %compiledclass.Name="Ens.BusinessProcessBPL" Quit
        
        #; find XDATA block named BPLERROR
        If ##class(%Dictionary.CompiledXData).%ExistsId(%class.Name_"||BPLERROR") {
            Set tSC=$$$ERROR($$$EnsErrInvalidBPL)
            Quit
        }
        
        #; find XDATA block named BPL
        If ##class(%Dictionary.CompiledXData).%ExistsId(%class.Name_"||BPL") {
            Set tIndex = %compiledclass.XDatas.FindObjectId(%class.Name_"||BPL")
        
            #; get XDATA as stream
            Set tStream = %compiledclass.XDatas.GetAt(tIndex).Data
            Do tStream.Rewind()
    
            Set tSC=##class(Ens.BPL.Compiler).CompileStream(tStream,%class.Name)
        } else {
            
            #; Must have an XDATA BPL Block
            Set tSC=$$$ERROR($$$EnsErrMissingBPL)
        }
    } while (0)
    Quit tSC
]]></Implementation>
</Method>

<Method name="OnRequest">
<Description>
Handle a 'Request'</Description>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>request:%Library.Persistent,*response:%Library.Persistent</FormalSpec>
<GenerateAfter>OnCompile</GenerateAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #; Don't run this method on the base class
    If %compiledclass.Name="Ens.BusinessProcessBPL" Quit $$$OK
    
    #; If compile failed for any reason, don't attempt to generate this method
    If '$Data(^CacheTempCls(%ISCName,"Ensemble","BPLCompiler",%class.Name)) Quit $$$OK
    
    Do %code.WriteLine(" Set $ZT=""Trap"",tSC=$$$OK do {")
    Do %code.WriteLine(" #; Create the initial thread")
    Do %code.WriteLine(" Set ..%Thread=$zobjclassmethod("""_^CacheTempCls(%ISCName,"Ensemble","BPLCompiler",%class.Name,"ThreadClass")_""",""%New"",$this)")
    Do %code.WriteLine(" $$$ASSERT($IsObject(..%Thread))")
    Do %code.WriteLine(" #; Create the final response body")
    
    #; Response is optional
    Set tResponse=$Get(^CacheTempCls(%ISCName,"Ensemble","BPLCompiler",%class.Name,"ResponseClass"))
    If tResponse'="" {
        Do %code.WriteLine(" Set response=$zobjclassmethod("""_^CacheTempCls(%ISCName,"Ensemble","BPLCompiler",%class.Name,"ResponseClass")_""",""%New"")")
        Do %code.WriteLine(" $$$ASSERT($IsObject(response))")
    } else {
        Do %code.WriteLine(" Set response=$$$NULLOREF")
    }
    Do %code.WriteLine(" #; Create the context class")
    Do %code.WriteLine(" Set ..%Context=$zobjclassmethod("""_^CacheTempCls(%ISCName,"Ensemble","BPLCompiler",%class.Name,"ContextClass")_""",""%New"",$this)")
    Do %code.WriteLine(" $$$ASSERT($IsObject(..%Context))")
    Do %code.WriteLine(" #; Schedule the top level thread")
    Do %code.WriteLine(" Set tSC=..%Thread.SwitchState(.tStatus,request,.response,"""",0)")
    Do %code.WriteLine(" Kill %BPLVARS")
    Do %code.WriteLine(" If $$$ISERR(tSC) Quit")
    Do %code.WriteLine(" #; Status MUST be 'completed','waiting' or 'errored'")
    Do %code.WriteLine(" $$$ASSERT(tStatus=$$$eRunStatusCompleted||(tStatus=$$$eRunStatusWaiting)||(tStatus=$$$eRunStatusErrored))")
    Do %code.WriteLine(" If tStatus'=$$$eRunStatusWaiting&&(..%Context.%Id()'="""") Kill ^Ens.BPL.Milestone(..%SessionId,..%Context.%Id())") 
    Do %code.WriteLine(" } while (0)")
    Do %code.WriteLine("Exit Quit tSC")
    Do %code.WriteLine("Trap Set $ZT="""",tSC=$$$EnsSystemError Goto Exit")
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnResponse">
<Description>
Handle a 'Response'</Description>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[request:%Library.Persistent,&response:%Library.Persistent,callrequest:%Library.Persistent,callresponse:%Library.Persistent,pCompletionKey:%String]]></FormalSpec>
<GenerateAfter>OnCompile</GenerateAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #; Don't run this method on the base class
    If %compiledclass.Name="Ens.BusinessProcessBPL" Quit $$$OK
    
    #; If compile failed for any reason, don't attempt to generate this method
    If '$Data(^CacheTempCls(%ISCName,"Ensemble","BPLCompiler",%class.Name)) Quit $$$OK
    
    Do %code.WriteLine(" Set $ZT=""Trap"",tSC=$$$OK do {")
    Do %code.WriteLine("   If pCompletionKey'="""" {")
    Do %code.WriteLine("     #; Apply Response handler if specified")
    Do %code.WriteLine("     Set tResponseHandler=..%Context.%ResponseHandlers.GetAt(pCompletionKey)")
    Do %code.WriteLine("     If tResponseHandler'="""" {")
    Do %code.WriteLine("       Set tSC=$zobjmethod(..%Context,tResponseHandler,$this,..%Context,request,.response,callrequest,callresponse,pCompletionKey)")
    Do %code.WriteLine("       If $$$ISERR(tSC) Quit")
    Do %code.WriteLine("    }")
    Do %code.WriteLine("  }") 
    Do %code.WriteLine("  #; Schedule the top level thread")
    Do %code.WriteLine("  Set tSC=..%Thread.SwitchState(.tStatus,request,.response,pCompletionKey,0)")
    Do %code.WriteLine("  Kill %BPLVARS")
    Do %code.WriteLine("  If $$$ISERR(tSC) Quit")
    Do %code.WriteLine("  #; Status MUST be 'completed' or 'waiting'")
    Do %code.WriteLine("  $$$ASSERT(tStatus=$$$eRunStatusCompleted||(tStatus=$$$eRunStatusWaiting))")   
    Do %code.WriteLine("  Set tSC=..UpdateSynchronizedResponses()")
    Do %code.WriteLine("  If $$$ISERR(tSC) Quit")
    Do %code.WriteLine(" } while (0)")
    Do %code.WriteLine("Exit Quit tSC")
    Do %code.WriteLine("Trap Set $ZT="""",tSC=$$$EnsSystemError Goto Exit")
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnErroredResponse">
<Description>
We override this method to determine if there is an active error handler and if so to dispatch to it</Description>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[pErroredResponseStatus:%Status,request:%Library.Persistent,&response:%Library.Persistent,pCompletionKey:%String]]></FormalSpec>
<GenerateAfter>OnCompile</GenerateAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #; Don't run this method on the base class
    If %compiledclass.Name="Ens.BusinessProcessBPL" Quit $$$OK
    
    #; If compile failed for any reason, don't attempt to generate this method
    If '$Data(^CacheTempCls(%ISCName,"Ensemble","BPLCompiler",%class.Name)) Quit $$$OK
    
    Do %code.WriteLine(" Set $ZT=""Trap"",tSC=$$$OK do {")
    Do %code.WriteLine(" #; Determine if the thread has an active handler")
    Do %code.WriteLine(" Set tSC=..%Thread.AnyHandlerActive(.tActive)")
    Do %code.WriteLine(" If $$$ISERR(tSC)")
    Do %code.WriteLine(" #; If there isn't a handler active then return the original response status")
    Do %code.WriteLine(" If tActive = 0 Set tSC=pErroredResponseStatus Quit")
    Do %code.WriteLine(" #; Record LastError")
    Do %code.WriteLine(" Set ..%Context.%LastError=pErroredResponseStatus")
    Do %code.WriteLine(" Set tSC=..%Thread.SwitchState(.tStatus,request,.response,pCompletionKey,1)")
    Do %code.WriteLine(" Kill %BPLVARS")
    Do %code.WriteLine(" If $$$ISERR(tSC) Quit")
    Do %code.WriteLine(" #; Status MUST be 'completed' or 'waiting'")
    Do %code.WriteLine(" $$$ASSERT(tStatus=$$$eRunStatusCompleted||(tStatus=$$$eRunStatusWaiting))")    
    Do %code.WriteLine(" Set tSC=..UpdateSynchronizedResponses()")
    Do %code.WriteLine(" If $$$ISERR(tSC) Quit")
    Do %code.WriteLine(" } while (0)")
    Do %code.WriteLine("Exit Quit tSC")
    Do %code.WriteLine("Trap Set $ZT="""",tSC=$$$EnsSystemError Goto Exit")
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="UpdateSynchronizedResponses">
<Description>
Update the synchronized responses</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    $$$sysTRACE("Start UpdateSynchronizedResponses")
    
    /// Recurse through the threads and ask each to remove from this processes
    /// %SynchronizedResponses array which are still outstanding
    Set tSC=..%Thread.UpdateSynchronizedResponses()
    If $$$ISERR(tSC) Quit tSC
    
    /// The array now contains those responses which have been
    /// synchronized by ALL threads. walk through the array and remove
    /// each response from the processes PendingResponse collection
    Set tResponse=..%SynchronizedResponses.Next("")
    While (tResponse'="") {
        Do ..RemovePendingResponse(tResponse)
        Set tResponse=..%SynchronizedResponses.Next(tResponse)
    }
    
    Do ..%SynchronizedResponses.Clear()
    
    $$$sysTRACE("Finish UpdateSynchronizedResponses")
    
    Quit tSC
]]></Implementation>
</Method>

<Method name="IsComponent">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>OnRequest</GenerateAfter>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    Set tIsComponent=$get(^CacheTempCls(%ISCName,"Ensemble","BPLCompiler",%class.Name,"IsComponent"),0)
    Do %code.WriteLine(" Quit "_tIsComponent)
]]></Implementation>
</Method>

<Method name="GetMessageList">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    Quit ..GetRequestClassList()
]]></Implementation>
</Method>

<Method name="GetRequestClassList">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>OnRequest</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set tClass=$get(^CacheTempCls(%ISCName,"Ensemble","BPLCompiler",%class.Name,"RequestClass"),"%Library.Persistent")
    Do %code.WriteLine(" Quit $lb("""_tClass_""")")
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetResponseClassList">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pRequest:%String=""</FormalSpec>
<GenerateAfter>OnRequest</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set tRequestClass=$get(^CacheTempCls(%ISCName,"Ensemble","BPLCompiler",%class.Name,"RequestClass"),"%Library.Persistent")
    Set tResponseClass=$get(^CacheTempCls(%ISCName,"Ensemble","BPLCompiler",%class.Name,"ResponseClass"),"%Library.Persistent")
    Do %code.WriteLine(" If pRequest=""""||(pRequest="""_tRequestClass_""") Quit $lb("""_tResponseClass_""")")
    Do %code.WriteLine(" Quit """"")
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="MakeTimerCall">
<FormalSpec>pPrefix:%String,*pName:%String,pTimeout:%String,pCompletionKeyList:%String,*pAlarmHandle:%String,pDescription:%String="",pIsTimer:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #; Create the call's name from a combination of prefix and runtime counter
    Set ..%Counter=..%Counter+1
    Set pName=pPrefix_..%Counter
    
    #; Set the timer
    Quit ..SetTimer(pTimeout,pName,$ListFromString(pCompletionKeyList),.pAlarmHandle,pDescription,pIsTimer)
]]></Implementation>
</Method>

<Method name="MakeAlarmCall">
<Description>
Deprecated</Description>
<FormalSpec>pThread:Ens.BP.Thread,pPrefix:%String,*pName:%String,pDuration:%String,pUntil:%String="",pIsTimer:%Boolean=0,pDescription:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set $ZT="Trap",tSC=$$$OK
    do {
        #; Form the alarm request
        Set tRequest=##class(Ens.AlarmRequest).%New()
        If '$IsObject(tRequest) Set tSC=%objlasterror Quit
        #; Set the duration or instant to wait until
        If pDuration'="" {
            Set tRequest.Duration=pDuration
        } elseif pUntil'="" {
            Set tRequest.Until=pUntil
        } else {
            $$$ASSERT("0:Duration or Instant MUST be specified")
        }
        #; Create the call's name from a combination of prefix and runtime counter
        Set ..%Counter=..%Counter+1
        Set pName=pPrefix_..%Counter
        
        #; Make the request
        Set tSC=pThread.MakeAsyncCall("","Ens.Alarm",tRequest,pName,1,pIsTimer,pDescription)
    } while (0)
Exit
    Quit tSC
Trap
    Set $ZT="",tSC=$$$EnsSystemError
    Goto Exit
]]></Implementation>
</Method>

<Method name="Purge">
<Description>
Deprecated - use Ens.BusinessProcess.Purge()</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>*pDeletedCount:%Integer,pDaysToKeep:%Integer,pKeepIntegrity:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##super(.pDeletedCount,.pDaysToKeeep,.pKeepIntegrity)
]]></Implementation>
</Method>

<Method name="%OnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set tId=$$$oidPrimary(oid)
    &sql(SELECT %Context INTO :tContext FROM Ens.BusinessProcessBPL WHERE %ID = :tId)
    If 'SQLCODE {
        &sql(DELETE from Ens_BP.Context where %ID = :tContext)
        &sql(DELETE from Ens_BP.Thread where %Process = :tId)
    }
    Quit $$$OK
]]></Implementation>
</Method>

<Trigger name="OnDelete">
<Code><![CDATA[    &sql(DELETE from Ens_BP.Context where %ID = :{%Context} )
    &sql(DELETE from Ens_BP.Thread where %Process = :{ID})]]></Code>
<Event>DELETE</Event>
</Trigger>

<Method name="WillHandleErroredResponse">
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[1
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>BusinessProcessBPLDefaultData</DefaultData>
<Data name="%SynchronizedResponses">
<Attribute>%SynchronizedResponses</Attribute>
<Structure>subnode</Structure>
<Subscript>"%SynchronizedResponses"</Subscript>
</Data>
<Data name="BusinessProcessBPLDefaultData">
<Subscript>"BusinessProcessBPL"</Subscript>
<Value name="1">
<Value>%Context</Value>
</Value>
<Value name="2">
<Value>%Thread</Value>
</Value>
<Value name="3">
<Value>%Counter</Value>
</Value>
<Value name="4">
<Value>RuleLogging</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Ens.BusinessService">
<Abstract>1</Abstract>
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Host,Ens.Util.IOLogger</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59266,33365.108</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="%WaitForNextCallInterval">
<Description>
Used to be named %ProcessInputCalled, with inverse sense</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="%ProcessInputCalled">
<Description>
Deprecated - use %WaitForNextCallInterval</Description>
<Type>%Boolean</Type>
<Calculated>1</Calculated>
</Property>

<Property name="%PreserveSession">
<Description>
Put all inputs from this service into a single session</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="%RequestHeader">
<Type>Ens.MessageHeader</Type>
</Property>

<Property name="%AlertStartTime">
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="%ProcessError">
<Description>
Store error from Service's ProcessInput() method - needed in SOAP adapter</Description>
<Type>%Status</Type>
<Internal>1</Internal>
</Property>

<Property name="AlertGracePeriod">
<Description>
When AlertOnError is True, refrain from alerting if it is not from ProcessInput() and the Service succeeds again within this number of seconds</Description>
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="%OutsideCreated">
<Description>
IO device name if created by CreateBusinessService from a CSP TCP job</Description>
<Type>%String</Type>
</Property>

<Parameter name="SETTINGS">
<Default>AlertGracePeriod:Alerting</Default>
</Parameter>

<Parameter name="APPDATAKEY">
<Type>%String</Type>
<Default>ProcessInputAsync</Default>
</Parameter>

<Method name="ProcessInput">
<Description>
This is the entry point for incoming data, called by InboundAdapters and external applications. Do not override.
Do not call SendRequestSync/Async() from outside this method (e.g. in a SOAP Service or a CSP page).</Description>
<Internal>1</Internal>
<FormalSpec><![CDATA[pInput:%RegisteredObject,*pOutput:%RegisteredObject,&pHint:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",$EC="",tSC=$$$OK
	Kill pOutput  Set pOutput = $$$NULLOREF
	Do {
		#; re-register if production bounced between ProcessInput() calls from outside job instantiated service
		If (..Adapter=""||$G($$$EnsJobLocal("TCPIn.OutsideJob")))&&'$D($$$EnsJobStatus($$$SystemName,$J)) Set tSC = ##class(Ens.Job).Register(..%ConfigName,-1,0,$Job,"Xternal",$$$eJobStatusVisiting)  Quit:$$$ISERR(tSC)
		Do ##class(Ens.Util.Statistics).InitStats(..%ConfigName)
		Set tSOAP=($this.%Extends("EnsLib.SOAP.Service") && $this.SOAPInvoked)
		Set ..%WaitForNextCallInterval=0
		Set:'tSOAP tSC=..preProcessInput()  Quit:$$$ISERR(tSC)
		Set tCreated='$IsObject(..IOLogEntry)
		$$$NEWINIOLOGENTRY($$$OK,"ProcessInput",pInput)
		Set $EC=""  try {
			Set tSC = ..OnProcessInput(.pInput,.pOutput,.pHint)
		} catch {
			Set tSC=$$$EnsSystemError
		}
		If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after OnProcessInput(); committing before proceeding")
		If $$$ISERR(tSC) {
			$$$sysTRACE("OnProcessInput() returned "_$$$StatusDisplayString(tSC)_", %QuitTask="_..%QuitTask_", %WaitForNextCallInterval="_..%WaitForNextCallInterval)
			Do:..Adapter=""||$G($$$EnsJobLocal("TCPIn.OutsideJob")) ..onOutsideErr(.tSC)
		} Else {
			Kill %objlasterror
			If ""'=$G(pOutput)||..%QuitTask||'..%WaitForNextCallInterval {
				$$$sysTRACE("returned OK from OnProcessInput(); Output="_$G(pOutput)_", %WaitForNextCallInterval="_..%WaitForNextCallInterval_", %QuitTask="_..%QuitTask)
			} Else {
				$$$catTRACE("ontask","Returned OK from OnProcessInput(); Output="_$G(pOutput)_", %WaitForNextCallInterval="_..%WaitForNextCallInterval_", %QuitTask="_..%QuitTask)
			}
		}
		If tCreated { $$$CLOSEIOLOGENTRY(tSC,"After ProcessInput",pOutput) }
		Else { $$$SAVEIOLOGENTRY(tSC,"After ProcessInput",pOutput) }
	} While 0
Exit
	Do ##class(Ens.Util.Statistics).RecordStats($$$eHostTypeService,..%ConfigName)
	Kill $$$JobSessionId
	Set ..%ProcessError=tSC  Kill %objlasterror
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="preProcessInput">
<Internal>1</Internal>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If (..Adapter=""||$G($$$EnsJobLocal("TCPIn.OutsideJob"))) && ##class(Ens.Job).ShouldBeQuiescent() {
		Quit $$$EnsError($$$EnsErrProductionQuiescent)
	}
	Set tConfigName=$$$DispatchNameToConfigName(..%ConfigName)
	If '$$$ConfigIsEnabled(tConfigName) {
		Quit $$$EnsError($$$EnsErrConfigDisabled,..%ConfigName)
	}
	If '..%PreserveSession Set ..%SessionId=""  Kill $$$JobSessionId
	Set ..%ProcessError=""  Kill %objlasterror

	// update monitor & counter
	$$$IncHostCounterTime(tConfigName)
	$$$IncJobCounterTime(tConfigName,$$$SystemName_":"_$Job)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="onOutsideErr">
<Description>
Do AlertOnError here if we are being called from an outside job and not in the OnTask loop of an Ensemble job</Description>
<Internal>1</Internal>
<FormalSpec><![CDATA[&pSC:%Status]]></FormalSpec>
<Implementation><![CDATA[
#define BSRuntime(%s)	$$$EnsRuntimeAppData("BSOutsideErrors",..%ConfigName,%s)

	Set tDoAlert=..OnError(.pSC)
	Set tTxt=""
	If $$$ISERR(pSC) {
		Set tTxt=$P($$$StatusDisplayString(pSC)," -- ") // OnError might have changed it; strip off "logged as" varying text
		Set tLastReportedError=$G($$$BSRuntime("LastReportedError"))
		If tTxt'=tLastReportedError {
			$$$SetHostMonitor(..%ConfigName,$$$eMonitorStatus,"Error")
			$$$LOGSTATUS(pSC)
		} Else { Set tDoAlert=0 }
		Do:tDoAlert&&..AlertOnError ..SendAlert(##class(Ens.AlertRequest).%New($LB(..%ConfigName,$$$StatusDisplayString(pSC))))
	}
	Set $$$BSRuntime("LastReportedError")=tTxt
]]></Implementation>
</Method>

<Method name="OnProcessInput">
<Description>
Override this method to process incoming data. Do not call SendRequestSync/Async() from outside this method (e.g. in a SOAP Service or a CSP page).</Description>
<FormalSpec><![CDATA[pInput:%RegisteredObject,*pOutput:%RegisteredObject,&pHint:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$NotImplemented)
]]></Implementation>
</Method>

<Method name="SendRequestSync">
<Description>
Use this method to dispatch an Ensemble business invocation synchronously</Description>
<FormalSpec><![CDATA[pTargetDispatchName:%String,pRequest:%Library.Persistent,&pResponse:%Library.Persistent,pTimeout:%Numeric=-1,pDescription:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$sysTRACE("call to "_pTargetDispatchName)
	Set tTimeCalled=$ZH
	Set tTargetConfigName = $G($$$DispatchNameToConfigName(pTargetDispatchName))  Quit:""=tTargetConfigName $$$EnsError($$$EnsErrBusinessDispatchNameNotRegistered,pTargetDispatchName)
	Set tTargetBusinessClass = $$$ConfigClassName(tTargetConfigName)
	Set tSessionId = ..%SessionId
	Set tSuperSession = ..%SuperSession
	Set:$IsObject(..%RequestHeader)&&(""=..%RequestHeader.TimeCreated) tRequestHeader=..%RequestHeader
	$$$SyncCommitSet(tSyncCommit)
	Set tSC=$classmethod(tTargetBusinessClass,"acceptRequestSync",..%ConfigName,tTargetConfigName,.pRequest,.pResponse,.tSessionId,pTimeout,.tRequestHeader,pDescription,.tSuperSession)
	$$$SyncCommitClear(tSyncCommit)
	If $G(tSessionId)'="" Set (..%SessionId,$$$JobSessionId)=tSessionId
	If $G(tSuperSession)'="" Set (..%SuperSession,$$$JobSuperSession)=tSuperSession
	If $$$ISOK(tSC),$$$IsdefObject(tRequestHeader) {
		Set ..%RequestHeader=tRequestHeader, $$$JobCurrentHeaderId=tRequestHeader.%Id()
	}
	$$$catTRACE("timing","duration of sync call: "_($ZH-tTimeCalled))
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendRequestAsync">
<Description>
Use this method to dispatch an Ensemble business invocation asynchronously</Description>
<FormalSpec>pTargetDispatchName:%String,pRequest:%Library.Persistent,pDescription:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$sysTRACE("call to "_pTargetDispatchName)
	Set tTimeCalled=$ZH
	Set tTargetConfigName = $G($$$DispatchNameToConfigName(pTargetDispatchName))  Quit:""=tTargetConfigName $$$EnsError($$$EnsErrBusinessDispatchNameNotRegistered,pTargetDispatchName)
	Set tTargetBusinessClass = $$$ConfigClassName(tTargetConfigName)
	Set tSessionId = ..%SessionId
	Set tSuperSession = ..%SuperSession
	Set:$IsObject(..%RequestHeader)&&(""=..%RequestHeader.TimeCreated) tRequestHeader=..%RequestHeader
	$$$SyncCommitSet(tSyncCommit)
	Set tSC=$classmethod(tTargetBusinessClass,"acceptRequestAsync",..%ConfigName,tTargetConfigName,.pRequest,$$$eMessagePriorityAsync,"",.tSessionId,"",.tRequestHeader,pDescription,.tSuperSession)
	$$$SyncCommitClear(tSyncCommit)
	If $G(tSessionId)'="" Set (..%SessionId,$$$JobSessionId)=tSessionId
	If $G(tSuperSession)'="" Set (..%SuperSession,$$$JobSuperSession)=tSuperSession
	If $$$ISOK(tSC) {
		Set ..%RequestHeader=tRequestHeader, $$$JobCurrentHeaderId=tRequestHeader.%Id()
	}
	$$$catTRACE("timing","duration of async call: "_($ZH-tTimeCalled))
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnError">
<Description>
Override this method to provide custom error handling. Return 0 means skip standard AlertOnError behavior.</Description>
<FormalSpec>pStatus:%Status</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit 1
]]></Implementation>
</Method>

<Method name="SendAlert">
<Description>
Use this method to send an alert message</Description>
<FormalSpec>pAlertRequest:Ens.AlertRequest</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	
	If (""=$G($$$DispatchNameToConfigName("Ens.Alert"))) {
		$$$LOGALERT(pAlertRequest.AlertText)
	} Else {
		Do pAlertRequest.%Save()
		$$$LOGALERT(pAlertRequest.AlertText_" (alert request ID="_pAlertRequest.%Id()_")")
		Set tSC = ..SendRequestAsync("Ens.Alert",pAlertRequest)
	}
		
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnTask">
<Description>
This is called only for BusinessService classes that are in polling mode; BusinessService
 classes invoked externally via CSP, SOAP, or a language binding do not use OnTask().</Description>
<Internal>1</Internal>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",$EC="",tSC=$$$OK
	Do {
		If '..%WarnedLatest&&'..%ClassIsLatestVersion() {
			$$$LOGWARNING("Service Class "_$classname()_" has been recompiled; continuing to run using code from previous version")
			Set ..%WarnedLatest=1
		}
		If $IsObject(..Adapter)&&'..Adapter.%WarnedLatest&&'..Adapter.%ClassIsLatestVersion() {
			$$$LOGWARNING("Adapter Class "_$classname(..Adapter)_" has been recompiled; continuing to run using code from previous version")
			Set ..Adapter.%WarnedLatest=1
		}
		$$$ASSERT($IsObject(..Adapter)) ; Must have an Adapter to call OnTask()
		Set tTimeCalled = $ZH
		Set ..%WaitForNextCallInterval=1
		Set tSBQ=##class(Ens.Job).ShouldBeQuiescent()
		If ..ThrottleDelay>0&&'tSBQ {
			Set tRemaining=..ThrottleDelay/1000, t0=$ZH
			$$$catTRACE("ontask","hanging for "_(..ThrottleDelay/1000)_" ThrottleDelay seconds")
			While tRemaining>0&&'tSBQ {
				If tRemaining<5 { Hang tRemaining  Set tRemaining=0 } 
				Else { Hang 5  Set tNow=$ZH, tRemaining = t0+tRemaining-tNow, t0=tNow}
				Set tSBQ=##class(Ens.Job).ShouldBeQuiescent()
			}
		}
		If tSBQ {
			$$$sysTRACE("Adapter's OnTask() not called because system is quiescent")
			Set tSC = ##class(Ens.Queue).DeQueue("SystemSignal:"_$Job,,-1,,1)
		} Else {
			$$$catTRACE("ontask","calling adapter's OnTask()")
			Set tSC=..Adapter.OnTask()
			Set:('..%WaitForNextCallInterval)||('..%LastActionTime) tNow=$ZH, ..%LastActionTime=tNow, ..%LastHandledTime=tNow
			Set tTxt=$S($$$ISERR(tSC):$P($$$StatusDisplayString(tSC)," -- "), 1:"") ; strip off "logged as" varying text
			If (tTxt'=""&&(tTxt'=..%LastReportedError))||'..%WaitForNextCallInterval||..%QuitTask {
				$$$sysTRACE("returned from adapter's OnTask() : "_tTxt_", %WaitForNextCallInterval="_..%WaitForNextCallInterval_", %QuitTask="_..%QuitTask )
			} Else {
				$$$catTRACE("ontask","returned from adapter's OnTask() : "_tTxt_", %WaitForNextCallInterval="_..%WaitForNextCallInterval_", %QuitTask="_..%QuitTask )
			}
			If $$$ISERR(tSC) {
				Set tDoAlert=..OnError(.tSC)
				If $$$ISERR(tSC) {
					Set tTxt=$P($$$StatusDisplayString(tSC)," -- ") // OnError might have changed it; strip off "logged as" varying text
					Set:'..%AlertStartTime&&..AlertOnError&&..AlertGracePeriod&&(tTxt'=..%LastReportedError) ..%AlertStartTime=$ZH
					If ..%AlertStartTime&&tDoAlert {
						If $ZH>=(..%AlertStartTime+..AlertGracePeriod) {
							Set ..%AlertStartTime=0
							If tTxt'=..%LastReportedError {
								$$$SetHostMonitor(..%ConfigName,$$$eMonitorStatus,"Error")
								$$$LOGERROR("Alerting at expiration of retry grace period ("_..AlertGracePeriod_") for "_tTxt)
							} Else { $$$LOGINFO("Alerting at expiration of retry grace period ("_..AlertGracePeriod_") for "_tTxt) }
						} Else {
							Set tDoAlert=0
							If tTxt'=..%LastReportedError {
								$$$SetHostMonitor(..%ConfigName,$$$eMonitorStatus,"Error")
								$$$LOGERROR("Not Alerting during retry grace period ("_..AlertGracePeriod_") for "_tTxt)
							} Else { $$$LOGINFO("Not Alerting during retry grace period ("_..AlertGracePeriod_") for "_tTxt) }
						}
					} Else {
						If tTxt'=..%LastReportedError {
							$$$SetHostMonitor(..%ConfigName,$$$eMonitorStatus,"Error")
							$$$LOGSTATUS(tSC)
						} Else { Set tDoAlert=0 }
					}
					Do:tDoAlert&&..AlertOnError ..SendAlert(##class(Ens.AlertRequest).%New($LB(..%ConfigName,$$$StatusDisplayString(tSC))))
				} Else { Set ..%AlertStartTime=0, tTxt="" }
				Set ..%LastReportedError=tTxt
				If '..%QuitTask Set tSC=$$$OK $$$catTRACE("ontask","Ignoring error from OnTask()") ; Don't break the OnTask() loop except when %QuitTask is set
			} Else { Set ..%AlertStartTime=0, tTxt="" }
			Set ..%LastReportedError=tTxt
			$$$CLOSEIOLOGENTRY(tSC,"After OnTask",$$$NULLOREF)
			Set ..%RequestHeader = $$$NULLOREF
			Quit:'..%WaitForNextCallInterval||..%QuitTask
			Set tCallInterval = ..Adapter.CallInterval  Set:tCallInterval<1 tCallInterval=1
			Set tNow=$ZH, tWaitK=-1,(tWait,tWaitCall)=tCallInterval-(tNow-tTimeCalled)
			If ..Adapter.KeepaliveInterval>0&&..%LastActionTime {
				Set tWaitK=..Adapter.KeepaliveInterval  Set:tWaitK<=0 tWaitK=-1
				If tWaitK>0 {
					Set tWaitK=tWaitK-(tNow-..%LastActionTime)  Set:tWaitK<0 tWaitK=0
					Set:tWait>tWaitK tWait=tWaitK, tWaitK=0, tWaitCall=tWaitCall-tWait
				}
			}
			#; wait the shorter of keepalive wait or CallInterval
			Set:tWait>0 tSC = ##class(Ens.Queue).DeQueue("SystemSignal:"_$Job,,tWait,,0)
			If 'tWaitK {
				Quit:$$$ISERR(tSC)  Set tSC=..Adapter.OnKeepalive(), ..%LastActionTime=$ZH  Quit:$$$ISERR(tSC)||'..%WaitForNextCallInterval||..%QuitTask
				#; if keepalive wait was shorter, wait the rest of CallInterval now.
				Set:tWaitCall>0 tSC = ##class(Ens.Queue).DeQueue("SystemSignal:"_$Job,,tWaitCall,,0)
			}
		}
	} While 0
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="GetRequestClassList">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>OnProcessInput</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSignature=$$$comMemberKeyGet(%class.Name,$$$cCLASSmethod,"OnProcessInput",$$$cMETHformalspecparsed)
	Set tClass=$lg($lg(tSignature,1),2)
	Do %code.WriteLine(" Quit $LB("""_tClass_""")")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetResponseClassList">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pRequest:%String=""</FormalSpec>
<GenerateAfter>OnProcessInput</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSignature=$$$comMemberKeyGet(%class.Name,$$$cCLASSmethod,"OnProcessInput",$$$cMETHformalspecparsed)
	Set tRequestClass=$lg($lg(tSignature,1),2)
	Set tClass=$lg($lg(tSignature,2),2)
	Do %code.WriteLine(" If pRequest=""""||(pRequest="""_tRequestClass_""") Quit $LB("""_tClass_""")")
	Do %code.WriteLine(" Quit """"")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%ProcessInputCalledGet">
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA['i%%WaitForNextCallInterval
]]></Implementation>
</Method>

<Method name="%ProcessInputCalledSet">
<Internal>1</Internal>
<FormalSpec>val</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Set i%%WaitForNextCallInterval='val
]]></Implementation>
</Method>

<Method name="CallProcessInputAsync">
<Description>
ProcessInput in a background job ...
If a Response is provided use CheckProcessInputAsyncStatus to retrieve the Response object.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pConfigName:%String,pRequest:%Persistent,&pRequestId:%String,pDelay:%Numeric=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Try {
		Set tSC = pRequest.%Save()
		Quit:$$$ISERR(tSC)
		Set tOid = pRequest.%Oid()
		// Grab a new request id in order to log response
		Set pRequestId = $INCREMENT($$$EnsRuntimeAppData("ProcessInputAsync"))
		Set $$$EnsRuntimeAppData("ProcessInputAsync",pRequestId,"request")=tOid
		Set $$$EnsRuntimeAppData("ProcessInputAsync",pRequestId,"service")=pConfigName
		// Record date so that it can be purged if synchronous and response not checked.
		Set $$$EnsRuntimeAppData("ProcessInputAsync",pRequestId,"date")=$P($H,",")
		// Start the job
		Job ##class(Ens.BusinessService).backgroundJob(pRequestId,pDelay)::5
		If '$TEST {
			Set tSC=$$$EnsError($$$EnsErrJobFailed,pConfigName)
			// Clean up ...
			Kill $$$EnsRuntimeAppData("ProcessInputAsync",pRequestId)
			Quit
		}
		// Now we're done ... call CheckProcessInputAsyncStatus(pRequestId,.tResponse) to follow up
	} Catch e {
		Set tSC=$$$EnsSystemError
	} 
	Quit tSC
]]></Implementation>
</Method>

<Method name="CheckProcessInputAsyncStatus">
<Description>
Check the status of a pending CallProcessInputAsync() operation
pResponse will be returned as the response generated as a result of a previous call using CallProcessInputAsync
provided the business service invoked returned a response. 
The return status will be an error if an error was encountered or returned by the business service.
pSessionId is the Ensemble session created by the business service called. 
If a response is expected for a qiven request then it may be necessary to call this method a number of times.
When a response or error is returned this method will clean up temporary data if pRemoveTempData is true (default is true)
and hence it is necessary to record the response/error and if necessary the session ID.
Cleanup of tempdata not automatically cleaned up can be done using PurgeProcessInputAsyncTempData method.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pRequestId:%String,&pResponse:%Persistent,&pSessionId:%String,pRemoveTempData:%Boolean=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Try {
		Set pResponse = $$$NULLOREF, pSessionId = ""
		// Check for our global
		If '$DATA($$$EnsRuntimeAppData("ProcessInputAsync",pRequestId)) {
			Set tSC = $$$EnsError($$$EnsErrNoResponseClass,"<<"_pRequestId_">>")
			Quit
		}
		// Now, check either for an error or completion
		Set tSC = $G($$$EnsRuntimeAppData("ProcessInputAsync",pRequestId,"error"),$$$OK)
		Quit:$$$ISERR(tSC)  // Error!
		// Check for completion of the message ...
		If $DATA($$$EnsRuntimeAppData("ProcessInputAsync",pRequestId,"response")) {
			Set tOid = $G($$$EnsRuntimeAppData("ProcessInputAsync",pRequestId,"response"))
			Set pSessionId = $G($$$EnsRuntimeAppData("ProcessInputAsync",pRequestId,"session"))
			If tOid'="" {
				// Open the response object
				Set pResponse = ##class(%Persistent).%Open(tOid,,.tSC)
			} Else {
				// We got no response ... report error and session if recorded.
				// If there is no error, default to one ...
				Set tSC = $$$EnsError($$$EnsErrNoMsgBody,$S(pSessionId'="":pSessionId,1:"<<"_pRequestId_">>"))
			}
		}
	} Catch e {
		Set tSC=$$$EnsSystemError
	}
	#;	Remove temp data if either errored or response written. 
	If pRemoveTempData,('tSC||$IsObject(pResponse)) Kill $$$EnsRuntimeAppData("ProcessInputAsync",pRequestId)
	Quit tSC
]]></Implementation>
</Method>

<Method name="backgroundJob">
<Description>
Background job entry point for calling ProcessInput in the background</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRequestId:%Integer,pDelay:%Numeric=0</FormalSpec>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Try {
		#dim tService As Ens.BusinessService
		Set tRequest = $$$NULLOREF
		Set tResponse = $$$NULLOREF
		// Check for our global
		If '$DATA($$$EnsRuntimeAppData("ProcessInputAsync",pRequestId)) {
			Set tSC = $$$EnsError($$$EnsErrNoResponseClass,"<<Session:"_pRequestId_">>")
			Quit
		}
		// Wait if there's any delay requested (e.g. for the production to start)
		If pDelay>0 Hang pDelay
		Set tOid = $G($$$EnsRuntimeAppData("ProcessInputAsync",pRequestId,"request"))
		Set tConfigName = $G($$$EnsRuntimeAppData("ProcessInputAsync",pRequestId,"service"))
		// Open our request
		Set tRequest = ##class(%Persistent).%Open(tOid,,.tSC)
		Quit:$$$ISERR(tSC)
		// Create the business service
		Set tSC = ##class(Ens.Director).CreateBusinessService(tConfigName,.tService)
		Quit:$$$ISERR(tSC)
		// Process the input (synchronously ...) and store the session id
		Set tSC = tService.ProcessInput(tRequest,.tResponse)
		Set $$$EnsRuntimeAppData("ProcessInputAsync",pRequestId,"session") = tService.%SessionId
		Quit:$$$ISERR(tSC)
		If $IsObject($G(tResponse)) {
			// Save the response!
			Set tSC = tResponse.%Save()
			Quit:$$$ISERR(tSC)
			// And store the response OID for retrieval
			Set tOid = tResponse.%Oid()
		} Else {
			// We got no response
			Set tOid = ""
		}
		// Store the Oid for the response (if any)
		Set $$$EnsRuntimeAppData("ProcessInputAsync",pRequestId,"response") = tOid
	} Catch e {
		Set tSC=e.AsStatus()
	}
Exit
	If $$$ISERR(tSC) {
		If $DATA($$$EnsRuntimeAppData("ProcessInputAsync",pRequestId)) {
			Set $$$EnsRuntimeAppData("ProcessInputAsync",pRequestId,"error")=tSC
		}
		// Log this with Ensemble
		$$$LOGSTATUS(tSC)
	} Else {
		Try { 
			#; Cleanup RuntimeAppData if the BS sent Async or the BS did not send the message on (null SessionId) nor did it create a response.
			If (tOid=""),((tService.%SessionId="")||(##class(Ens.MessageHeader).%OpenId(tService.%SessionId).Priority=$$$eMessagePriorityAsync)) Kill:$$$EnsRuntimeAppData("ProcessInputAsync",pRequestId)
		} Catch e {}
	}
	Quit
]]></Implementation>
</Method>

<Method name="PurgeProcessInputAsyncTempData">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pDeletedCount:%Integer,pDaysToKeep:%Integer=7</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK, pDeletedCount=0, tRequestId="",pDaysToKeep=$S(pDaysToKeep<0:0,1:pDaysToKeep)
	Set tDoNotDeleteDate = $H-pDaysToKeep+1
	Set tRequestId=$O($$$EnsRuntimeAppData("ProcessInputAsync",tRequestId))
	Try {
		While (tRequestId'="") {
			If ($G($$$EnsRuntimeAppData("ProcessInputAsync",tRequestId,"date"),($H+1)) < tDoNotDeleteDate) { 
				Kill $$$EnsRuntimeAppData("ProcessInputAsync",tRequestId)
				Set pDeletedCount=$I(pDeletedCount), tRequestId=$O($$$EnsRuntimeAppData("ProcessInputAsync",tRequestId))
			} Else { Set tRequestId = ""}
		}
	} Catch e { Set tSC = e.AsStatus()}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ForceSessionId">
<Description>
Pre-allocate a request header object and an ID for it to represent a fresh session even before we get around to sending our first request.
When we do get around to making our first SendRequest... call it will use this pre-allocated header.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If ..%SessionId'="" Quit $$$OK
	Set ..%RequestHeader = ##class(Ens.MessageHeader).%New()
	Set (..%SessionId, $$$JobSessionId, $$$JobCurrentHeaderId) = ..%RequestHeader.MessageId()
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnTearDown">
<Description>
This user callback method is called from %OnClose()</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If ""'=..%OutsideCreated {
		If 1'=..%OutsideCreated {
			#; Turn back on <DISCONNECT>  mode and "external interrupts" from the webserver because Ensemble is done and the job may get re-used by the CSP server
			#; These may have been disabled in OnPreSoap() or CreateBusinessService()
			try {
				Set tIO=$IO
				Use ..%OutsideCreated:(::"+D")
				Use:tIO'=..%OutsideCreated tIO
			} catch {
			}
			try {
				Do $System.Util.SetInterruptEnable(1)
			} catch {
			}
		}
		Do ##class(Ens.Job).UnRegister(..%ConfigName,$Job)
		#; Kill $$$EnsJobLocal, but make sure we retain trace device
		Set tTraceDevice = $get($$$JobTraceDevice)
		Kill $$$EnsJobLocal
		If (tTraceDevice '= "") Set $$$JobTraceDevice = tTraceDevice
		Set ..%OutsideCreated=""
	}
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Ens.Config.Item">
<ClassType>persistent</ClassType>
<IncludeCode>Ensemble</IncludeCode>
<IncludeGenerator>Ensemble</IncludeGenerator>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,%XML.Adaptor</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59268,43371.029</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="XMLIGNORENULL">
<Default>1</Default>
</Parameter>

<Parameter name="DOMAIN">
<Default>Ensemble</Default>
</Parameter>

<Property name="Production">
<Description>
Reference to the Production object.</Description>
<Type>Ens.Config.Production</Type>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="Name">
<Description>
The name of this config item.  Default is the class name.</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="128"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Category">
<Description>
Optional list of categories this item belongs to, comma-separated. This is only used for 
display purposes and does not affect the behavior of this item.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="2500"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="ClassName">
<Description>
Class name of this config item.</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="128"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="PoolSize">
<Description><![CDATA[
Number of jobs to start for this config item. <br>
Default value: <br>
0 for Business Processes (i.e. use shared Actor Pool) <br>
1 for FIFO message router Business Processes (i.e. use a dedicated job) <br>
1 for Business Operations <br>
0 for adapterless Business Services <br>
1 for others <br>
For TCP based Services with JobPerConnection=1, this value is used to limit the number of connection jobs if its value is greater than 1. A value of 0 or 1 places no limit on the number of connection jobs.]]></Description>
<Type>%Integer</Type>
<Parameter name="MINVAL" value="0"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Enabled">
<Description>
Whether this config item is enabled or not.</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Foreground">
<Description>
Whether to run the job of this config item in the foreground or background.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="DisableErrorTraps">
<Description>
Deprecated - Always 0 : Whether to disable error traps for the job or not.</Description>
<Type>%Boolean</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="InactivityTimeout">
<Description>
This property is now a shadow of a Host Config Setting of the same name.</Description>
<Type>%Numeric</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
<Parameter name="MINVAL" value="0"/>
<Parameter name="XMLIO" value="IN"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Settings">
<Description>
Adapter and host settings specified for the adapter object and the host object.</Description>
<Type>Ens.Config.Setting</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Setting"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModifiedSettings">
<Description>
Same format as Settings. You must call PopulateModifiedSettings() to populate this collection. 
The collection contains the list of settings that are either defined in the production, or have default setting overrides.</Description>
<Type>Ens.Config.Setting</Type>
<Collection>list</Collection>
<Transient>1</Transient>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="VirtualSettings">
<Description><![CDATA[
Contains the list of settings, value, value_type, default, default_type and other meta information. 
Must call PopulateVirtualSettings() to populate this collection. 
The format of value of each element is the following: <br>
$LB(Target, Name, Value, ValueType, Default, DefaultType, Description, Type, MAXLEN, MINVAL, MAXVAL, VALUELIST, DISPLAYLIST, IsRequired)]]></Description>
<Type>%String</Type>
<Collection>list</Collection>
<Transient>1</Transient>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="Comment">
<Description>
Optional comment text for this component.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="512"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="CommentOrClassname">
<Description>
Calculated comment-or-classname property.</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Method name="CommentOrClassnameGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$S(..Comment'="":..Comment,1:..ClassName)
]]></Implementation>
</Method>

<Property name="LogTraceEvents">
<Description>
Whether to log trace events for this item.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Schedule">
<Description><![CDATA[
Specifies times when this item should be stopped and restarted. 
You may enter a string formatted as a comma-separated list of event specifications, 
or you may enter the name of a schedule specification preceded by the @ symbol. 
To create a named schedule specification, use the Ensemble > Configure > Schedule Specs page.<br/>
<p>If you wish to simply enter an event specification string in this field, it must use the following format:</p>
<pre>action:YYYY-MM-DDThh:mm:ss[,action:YYYY-MM-DDThh:mm:ss]</pre>
<p>Where each item in the event specification, from left to right, has the values described below:</p>
<ul><li>action - must be either START or STOP</li>
<li>: - Required separator</li>
<li>YYYY-MM-DD - This part of the string must have one of the following two syntaxes:
<ul><li>YYYY is the year as 4 numerals, MM is the month as 2 numerals and DD is the day of the month as 2 numerals.<br/>
Any of these fields may be the single character * (asterisk) indicating all years, all months, or all days.</li> 
<li>YYYY is the string WEEK, MM is the specific occurrence of the day of the week (indicated by DD) in the month 
(01 = first occurrence of the specific day of the week in the month, 02 = second occurrence in the month, etc.), and 
DD is a specific day of the week (00 = Sunday, 01 = Monday, etc.).<br/>
MM may be * for all occurrences and DD may be * for all days.<br/></li></ul>
Note that once a field is specified as *, all fields to the left of it are also assumed to be *. 
Thus, if the DD value is *, the MM value is treated as * even if it has a specific numeric value. 
Similarly, if MM is *, YYYY is treated as *.</li>
<li>T - Required separator</li>
<li>hh:mm:ss - Hour, minute, and second</li>
<li>, - Use the comma separator only if there is another event specification after the current one. 
Do not use it at the end of the Schedule string.</li></ul>
<p>For example, to start the configuration item every day at 8 a.m. and stop it every day at 5 p.m. 
you could use the following schedule string:</p>
<pre>START:*-*-*T08:00:00,STOP:*-*-*T17:00:00</pre>
<p>As described at the beginning of this topic, you can also create a named schedule string. 
Assuming you named your schedule 'Daytime', you could then refer to your named schedule as follows:</p>
<pre>@Daytime</pre>]]></Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="AlertGroups">
<Description><![CDATA[
A computed property to reflect the values specified in the AlertGroups setting in <property>Settings</property>.
The primary purpose of this property is to allow us to build the <index>AlertGroup</index> index on all the individual
group values in the string. The actual breaking down of this value is performed in <method>AlertGroupBuildValueArray</method>().]]></Description>
<Type>%String</Type>
<SqlComputeCode> Set {AlertGroups} = ..ComputeAlertGroups({Settings})</SqlComputeCode>
<SqlComputed>1</SqlComputed>
<SqlComputeOnChange>Settings</SqlComputeOnChange>
<Parameter name="MAXLEN" value="2500"/>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Index name="AlertGroup">
<Description><![CDATA[
Index on all the group names defined in <property>AlertGroups</property>. The production is included in the
index to ensure that the available values are correct for each production.]]></Description>
<Properties>Production:Exact,AlertGroups(ELEMENTS):Exact</Properties>
</Index>

<Index name="Name">
<Description>
Index on the name of the config item as well as which production it is associated with.</Description>
<Properties>Production:Exact,Name:Exact</Properties>
</Index>

<Method name="%OnNew">
<Internal>1</Internal>
<FormalSpec>initvalue</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..ClassName=$g(initvalue)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="InactivityTimeoutSet">
<Description><![CDATA[
Ensure that changes to <property>InactivityTimeout</property> are pushed into the 
InactivityTimeout setting in <property>Settings</property>.]]></Description>
<FormalSpec>%newval</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSetting = ..FindSettingByName("InactivityTimeout", "Host")
	If '$IsObject(tSetting) {
		Set tSetting = ##class(Ens.Config.Setting).%New()
		Set tSetting.Name = "InactivityTimeout"
		Set tSetting.Target = "Host"
		Set tStatus = tSetting.ValueSet(%newval)
		If $$$ISERR(tStatus) Quit tStatus
		Set tStatus = ..Settings.Insert(tSetting)
	}
	Else {
		Set tStatus = tSetting.ValueSet(%newval)
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="InactivityTimeoutGet">
<Description><![CDATA[
Retrieve the value of <property>InactivityTimeout</property> from the
InactivityTimeout setting in <property>Settings</property>.]]></Description>
<ReturnType>%Numeric</ReturnType>
<Implementation><![CDATA[
	Set tSetting = ..FindSettingByName("InactivityTimeout", "Host")
	If '$IsObject(tSetting) {
		Set tSetting = ##class(Ens.Config.Setting).%New()
		Set tSetting.Name = "InactivityTimeout"
		Set tSetting.Target = "Host"
		Set tSetting.Value = 0
		Do ..Settings.Insert(tSetting)
	}
	Quit tSetting.Value
]]></Implementation>
</Method>

<Method name="ClassNameSet">
<Internal>1</Internal>
<FormalSpec>initvalue</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%ClassName=initvalue
	Do:""'=..ClassName ..initPoolSize()
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="initPoolSize">
<Internal>1</Internal>
<Implementation><![CDATA[
	Set $ZT="Trap"
	Set:""=..PoolSize ..PoolSize=$Case(..BusinessType()
								,$$$eHostTypeProcess:$S("Ens.Actor"=..ClassName:1, 1:0)
								,$$$eHostTypeService:$S(""=$classmethod(..ClassName,"%GetParameter","ADAPTER"):0, 1:1)
								,:1)
	Quit
Trap Set $ZT="", ..PoolSize=1
	Quit
]]></Implementation>
</Method>

<Method name="BusinessType">
<Description>
The Business type of this config item.</Description>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..GetBusinessType(..ClassName,$this)
]]></Implementation>
</Method>

<Method name="GetBusinessType">
<Description>
Get the business type of the config item. The return value macros are defined in EnsConstants.inc.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassname:%String,pThisObject:Ens.Config.Item</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap"
	Do {
		If pClassname="Ens.Actor" Set tValue=$$$eHostTypeProcess Quit
		If pClassname="Ens.Alarm" Set tValue=$$$eHostTypeOperation Quit
		If $classmethod(pClassname,"%Extends","Ens.BusinessDuplex")    Set tValue=$classmethod(pClassname,"OnBusinessType",pThisObject) Quit
		If $classmethod(pClassname,"%Extends","Ens.BusinessService")   Set tValue=$$$eHostTypeService   Quit
		If $classmethod(pClassname,"%IsA","Ens.BusinessProcess")       Set tValue=$$$eHostTypeProcess   Quit
		If $classmethod(pClassname,"%Extends","Ens.BusinessOperation") Set tValue=$$$eHostTypeOperation Quit
	} While 0
Exit
	Quit $G(tValue,$$$eHostTypeUnknown)
Trap
 	Set $ZT=""
	Goto Exit
]]></Implementation>
</Method>

<Method name="AdapterClassName">
<Description>
Name of the Adapter class used by this config item.</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#; calculated from the ADAPTER parameter.
	If ..ClassName="" Quit ""
	Quit $$$comMemberKeyGet(..ClassName,$$$cCLASSparameter,"ADAPTER",$$$cPARAMdefault)
]]></Implementation>
</Method>

<Method name="Checksum">
<Description>
Checksum used in updating production.</Description>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tValue=..Name_..ClassName_..Enabled_..Foreground
	Set tIndex="" For { Set tIndex = ..ModifiedSettings.Next(tIndex)  Quit:tIndex=""
		Set tSetting = ..ModifiedSettings.GetAt(tIndex)
		Set tValue=tValue_tSetting.Target_tSetting.Name_tSetting.Value
	}
	Quit $zcrc(tValue,7)
]]></Implementation>
</Method>

<Method name="NameGet">
<Description>
Return the class name if i%Name is not set.</Description>
<Internal>1</Internal>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If i%Name'="" Quit i%Name
	Quit ..ClassName
]]></Implementation>
</Method>

<Method name="QueueName">
<Description>
Queue name used by this config item.</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If ..Name'="" Quit ..Name
	Quit ..ClassName
]]></Implementation>
</Method>

<Method name="GetSetting">
<Description>
Get the config value of the named setting, return 0 if not defined, 1 if defined.</Description>
<FormalSpec><![CDATA[pSettingName:%String,&pValue:%String]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Kill pValue
	Set tKey="" For { Set tSetting=..Settings.GetNext(.tKey)  Quit:""=tKey
		If tSetting.Name = pSettingName {
			Set pValue = tSetting.Value
			Quit
		}
	}
	Quit ''$D(pValue)
]]></Implementation>
</Method>

<Method name="GetModifiedSetting">
<Description>
Get the config value of the named setting including resolution of system default settings, return 0 if not defined, 1 if defined.</Description>
<FormalSpec><![CDATA[pSettingName:%String,&pValue:%String]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Kill pValue
	try {
		Set tKey="" For { Set tSetting=..Settings.GetNext(.tKey)  Quit:tKey=""
			If tSetting.Name=pSettingName Set pValue=tSetting.Value  Quit
		}
		Quit:$D(pValue)

		If ##class(Ens.Config.DefaultSettings).%GetSetting(..Production.Name, ..Name, ..ClassName, "", pSettingName, .tValue) {
			Set pValue=tValue
			Quit
		}
		Set tValue=$classmethod(..ClassName,"EvalInitialExpression",pSettingName)
		If ""'=tValue Set pValue=tValue  Quit
	} catch { }
	Quit ''$D(pValue)
]]></Implementation>
</Method>

<Method name="getModifiedSettingValue">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pProductionName:%String,pItemName:%String,pType:%String="Host",pHostClass:%String="",pSettingName:%String,pSettingsList:%String="",&pStatus:%Status]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pStatus=$$$OK, tFound=0
	If (""=pHostClass)||(""=pSettingsList) {
		&sql(Select ClassName,Settings Into :tClass,:tSettings From Ens_Config.Item Where Production=:pProductionName and Name=:pItemName)
		If SQLCODE Set pStatus=$$$ERROR($$$EnsErrGeneral,"No Production '"_pProductionName_"' with config item '"_pItemName_" found: SQLCODE="_SQLCODE)  Quit ""
		Set:""=pSettingsList pSettingsList=tSettings
		Set:""=pHostClass pHostClass=tClass
	}
	For i=$LL(pSettingsList):-1:1 { Set tSetting=$LG($LI(pSettingsList,i))
		If $LI(tSetting,1)=pSettingName && ($LI(tSetting,2)=pType) && $LD(tSetting,3) {
			Set tFound=1, tValue=$LI(tSetting,3)
			Quit
		}
	}
	If 'tFound {
		#; Look through to default setting
		If "Host"=pType { Set tClass=pHostClass }
		Else { $$$comMemberKeyGetLvar(tClass,pHostClass,$$$cCLASSparameter,"ADAPTER",$$$cPARAMdefault) }
		If ##class(Ens.Config.DefaultSettings).%GetSetting(pProductionName,pItemName,tClass,pType,pSettingName,.tValue) {
			Set tFound=1
		}
		If 'tFound {
			#; Get InitialExpression for the setting
			Set tValue=$classmethod(tClass,"EvalInitialExpression",pSettingName)
			If ""'=tValue { Set tFound=1 }
			Else {
				#; Need to find if the Setting exists at all
				Set rs = ##class(%ResultSet).%New(tClass_":EnumerateSettings")
				Set tSC = rs.Execute()
				While rs.Next() { If pSettingName=$G(rs.Data("Name")) Set tFound=1  Quit }
				If 'tFound Set pStatus=$$$ERROR($$$EnsErrGeneral,"No Setting '"_pSettingName_"' found for config item '"_pItemName_" in Production '"_pProductionName_"'")
			}
		}
	}
	Quit tValue
]]></Implementation>
</Method>

<Method name="FindSettingByName">
<Description>
Locate the first setting with a given name.</Description>
<FormalSpec>pSettingName:%String,pTarget:%String=""</FormalSpec>
<ReturnType>Setting</ReturnType>
<Implementation><![CDATA[
	#dim i,tFound As Ens.Config.Setting
	Set tFound = $$$NULLOREF
	For i=1:1:..Settings.Count() {
		#dim tSetting As Setting
		Set tSetting = ..Settings.GetAt(i)

		// Match the name, and target (if specified)
		If $S(tSetting.Name'=pSettingName:0,pTarget="":1,1:tSetting.Target=pTarget) {
			Set tFound = tSetting
			Quit
		}
	}
	Quit tFound
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Description><![CDATA[
Ensure that we check that <property>Name</property> doesn't contain any illegal characters
when validating the object.]]></Description>
<Internal>1</Internal>
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit ..CheckForIllegalCharacters(..Name)
]]></Implementation>
</Method>

<Method name="CheckForIllegalCharacters">
<Description><![CDATA[
Check for characters that are illegal in configuration item names.
Characters <b> | ; , : [ </b> are not allowed at all,
characters <b> ! - $ </b> are not allowed as first or last character,
and character * is not allowed as the whole config name.]]></Description>
<FormalSpec>pName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// General use:
	// | is the separator for production and comment names when concatenated into a single string
	// ; is the separator for multi-Action Rules
	// , is the separator for multi-target Rule Actions
	// : is the separator for Rule Action components
	// Message Bank use (ArchiveItems setting):
	// * means all event types
	// [ appends an events spec
	// - at the front of an item means exclude it from archiving
	// - at the end of an item means exclude message headers from archiving <p>
	// ! at the end of an item means exclude message bodies from archiving
	// $ at the end of an item means exclude SearchTable entries if any from archiving

	Set tError = $$$Text("Illegal character %1 present in config item name")
	Quit:"*"=pName $$$ERROR($$$EnsErrGeneral, $$$FormatText(tError, "*")_" "_$$$Text("(not allowed as the only character)"))

	// Characters not allowed anywhere in the name
	Set t = "[|;,"  // [DMC755/DMC760] Used to contain ":" too
	Set tSC = $$$OK
	For i = 1:1:$L(t) { If pName[$E(t,i) Set tSC = $$$ERROR($$$EnsErrGeneral, $$$FormatText(tError, $E(t,i))) Quit  }
	If $$$ISOK(tSC) {
		// Characters not allowed as first character of the name
		Set t = "-"
		For i = 1:1:$L(t) { If $E(pName,1)=$E(t,i) Set tSC = $$$ERROR($$$EnsErrGeneral, $$$FormatText(tError, $E(t,i))_" "_$$$Text("(not allowed as the first character)"))  Quit }
		// Characters not allowed as last character of the name
		Set t = "-!$"
		For i = 1:1:$L(t) { If $E(pName,*)=$E(t,i) Set tSC = $$$ERROR($$$EnsErrGeneral, $$$FormatText(tError, $E(t,i))_" "_$$$Text("(not allowed as the last character)"))  Quit }
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="PopulateModifiedSettings">
<Description>
Call this method to initialize the ModifiedSettings collection.
The collection includes settings defined in the Production as well as those ones with default setting overrides.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	do ..ModifiedSettings.Clear()

	#dim tRegistrySettings As %String ;The array of settings found for the service registry entry identified as either Host, Adapter or Adapterorhost
	
	#;Look for RegistryID
	set tUsesRegistry = ..GetSetting("RegistryID",.tRegistryID)
	if tUsesRegistry {
		set tSC = ##class(Ens.ServiceRegistry.External.API).ParseServiceEndPoint(tRegistryID,.tRegistrySettings)
		if tSC {
			merge tAlreadyDefined("Host")=tRegistrySettings("Host")
			merge tAlreadyDefined("Adapter")=tRegistrySettings("Adapter")
			set tAlreadyDefined("Adapter","RegistryID")=tRegistryID
			set tTarget = $O(tAlreadyDefined(""))
			while (tTarget '="") {
				set tName = $O(tAlreadyDefined(tTarget,""),1,tThisValue)
				while tName '="" {
					set tOneSetting=##class(Ens.Config.Setting).%New()
					set tOneSetting.Target = tTarget
					set tOneSetting.Name = tName
					set tOneSetting.Value = tThisValue
					do ..ModifiedSettings.Insert(tOneSetting)
					set tName = $O(tAlreadyDefined(tTarget,tName),1,tThisValue)
				}
				set tTarget = $O(tAlreadyDefined(tTarget))
			}
		}
	} 
	;
	set tIndex="" for  {
		set tIndex = ..Settings.Next(tIndex)  quit:tIndex=""
		set tOneSetting = ..Settings.GetAt(tIndex)
		if $d(tAlreadyDefined(tOneSetting.Target,tOneSetting.Name)) continue
		if $d(tRegistrySettings("Adapterorhost",tOneSetting.Name),tThisValue) {
			set tAlreadyDefined(tOneSetting.Target,tOneSetting.Name)=tThisValue
			set tRegistrySettings(tOneSetting.Target,tOneSetting.Name)=tThisValue
			set tOneSetting=##class(Ens.Config.Setting).%New()
			set tOneSetting.Target = tOneSetting.Target
			set tOneSetting.Name = tOneSetting.Name
			set tOneSetting.Value = tThisValue
			do ..ModifiedSettings.Insert(tOneSetting)
		} else {
			set tAlreadyDefined(tOneSetting.Target,tOneSetting.Name)=""
			do ..ModifiedSettings.Insert(tOneSetting)
		}
	}
	;
	set tTargetClassname("Host") = ..ClassName
	set tTargetClassname("Adapter") = ..AdapterClassName()
	set tTarget="" for  {
		set tTarget=$o(tTargetClassname(tTarget),1,tClassname) quit:tTarget=""
		set rs = ##class(%ResultSet).%New()
		set rs.ClassName = tClassname
		set rs.QueryName = "EnumerateSettings"
		if ('rs.QueryIsValid()) continue
		set tSC = rs.Execute()
		while (rs.Next()) {
			set tName = $G(rs.Data("Name"))
			if $d(tAlreadyDefined(tTarget,tName)) continue
			if '$d(tRegistrySettings("Adapterorhost",tName),tValue) {
				if '##class(Ens.Config.DefaultSettings).%GetSetting(..Production.Name, ..Name, ..ClassName, tTarget, tName, .tValue) set tValue=$G(rs.Data("Default"))
			}
			set tOneSetting=##class(Ens.Config.Setting).%New()
			set tOneSetting.Target = tTarget
			set tOneSetting.Name = tName
			set tOneSetting.Value = tValue
			do ..ModifiedSettings.Insert(tOneSetting)
		}
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="GetStaticSettings">
<Description>
Return a list of all the common static settings properties for the current config item.</Description>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[&pList]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do %code.WriteLine(" Kill pList  Set tSC=$$$OK, tBusType=..GetBusinessType(..ClassName)")
	For tProp="Comment","Schedule","Category","Classname","Description","AdapterClassname","AdapterDescription","Enabled","Foreground","LogTraceEvents","PoolSize" {
		#; IsAdapter,Name,Value,ValueSource,DefaultValue,DefaultSource,Description,DataType,MAXLEN,MINVAL,MAXVAL,VALUELIST,DISPLAYLIST,IsRequired,LocalizedName,Category,LocalizedCategory,EditorContext
		Do %code.WriteLine(" ; ** "_tProp_" **")
		Do:tProp="Foreground" %code.WriteLine(" If ..PoolSize||(tBusType'=$$$eHostTypeProcess) {")
		If tProp["Description" {
			If tProp="AdapterDescription" {
				Do %code.WriteLine(" Set tAdapterClass=$$$comMemberKeyGet(..ClassName,$$$cCLASSparameter,""ADAPTER"",$$$cPARAMdefault)")
				Do %code.WriteLine(" Set tVal=$S(""""=tAdapterClass:"""",1:$$$comClassKeyGet(tAdapterClass,$$$cCLASSdescription))")
				Set tDesc="Description of the Adapter class used by this config item"
			} Else {
				Do %code.WriteLine(" Set tVal=$$$comClassKeyGet(..ClassName,$$$cCLASSdescription)")
				Set tDesc="Description of the class used by this config item"
			}
			Set tType=$$$NormalizeClassname("%String")
			Do %code.WriteLine(" Set Row=$lb(""Core"","""_tProp_""",tVal,$$$eConfigSettingValueTypeReadOnly)")
			Do %code.WriteLine(" Set Row=Row_$lb(tVal,$$$eConfigSettingValueTypeProperty)")
		} ElseIf tProp["Classname" {
			If tProp="AdapterClassname" {
				Do %code.WriteLine(" Set tVal=..AdapterClassName()")
				Set tDesc=$$$defMemberKeyGet("Ens.Config.Item",$$$cCLASSmethod,"AdapterClassName",$$$cMETHdescription)
			} Else {
				Do %code.WriteLine(" Set tVal=..ClassName")
				Set tDesc=$$$defMemberKeyGet("Ens.Config.Item",$$$cCLASSproperty,"ClassName",$$$cPROPdescription)
			}
			Set tType=$$$NormalizeClassname("Ens.DataType.Class")
			Do %code.WriteLine(" Set Row=$lb(""Core"","""_tProp_""",tVal,$$$eConfigSettingValueTypeReadOnly)")
			Do %code.WriteLine(" Set Row=Row_$lb(tVal,$$$eConfigSettingValueTypeProperty)")
		} Else {
			Set tInitVal=$$$defMemberKeyGet("Ens.Config.Item",$$$cCLASSproperty,tProp,$$$cPROPinitialexpression)
			Set tDesc=$$$defMemberKeyGet("Ens.Config.Item",$$$cCLASSproperty,tProp,$$$cPROPdescription)
			Set tType=$$$NormalizeClassname($$$defMemberKeyGet("Ens.Config.Item",$$$cCLASSproperty,tProp,$$$cPROPtype))
			Do %code.WriteLine(" Set tVal=.."_tProp)
			If tProp="Name" {
				Do %code.WriteLine(" Set Row=$lb(""Core"","""_tProp_""",tVal,$$$eConfigSettingValueTypeReadOnly)")
			} Else {
				Do %code.WriteLine(" Set Row=$lb(""Core"","""_tProp_""",tVal,$S(tVal="""_tInitVal_""":$$$eConfigSettingValueTypeProperty,1:$$$eConfigSettingValueTypeProduction))")
			}
			Do %code.WriteLine(" Set Row=Row_$lb("_tInitVal_",$$$eConfigSettingValueTypeProperty)")
		}		
		Set tDesc=$Replace( $TR( $Replace(tDesc,$C(13,10),$C(13)), $C(10),$C(13)) ,$C(13),"""_"_$C(13,10)_"   """)
		Do %code.WriteLine(" Set Row=Row_$lb("""_tDesc_""","""_tType_""")")
		For tParam="MAXLEN","MINVAL","MAXVAL","VALUELIST","DISPLAYLIST" {
			Do %code.WriteLine(" Set Row=Row_$lb("""_$$$defMemberArrayGet("Ens.Config.Item",$$$cCLASSproperty,tProp,$$$cPROPparameter,tParam)_""")")
		}
		Do %code.WriteLine(" Set Row=Row_$lb("_$$$defMemberKeyGet("Ens.Config.Item",$$$cCLASSproperty,tProp,$$$cPROPrequired)_")")
		Do %code.WriteLine(" Set Row=Row_$lb($$$GetLocalizedName("""_tProp_"""))")
		Set tCat=$Case(tProp
			,"Name":"Info"
			,"Comment":"Info"
			,"Schedule":"Additional"
			,"Category":"Info"
			,"Classname":"Info"
			,"Description":"Info"
			,"AdapterClassname":"Info"
			,"AdapterDescription":"Info"
			,"Enabled":"Basic"
			,"Foreground":"Dev"
			,"LogTraceEvents":"Dev"
			,"PoolSize":"Additional"
			,:"Additional"
			)
		Do %code.WriteLine(" Set Row=Row_$lb("""_tCat_""")")
		Do %code.WriteLine(" Set Row=Row_$lb($$$GetLocalizedName("""_tCat_"""))")
		Set tEdContext=$Case(tProp
			,"Schedule":"scheduleSelector"
			,"Category":"selector?multiSelect=1&context={Ens.ContextSearch/ProductionCategories?productionName=@productionId}"
			,:""
			)
		If tProp="Classname" {
			Do %code.WriteLine(" Set Row=Row_$lb($S(##class(EnsPortal.Utils).IsSubclass(..ClassName,""Ens.BusinessProcessBPL""):""bplSelector"",1:""""))")
		} Else {
			Do %code.WriteLine(" Set Row=Row_$lb("""_$Replace(tEdContext,"""","""""")_""")")
		}
		Do %code.WriteLine(" Set pList($I(tIndex))=Row")
		Do:tProp="Foreground" %code.WriteLine(" }")
	}
	Do %code.WriteLine(" Quit tSC")
]]></Implementation>
</Method>

<Method name="PopulateVirtualSettings">
<Description>
Populate the VirtualSettings collection.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	do ..VirtualSettings.Clear()
	#;Look for RegistryID
	
	#dim tRegistrySettings As %String ;The array of settings found for the service registry entry identified as either Host, Adapter or Adapterorhost
	#dim tRegistryValues As %String ;The array of settings found for the service registry entry identified as either Host or Adapter
	
	set tUsesRegistry = ..GetSetting("RegistryID",.tRegistryID)
	if tUsesRegistry {
		set tSC = ##class(Ens.ServiceRegistry.External.API).ParseServiceEndPoint(tRegistryID,.tRegistrySettings)
		if tSC {
			merge tAlreadyDefined("Host")=tRegistrySettings("Host")
			merge tAlreadyDefined("Adapter")=tRegistrySettings("Adapter")
			#;need to be able to identify as $$$eConfigSettingValueTypeRegistry
			merge tRegistryValues=tAlreadyDefined
			set tAlreadyDefined("Adapter","RegistryID")=tRegistryID
		}
	} 

	set tIndex="" for  {
		set tIndex = ..Settings.Next(tIndex)  quit:tIndex=""
		set tOneSetting = ..Settings.GetAt(tIndex)
		if $d(tRegistrySettings("Adapterorhost",tOneSetting.Name),tThisValue) {
			set tAlreadyDefined(tOneSetting.Target,tOneSetting.Name)=tThisValue
			set tRegistryValues(tOneSetting.Target,tOneSetting.Name)=tThisValue
			set tRegistrySettings(tOneSetting.Target,tOneSetting.Name)=tThisValue
		} else {
			set tAlreadyDefined(tOneSetting.Target,tOneSetting.Name)=tOneSetting.Value
		}
	}
	
	set tTargetClassname("Host") = ..ClassName
	set tTargetClassname("Adapter") = ..AdapterClassName()
	set tTarget="" for  {
		set tTarget=$o(tTargetClassname(tTarget),1,tClassname) quit:tTarget=""
		set rs = ##class(%ResultSet).%New()
		set rs.ClassName = tClassname
		set rs.QueryName = "EnumerateSettings"
		if ('rs.QueryIsValid()) continue
		set tSC = rs.Execute()
		while (rs.Next()) {
			set tName = $G(rs.Data("Name"))
			set tDefault = $G(rs.Data("Default"))
			set tDefaultType=$$$eConfigSettingValueTypeProperty
			set tValue=tDefault
			set tValueType=$$$eConfigSettingValueTypeProperty
			if $d(tRegistryValues(tTarget,tName),tThisValue)||$d(tRegistrySettings("Adapterorhost",tName),tThisValue) {
				set tValue=tThisValue
				set tValueType=$$$eConfigSettingValueTypeRegistry
			} else {
				if ##class(Ens.Config.DefaultSettings).%GetSetting(..Production.Name, ..Name, ..ClassName, tTarget, tName, .tThisValue) {
					set tDefault = tThisValue
					set tDefaultType = $$$eConfigSettingValueTypeSystem
					set tValue = tThisValue
					set tValueType = $$$eConfigSettingValueTypeSystem
				}
				if $d(tAlreadyDefined(tTarget,tName),tThisValue) {
					set tValue=tThisValue
					set tValueType=$$$eConfigSettingValueTypeProduction
				}
			}
			#; Target,Name,Value,ValueType,Default,DefaultType,Description,Type,MAXLEN,MINVAL,MAXVAL,VALUELIST,DISPLAYLIST,IsRequired,LocalizedName,Category,LocalizedCategory,EditorContext
			set tData = $lb(tTarget,tName,tValue,tValueType,tDefault,tDefaultType)
			set tData = tData _ $lb($g(rs.Data("Description")))
			set tData = tData _ $lb($g(rs.Data("Type")))
			set tData = tData _ $lb($g(rs.Data("MAXLEN")))
			set tData = tData _ $lb($g(rs.Data("MINVAL")))
			set tData = tData _ $lb($g(rs.Data("MAXVAL")))
			set tData = tData _ $lb($g(rs.Data("VALUELIST")))
			set tData = tData _ $lb($g(rs.Data("DISPLAYLIST")))
			set tData = tData _ $lb($g(rs.Data("IsRequired")))
			set tData = tData _ $lb($$$GetLocalizedName(tName))
			set tGroup = $g(rs.Data("Category"))
			set tData = tData _ $lb(tGroup)
			set tData = tData _ $lb($$$GetLocalizedName(tGroup))
			set tData = tData _ $lb($g(rs.Data("EditorContext")))
			do ..VirtualSettings.Insert(tData)
		}
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="UpdateSettings">
<Description><![CDATA[
This method updates the settings collection with the data from <var>pArray</var>.
The settings collection is cleared first, then the entries in <var>pArray</var> are used to update it.
The format of <var>pArray</var> is the following: <br>
pArray = total number of entries <br>
pArray(i) = $LB(Target, Name, Value)]]></Description>
<FormalSpec>pArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	do ..Settings.Clear()
	for i=1:1:pArray {
		set tOneSetting = ##class(Ens.Config.Setting).%New()
		set tOneSetting.Target = $li(pArray(i),1)
		set tOneSetting.Name = $li(pArray(i),2)
		set tOneSetting.Value = $li(pArray(i),3)
		do ..Settings.Insert(tOneSetting)
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnAddToSaveSet">
<Description><![CDATA[
Callback invoked as part of the initial <method>%Save</method>() processing to ensure
that the item has a <property>Name</property> defined and to ensure that the value of
<property>AlertGroups</property> is up-to-date as not all changes to <property>Settings</property>
seem to trigger the SQL Compute Code.]]></Description>
<Internal>1</Internal>
<FormalSpec>depth:%Integer=3,insert:%Integer=0,callcount:%Integer=0</FormalSpec>
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set:""=i%Name i%Name=i%ClassName
	Set tAlertGroupsSetting = ..FindSettingByName("AlertGroups","Host")
	If $IsObject(tAlertGroupsSetting) {
		Set i%AlertGroups = tAlertGroupsSetting.Value
	}
	Else {
		Set i%AlertGroups = ""
	}
	Do ..ModifiedSettings.%SetModified(0)
	If $data($$$EnsProdSettings) {
		If $IsObject($get($$$EnsProdSettingsProperty("prod"))) && '$IsObject(..Production) {
			Set ..Production = $$$EnsProdSettingsProperty("prod")
		}
		ElseIf $IsObject(..Production) {
			Do ..Production.%AddToSaveSet(depth)
			If '$IsObject($get($$$EnsProdSettingsProperty("prod"))) {
				Set $$$EnsProdSettingsProperty("prod") = ..Production
			}
		}
		If ..%IsModified() || $get($$$EnsProdSettingsOref($this)) {
			$$$EnsProdSettingsSetModified(1)
		}
	}
	Else {
		Set tProduction = ..ProductionGetObjectId()
		If (tProduction '= "") {
			Do ##class(Ens.Config.Production).SetModified(tProduction)
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ComputeAlertGroups">
<Description><![CDATA[
Method to compute the value of <property>AlertGroups </property> based on the value of
the AlertGroups setting in the serialized <property>Settings</property> list passed in as <var>pSettings</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSettings</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tAlertGroups = ""
	Set tSettings = $get(pSettings)
	If $listvalid(tSettings) && ($listlength(tSettings) > 0) {
		Set tActualList = $listget(tSettings)
		If $listvalid(tActualList) && ($listlength(tActualList) > 0) {
			#; Remove outer list framing to get $lb(<serial>,<serial>) state
			While $listvalid($listget(tActualList,1)) && $listvalid($listget($listget(tActualList,1),1)) && ($listlength($listget(tActualList,1)) > 0) {
				Set tActualList = $listget(tActualList,1)
			}
			For i=1:1:$listlength(tActualList) {
				Set tSetting = $listget(tActualList,i)
				If ($listget(tSetting,1) = "AlertGroups") && ($listget(tSetting,2) = "Host") {
					Set tAlertGroups = $listget(tSetting,3)
					Quit
				}
			}
		}
	}
	Quit tAlertGroups
]]></Implementation>
</Method>

<Method name="AlertGroupsBuildValueArray">
<Description>
Helper method to allow the individual values in AlertGroups to be indexed.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pAlertGroups:%String="",*pValueArray:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If $get(pAlertGroups) '= "" {
		Set tCount = 0
		For i=1:1:$length(pAlertGroups,",") {
			Set tGroup = $piece(pAlertGroups,",",i)
			If (tGroup '= "") {
				Set tCount = tCount + 1
				Set pValueArray(tCount) = tGroup
			}
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Trigger name="OnChange">
<Description>
Ensure we update the modified flag after SQL changes.</Description>
<Code>	If ({Production} '= "") {
		Do ##class(Ens.Config.Production).SetModified({Production})
	}</Code>
<Event>INSERT/UPDATE/DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Ens.Config.ItemD</DataLocation>
<DefaultData>ItemDefaultData</DefaultData>
<IdLocation>^Ens.Config.ItemD</IdLocation>
<IndexLocation>^Ens.Config.ItemI</IndexLocation>
<StreamLocation>^Ens.Config.ItemS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="ItemDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClassName</Value>
</Value>
<Value name="3">
<Value>DisableErrorTraps</Value>
</Value>
<Value name="4">
<Value>Enabled</Value>
</Value>
<Value name="5">
<Value>Foreground</Value>
</Value>
<Value name="6">
<Value>InactivityTimeout</Value>
</Value>
<Value name="7">
<Value>Name</Value>
</Value>
<Value name="8">
<Value>PoolSize</Value>
</Value>
<Value name="9">
<Value>Settings</Value>
</Value>
<Value name="10">
<Value>Comment</Value>
</Value>
<Value name="11">
<Value>Category</Value>
</Value>
<Value name="12">
<Value>LogTraceEvents</Value>
</Value>
<Value name="13">
<Value>Schedule</Value>
</Value>
<Value name="14">
<Value>Production</Value>
</Value>
<Value name="15">
<Value>AlertGroups</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Ens.Config.Production">
<IncludeCode>Ensemble,%ZEN.ReportUtil</IncludeCode>
<IncludeGenerator>EnsUtil</IncludeGenerator>
<Super>%Persistent,%XML.Adaptor</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59262,38860.205</TimeCreated>

<Parameter name="XMLNAME">
<Default>Production</Default>
</Parameter>

<Parameter name="XMLIGNORENULL">
<Default>1</Default>
</Parameter>

<Property name="Name">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="128"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Description">
<Description>
Description of the production.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="500"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="ActorPoolSize">
<Description>
Actor pool size for the production. This is the number of jobs that will be shared by business processes not configured to use a private job pool.</Description>
<Type>%Integer</Type>
<InitialExpression>1</InitialExpression>
<Parameter name="MAXVAL" value="128"/>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="TestingEnabled">
<Description>
Enable testing infrastructure for the production.</Description>
<Type>%Boolean</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="LogGeneralTraceEvents">
<Description>
Log trace events that are not associated with any particular config item.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Settings">
<Description>
Production settings</Description>
<Type>Ens.Config.Setting</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Setting"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ModifiedSettings">
<Description>
Same format as Settings, You must call PopulateModifiedSettings() to populate this collection
The collection contains the list of settings that are either defined in the production, or have default setting overrides.</Description>
<Type>Ens.Config.Setting</Type>
<Collection>list</Collection>
<Transient>1</Transient>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="VirtualSettings">
<Description>
Contains the list of settings, value, value_type, default, default_type and other meta information
Must call PopulateVirtualSettings() to populate this collection
The format of value of each element is the following
$lb(Target,Name,Value,ValueType,Default,DefaultType,Description,Type,MAXLEN,MINVAL,MAXVAL,VALUELIST,DISPLAYLIST,IsRequired)</Description>
<Type>%String</Type>
<Collection>list</Collection>
<Transient>1</Transient>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="Items">
<Type>Ens.Config.Item</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Item"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="SubProductions">
<Description>
Property SubProductions As list Of Ens.Config.Production(XMLNAME = "SubProduction", XMLPROJECTION = "ELEMENT", XMLREFERENCE = "id");</Description>
<Type>Ens.Config.SubProduction</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="SubProduction"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Index name="indexName">
<IdKey>1</IdKey>
<Properties>Name</Properties>
</Index>

<Method name="%OnNew">
<FormalSpec>initvalue</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..Name=$g(initvalue)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ActorDebugSetting">
<FormalSpec>pKeyword:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tValue=0
	For i=1:1:..Items.Count() {
		Set tItem = ..Items.GetAt(i)
		If tItem.BusinessType()'=$$$eHostTypeProcess Continue
		If tItem.PoolSize'=0 Continue
		Set tValue=$zobjproperty(tItem,pKeyword)
		If tValue Quit
	}
	Quit tValue
]]></Implementation>
</Method>

<Method name="SaveToClass">
<Description>
This method saves the production into the XData of the corresponding class</Description>
<FormalSpec>pItem:Ens.Config.Item=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Try {
		Set tClassName=..Name

		#; open the class definition, if doesn't exist, create it anew
		Set tClassDefinition = ##class(%Dictionary.ClassDefinition).%OpenId(tClassName)
		If '$IsObject(tClassDefinition) {
			Set tClassDefinition = ##class(%Dictionary.ClassDefinition).%New(tClassName)
			$$$ASSERT($IsObject(tClassDefinition))
			Set tClassDefinition.Super = "Ens.Production"
		}

		#; delete the old XDATA block named ProductionDefinition
		Set tIndex = tClassDefinition.XDatas.FindObjectId(tClassName_"||ProductionDefinition")
		If tIndex'="" Do tClassDefinition.XDatas.RemoveAt(tIndex)
		
		#; define a new XDATA block named ProductionDefinition
		Set tXDataDefinition = ##class(%Dictionary.XDataDefinition).%New()
		$$$ASSERT($IsObject(tClassDefinition))

		Set tXDataDefinition.Name="ProductionDefinition"
		Set tXDataDefinition.parent=tClassDefinition

		#; export to stream
		Set tSC=..XMLExportToStream(tXDataDefinition.Data,,"literal,indent") Quit:$$$ISERR(tSC)

		Set tSC=tClassDefinition.%Save() Quit:$$$ISERR(tSC)
		Do $classmethod(tClassName,"OnConfigChange",$this,pItem)
		If $IsObject(pItem) {
			Try { Do $classmethod(pItem.ClassName,"OnConfigChange",$this,pItem) }
			Catch ex {
				If "<METHOD DOES NOT EXIST>" = $extract(ex.Name,1,$length("<METHOD DOES NOT EXIST>")) {
					Set tSC = $$$OK
				}
				Else {
					Set tSC = $$$EnsSystemError
				}
			}
		}
	}
	Catch {
		Set tSC = $$$EnsSystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="LoadFromClass">
<Description>
This method loads the production from the XData of a class</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName:%String</FormalSpec>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	New $$$EnsProdSettings
	Do {
		Set tSC = ##Class(Ens.Util.XML.Reader).ObjectFromXData(.tObject,pClassName,"ProductionDefinition","Ens.Config.Production")  Quit:$$$ISERR(tSC)

		If ##class(Ens.Config.Production).%ExistsId(pClassName) {
			Do ##class(Ens.Config.Production).%DeleteId(pClassName)
		}
		$$$EnsProdSettingsSetModified(1)
		Set tObject.Name=pClassName
		Set tSC=tObject.%Save()
	} While 0
Exit
	Quit tSC
Trap
 	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="RemoveItem">
<Description>
Remove the given config item from the production</Description>
<FormalSpec>target:Ens.Config.Item=$$$NULLOREF</FormalSpec>
<Implementation><![CDATA[
	Set targid=$S($IsObject(target):target.%Id(),1:"")
	Quit:""=targid
	Set nItems=..Items.Count()  For i = 1:1:nItems {  Set item = ..Items.GetAt(i)
		If $IsObject(item) && (item.%Id() = targid) {
			Do ..Items.RemoveAt(i)
			Do ##class(Ens.Config.Item).%DeleteId(item.%Id())
			Set target.Production=$$$NULLOREF
			Quit
		}
	}
]]></Implementation>
</Method>

<Method name="GetCallTargets">
<FormalSpec><![CDATA[pItem:Ens.Config.Item,&pArray]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		Set tSC=$$$OK
		Set tClassName=pItem.ClassName
		Do ..GetConnections(.tArray,tClassName,pItem)
		try { If $$$comClassDefined(tClassName) Do $zobjclassmethod(tClassName,"OnGetConnections",.tArray,pItem) } catch {}
		Set tName="" For  {
			Set tName=$o(tArray(tName)) Quit:tName=""
			If $data(pArray(tName)) Continue
			Set tItem=..FindItemByConfigName(tName)
			set pArray(tName)=tItem
			If tItem'=$$$NULLOREF Set tSC=..GetCallTargets(tItem,.pArray) If $$$ISERR(tSC) Quit
		}
	} catch {
		set tSC=$$$ERROR($$$CacheError,$ZE)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetConnections">
<Description>
For given business class, return an array of business classes it talks to (left to right)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&array:%String,rootclass:%String,item:Ens.Config.Item]]></FormalSpec>
<Implementation><![CDATA[
	Do $system.OBJ.GetPackageList(.tList,rootclass,"ars")
	Set tList(rootclass)=""
	Set class="" For { Set class=$o(tList(class)) Quit:class=""
		If $$$comClassDefined(class) {
			Set method="" For { Set method=$$$comMemberNext(class,$$$cCLASSmethod,method) Quit:method=""
				Set origin=$$$comMemberKeyGet(class,$$$cCLASSmethod,method,$$$cMETHorigin)
				If origin="" Continue
				Do ..scanmethod(class,origin,method,.array)
			}
		} Else {
			Set method="" For { Set method=$$$defMemberNext(class,$$$cCLASSmethod,method) Quit:method=""
				Do ..scanmethod(class,class,method,.array)
			}
		}
	}
	/* Don't bother; config page will invoke callback
	set $zt="UserError"
	If $$$comClassDefined(rootclass) {
		do $zobjclassmethod(rootclass,"OnGetConnections",.array,item)
	}
	*/
Exit
	Quit
UserError
	Set tSC = $$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="ProductionStateToText">
<Description><![CDATA[
API to convert the numeric production status value in <var>pState</var> into the corresponding
text string. By default, the string is localized, but if <var>pLocalize</var> is passed in as 0,
the English string is returned irrespective of the user's current language settings. ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pState:%Integer=$$$eProductionStateUnknown,pLocalize:%Boolean=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tLanguage = $select(pLocalize: $$$SessionLanguage, 1: "en")
	Quit $case(pState
		,$$$eProductionStateRunning:			$$$Text("Running","Ensemble",tLanguage)
		,$$$eProductionStateStopped:			$$$Text("Stopped","Ensemble",tLanguage)
		,$$$eProductionStateSuspended:			$$$Text("Suspended","Ensemble",tLanguage)
		,$$$eProductionStateTroubled:			$$$Text("Troubled","Ensemble",tLanguage)
		,$$$eProductionStateUnknown:			$$$Text("Unknown","Ensemble",tLanguage)
		,$$$eProductionStateBackupRunning:		$$$Text("MirrorBackup: Running","Ensemble",tLanguage)
		,$$$eProductionStateBackupStopped:		$$$Text("MirrorBackup: Stopped","Ensemble",tLanguage)
		,$$$eProductionStateBackupSuspended:	$$$Text("MirrorBackup: Suspended","Ensemble",tLanguage)
		,$$$eProductionStateBackupTroubled:		$$$Text("MirrorBackup: Troubled","Ensemble",tLanguage)
		,$$$eProductionStateBackupUnknown:		$$$Text("MirrorBackup: Unknown","Ensemble",tLanguage)
		,	:$$$Text("Unrecognized","Ensemble",tLanguage)_":"_pState)
]]></Implementation>
</Method>

<Method name="ProductionTextToState">
<Description><![CDATA[
API to convert the text of a production status in <var>pText</var> into the corresponding 
state value, which serves as a partial inverse to <method>ProductionStateToText</method>().
It only serves as a partial inverse as the status text can depend on the language settings at the
time of the original conversion from a state integer to a status text. If the language is known,
it can be supplied in <var>pLanguage</var>, otherwise it will default to the current language for the process.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pText:%String,pLanguage:%String=$$$SessionLanguage</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Quit $case(pText
		,$$$Text("Running","Ensemble",pLanguage):					$$$eProductionStateRunning
		,$$$Text("Stopped","Ensemble",pLanguage): 					$$$eProductionStateStopped
		,$$$Text("Suspended","Ensemble",pLanguage):					$$$eProductionStateSuspended
		,$$$Text("Troubled","Ensemble",pLanguage):					$$$eProductionStateTroubled
		,$$$Text("Unknown","Ensemble",pLanguage):					$$$eProductionStateUnknown
		,$$$Text("MirrorBackup: Running","Ensemble",pLanguage):		$$$eProductionStateBackupRunning
		,$$$Text("MirrorBackup: Stopped","Ensemble",pLanguage):		$$$eProductionStateBackupStopped
		,$$$Text("MirrorBackup: Suspended","Ensemble",pLanguage):	$$$eProductionStateBackupSuspended
		,$$$Text("MirrorBackup: Troubled","Ensemble",pLanguage):	$$$eProductionStateBackupTroubled
		,$$$Text("MirrorBackup: Unknown","Ensemble",pLanguage):		$$$eProductionStateBackupUnknown
		,	:$$$eProductionStateUnknown)
]]></Implementation>
</Method>

<Method name="scanmethod">
<ClassMethod>1</ClassMethod>
<FormalSpec>defclass,class,method,array</FormalSpec>
<Implementation><![CDATA[
	For i=1:1:$$$defMemberKeyGet(class,$$$cCLASSmethod,method,$$$cMETHimplementation) {
		Set line=$$$defMemberArrayGet(class,$$$cCLASSmethod,method,$$$cMETHimplementation,i)
		Set line=$p($p($p(line,"//",1),"#;",1),";",1)
		//Set line=$tr(line," ")
		For j=1:2:$l(line,"""") Set $p(line,"""",j)=$tr($p(line,"""",j)," ")
		Set configname=..findcall(defclass, line,"SendRequestSync",1)  Set:configname'="" array(configname)=""
		Set configname=..findcall(defclass, line,"SendRequestAsync",1) Set:configname'="" array(configname)=""
		Set configname=..findcall(defclass, line,"MakeAsyncCall",2)    Set:configname'="" array(configname)=""
		Set configname=..findcall(defclass, line,"MakeSyncCall",2)     Set:configname'="" array(configname)=""
	}
	Quit
]]></Implementation>
</Method>

<Method name="findcall">
<ClassMethod>1</ClassMethod>
<FormalSpec>defclass,line,method,argument</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set f=$find(line,"."_method_"(") Quit:f=0 ""
	For i=2:2:$l(line,"""") Set piece=$tr($p(line,"""",i),",","."),$p(line,"""",i)=piece
	Set arg=$p($e(line,f,32768),",",argument),l=$l(arg)
	If $e(arg,1,2)="""""",$e(arg,l-1,l)="""""",$e(arg,3,l-2)'["""" Quit $p(arg,"""""",2)
	If $e(arg,1)="""",$e(arg,l)="""",$e(arg,2,l-1)'[""""           Quit $p(arg,"""",2)
	If $e(arg,1,3)="..#"  Quit $$$comMemberKeyGet(defclass,$$$cCLASSparameter,$e(arg,4,32767),$$$cPARAMdefault)
	Quit ""
]]></Implementation>
</Method>

<Query name="ProductionStatus">
<Type>%Query</Type>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Production:%String,Status:%String,LastStartTime:%String,LastStopTime:%String,StatusEnum:%String"/>
</Query>

<Method name="ProductionStatusExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tIndex=$increment(^CacheTemp)
	Set tSC = ##class(Ens.Director).GetProductionStatus(.tProductionName,.tState) Quit:$$$ISERR(tSC)
	Set tRS=##class(%ResultSet).%New("Ens.Config.Production:Extent")
	Set tSC=tRS.Execute()
	#; Check if the state is for a mirror backup
	Set tStoppedValue = $select(tState < 0: $$$eProductionStateBackupStopped, 1: $$$eProductionStateStopped)
	For {
		Quit:tRS.Next()=0
		Set tThisProduction = tRS.GetData(1)
		Set ^CacheTemp(tIndex,tThisProduction)=$s(tThisProduction=tProductionName: tState, 1: tStoppedValue)
	}
	Set qHandle=$lb(tIndex,"")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ProductionStatusFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>ProductionStatusExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set index=$list(qHandle,1)
	Set class=$list(qHandle,2)
	Set class=$order(^CacheTemp(index,class))
	If class="" {
		Set Row="",AtEnd=1
	} Else {
		Set display=..ProductionStateToText(^CacheTemp(index,class))
		Set Row=$lb(class,display,$$$timeUTCtoLocal($get(^Ens.Configuration("csp","Activity",class,"started"))),$$$timeUTCtoLocal($get(^Ens.Configuration("csp","Activity",class,"stopped"))),^CacheTemp(index,class)),AtEnd=$order(^CacheTemp(index,class))=""
	}
	Set qHandle=$lb(index,class)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ProductionStatusClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>ProductionStatusExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set index=$list(qHandle,1)
	Kill ^CacheTemp(index)
	Set qHandle=""
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="EnumerateConfigItems">
<Description>
Enumerate all config items in the given Production.
Passing ItemType restricts the results to only items of the given type, for example $$$eHostTypeService.
Prefixing the type with a minus sign restricts the results to all except those of the given type, for example -$$$eHostTypeService.
Passing PrimaryOnly=0 will return multiple items with the same name if any exist. Otherwise only the primary (i.e. enabled) item will be returned.</Description>
<Type>%Query</Type>
<FormalSpec>Production:%String="",ItemType:%Integer="",PrimaryOnly:%Boolean=1</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="ConfigName:%String,CommentOrClassName:%String,Enabled:%Boolean,BusinessType:%Integer,ClassName:%String,RequestClasses:%String,ResponseClasses:%String,Production:%String,ItemId:%Integer,SeqNum:%String,BusPartner:%String,Categories:%String,AlertGroups:%String"/>
</Query>

<Method name="EnumerateConfigItemsExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,Production:%String="",ItemType:%Integer="",PrimaryOnly:%Boolean=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill qHandle  Set qHandle=0, qHandle(0)=$I(%EnsEnumItems), tQ=qHandle(0)
	If ""'=Production { Set qHandle=1, %EnsEnumItems(tQ,1)=Production }
	Else {
		Set tRS=##class(%ResultSet).%New("Ens.Config.Production:Extent")
		Set tSC=tRS.Execute()  Quit:$$$ISERR(tSC)
		For i=1:1 { Quit:'tRS.Next()
			Set qHandle=i, %EnsEnumItems(tQ,i)=tRS.GetData(1)
		}
	}
	Set tSC=$$$OK
	For iProd=1:1:qHandle {
		Set tProduction = ##class(Ens.Config.Production).%OpenId(%EnsEnumItems(tQ,iProd),,.tSC)
		If '$IsObject(tProduction)||$$$ISERR(tSC) { Set tSC=$$$ADDSC(tSC,$$$ERROR($$$EnsErrProductionNotRegistered,%EnsEnumItems(tQ,iProd),$$$StatusDisplayString(tSC)))  Continue }

		#; Construct list of all matching enabled items, and the first we find that's a perfect match
		Set tCount=tProduction.Items.Count()
		For iItem=1:1:tCount { Set tItem = tProduction.Items.GetAt(iItem)
			Set tType=tItem.BusinessType()
			Continue:$S(ItemType="":0, "-"=$E(ItemType):(tType=$E(ItemType,2,$L(ItemType))), 1:(tType'=ItemType))
			Set iSub=$I(%EnsEnumItems(tQ,iProd,tType,tItem.Name))
			Set %EnsEnumItems(tQ,iProd,tType,tItem.Name,iSub)=tItem.CommentOrClassname
			Set %EnsEnumItems(tQ,iProd,tType,tItem.Name,iSub,"enabled")=tItem.Enabled
			Set %EnsEnumItems(tQ,iProd,tType,tItem.Name,iSub,"classname")=tItem.ClassName
			Set %EnsEnumItems(tQ,iProd,tType,tItem.Name,iSub,"id")=tItem.%Id()
			Set %EnsEnumItems(tQ,iProd,tType,tItem.Name,iSub,"seq")=iItem
			Set %EnsEnumItems(tQ,iProd,tType,tItem.Name,iSub,"cats")=tItem.Category
			Set %EnsEnumItems(tQ,iProd,tType,tItem.Name,iSub,"alertgroups")=tItem.AlertGroups
			Set tPartner=tItem.FindSettingByName("BusinessPartner","Host")
			Set %EnsEnumItems(tQ,iProd,tType,tItem.Name,iSub,"partner")=$S($IsObject(tPartner):tPartner.Value,1:"")
			Set (tReq,tResp)=""
			If tType'=$$$eHostTypeActor {
				try {
					Set tList=$zobjclassmethod(tItem.ClassName,"GetRequestClassList")
					For r=1:1:$LL(tList) { Set tReq=tReq_$LI(tList,r)_"," } Set $E(tReq,$L(tReq))=""
					Set tList=$zobjclassmethod(tItem.ClassName,"GetResponseClassList")
					For r=1:1:$LL(tList) { Set tResp=tResp_$LI(tList,r)_"," } Set $E(tResp,$L(tResp))=""
				} catch {
				}
			}
			Set %EnsEnumItems(tQ,iProd,tType,tItem.Name,iSub,"req")=tReq
			Set %EnsEnumItems(tQ,iProd,tType,tItem.Name,iSub,"resp")=tResp

			#; See if this one is new or supersedes one already found
			Set tOldPriority=$G(%EnsEnumItems(tQ,iProd,tType,tItem.Name,"priority"))
			If ""=tOldPriority {
				Set %EnsEnumItems(tQ,iProd,tType,tItem.Name,"primary")=iSub
				Set %EnsEnumItems(tQ,iProd,tType,tItem.Name,"priority")=$S(tItem.%Id()=$G($$$ConfigId(tItem.Name)):2, tItem.Enabled:1, 1:0)
			} Else {
				#; See if this one supersedes the best one found so far
				#; prefer the one that's running or one that's enabled
				If tOldPriority<2 {
					Set tPriority = $S(tItem.%Id()=$G($$$ConfigId(tItem.Name)):2, tItem.Enabled:1, 1:0)
					Set:tPriority>tOldPriority %EnsEnumItems(tQ,iProd,tType,tItem.Name,"primary")=iSub, %EnsEnumItems(tQ,iProd,tType,tItem.Name,"priority")=tPriority
				}
			}
		}
	} Quit:$$$ISERR(tSC) tSC
	Set qHandle("sub")="", qHandle("name")="", qHandle("type")="", qHandle("prod")=0, qHandle("primaryOnly")=PrimaryOnly
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnumerateConfigItemsFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>EnumerateConfigItemsExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill Row Set Row=""
	Set tQ=$G(qHandle(0)), iProd=$G(qHandle("prod")), tType=$G(qHandle("type")), tName=$G(qHandle("name")), iSub=$G(qHandle("sub"))
	For { If ""=tType Set iProd=$Case(iProd,"":"",$G(qHandle):"",:iProd+1)  Quit:""=iProd
		For { If ""=tName Set tType=$O(%EnsEnumItems(tQ,iProd,tType)) Quit:""=tType
			For { If 'iSub Set tName=$O(%EnsEnumItems(tQ,iProd,tType,tName)) Quit:""=tName
				Set tPrimary=$G(%EnsEnumItems(tQ,iProd,tType,tName,"primary"))
				#; increment or set the sub-item
				If qHandle("primaryOnly") {
					Set iSub=$S(iSub:"",1:tPrimary)
				} Else {
					Set iSub=$Case(iSub, "":tPrimary, tPrimary:$S(tPrimary=1:2,1:1), tPrimary-1:tPrimary+1, :iSub+1)  Set:iSub>%EnsEnumItems(tQ,iProd,tType,tName) iSub=""  Quit:""=iSub
				} Quit:+iSub
			} Quit:+iSub
		} Quit:+iSub
	} ; now we're either at the end or we have iProd,tType,tName,iSub not empty
	Set qHandle("prod")=iProd
	If ""=iProd Set AtEnd=1  Quit $$$OK

	#; build the Row list
	//ConfigName,CommentOrClassName,Enabled,BusinessType,ClassName,RequestClasses,ResponseClasses,Production,ItemId,SeqNum,BusPartner
	Set tCOC=%EnsEnumItems(tQ,iProd,tType,tName,iSub)
	Set tEnabled=%EnsEnumItems(tQ,iProd,tType,tName,iSub,"enabled")
	Set tClass=%EnsEnumItems(tQ,iProd,tType,tName,iSub,"classname")
	Set tReq=%EnsEnumItems(tQ,iProd,tType,tName,iSub,"req")
	Set tResp=%EnsEnumItems(tQ,iProd,tType,tName,iSub,"resp")
	Set tProd=%EnsEnumItems(tQ,iProd)
	Set tId=%EnsEnumItems(tQ,iProd,tType,tName,iSub,"id")
	Set tSeq=%EnsEnumItems(tQ,iProd,tType,tName,iSub,"seq")
	Set tPartner=%EnsEnumItems(tQ,iProd,tType,tName,iSub,"partner")
	Set tCats=%EnsEnumItems(tQ,iProd,tType,tName,iSub,"cats")
	Set tAlertGroups=%EnsEnumItems(tQ,iProd,tType,tName,iSub,"alertgroups")
	Set Row=$LB(tName,tCOC,tEnabled,tType,tClass,tReq,tResp,tProd,tId,tSeq,tPartner,tCats,tAlertGroups)
	Set qHandle("type")=tType, qHandle("name")=tName, qHandle("sub")=iSub
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="EnumerateConfigItemsClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateConfigItemsExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tQ=$G(qHandle(0))
	Kill:tQ %EnsEnumItems(tQ)  Kill:tQ=1 %EnsEnumItems ; in-proc so no concurrency issues
	Kill qHandle
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="EnumerateConfigItemNames">
<Description>
Enumerate all configuration item names whose underlying class is a subclass of the class specified by ClassName,
for the given Production. This is used, for example, to list all business metrics within a given production, to 
support the DeepSee widget finder. It is more lightweight and faster than EnumerateConfigItems, but returns less data.
If the Production string is an empty string ("") list all config item names of a particular class for all productions.</Description>
<Type>%Query</Type>
<FormalSpec>Production:%String="",ClassName:%String=""</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Production:%String,ConfigName:%String,ClassName:%String,Comment:%String,Enabled:%Boolean"/>
</Query>

<Method name="EnumerateConfigItemNamesExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,Production:%String="",ClassName:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill qHandle  Set qHandle=0, qHandle(0)=$I(%EnsEnumItemNames), tQ=qHandle(0) // Put the top-level subscript in tQ and qHandle(0)
	If ""'=Production { Set qHandle=1, %EnsEnumItemNames(tQ,1)=Production }
	Else { // We are looking in all productions
		Set tRS=##class(%ResultSet).%New("Ens.Config.Production:Extent")
		Set tSC=tRS.Execute()  Quit:$$$ISERR(tSC)
		For i=1:1 { Quit:'tRS.Next()
			Set qHandle=i, %EnsEnumItemNames(tQ,i)=tRS.GetData(1) // Put the production name in %EnsEnumItemNames(tQ,i)
		}
	}
	Set tSC=$$$OK

	#; qHandle holds the number of productions; iterate over them
	For iProd=1:1:qHandle { Set tProductionName = %EnsEnumItemNames(tQ,iProd)
		&sql(DECLARE C1 CURSOR FOR
			SELECT Name,ClassName,Comment,Enabled
			INTO :tConfigName,:tClassName,:tComment,:tEnabled
			FROM Ens_Config.Item 
			WHERE Production = :tProductionName
		)
		#; Set up the global with the values
		&sql(OPEN C1)
		For i=1:1 { &sql(FETCH C1)  Quit:SQLCODE
			try {
				If ""=ClassName || $classmethod(tClassName,"%Extends",ClassName) {
					Set %EnsEnumItemNames(tQ,iProd,tConfigName,tClassName,$S(""'=tComment:tComment,1:$C(0)))=+tEnabled
				}
			} catch {
			}
		} Set tCode=SQLCODE &sql(CLOSE C1) Set:'SQLCODE SQLCODE=tCode
	}
	Set qHandle("prod")=0, qHandle("name")="", qHandle("class")="", qHandle("comment")=""
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnumerateConfigItemNamesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>EnumerateConfigItemsExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill Row Set Row=""
	Set tQ=$G(qHandle(0)), iProd=$G(qHandle("prod")), tName=$G(qHandle("name")), tClassName=$G(qHandle("class")), tComment=$G(qHandle("comment"))
	For { If ""=tName Set iProd=$Case(iProd,"":"",$G(qHandle):"",:iProd+1)  Quit:""=iProd
		For { If ""=tClassName Set tName=$O(%EnsEnumItemNames(tQ,iProd,tName))  Quit:""=tName
			For { If ""=tComment Set tClassName=$O(%EnsEnumItemNames(tQ,iProd,tName,tClassName))  Quit:""=tClassName
				Set tComment=$O(%EnsEnumItemNames(tQ,iProd,tName,tClassName,tComment),1,tEnabled)  Quit
			} Quit:""'=tComment
		} Quit:""'=tComment
	} ; now we're either at the end or we have iProd,tName,tClassName,tComment not empty
	Set qHandle("prod")=iProd, qHandle("name")=tName, qHandle("class")=tClassName, qHandle("comment")=tComment
	If ""=iProd Set AtEnd=1  Quit $$$OK
	Set tProductionName=%EnsEnumItemNames(tQ,iProd)

	Set Row=$LB(tProductionName,tName,tClassName,$S($C(0)'=tComment:tComment,1:""),tEnabled)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="EnumerateConfigItemNamesClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateConfigItemsExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tQ=$G(qHandle(0))
	Kill:tQ %EnsEnumItemNames(tQ)  Kill:(tQ=1)&&(1=$G(%EnsEnumItemNames)) %EnsEnumItemNames ; in-proc so no concurrency issues
	Kill qHandle
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="EnumerateCategories">
<Description>
Returns an alphabetically sorted list of all non-blank category names that are used by host items in the identified production. </Description>
<Type>%Query</Type>
<FormalSpec>Production:%String</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Category:%String"/>
</Query>

<Method name="EnumerateCategoriesExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,Production:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK, SQLCODE=0
	Set qHandle = ""
	&sql(DECLARE C2 CURSOR FOR 
		SELECT Category INTO :tRaw FROM Item 
		WHERE Production = :Production)
	&sql(OPEN C2) For { &sql(FETCH C2)  Quit:SQLCODE
		For i = $LENGTH(tRaw,","):-1:1 {
			Set tCat = $ZSTRIP($PIECE(tRaw,",",i),"<>WC")
			If (tCat '= "") {
				Set qHandle(tCat) = ""
			}
		}
	} Set tCode=SQLCODE &sql(CLOSE C2) Set:'SQLCODE SQLCODE=tCode
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnumerateCategoriesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>EnumerateCategoriesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set qHandle = $O(qHandle(qHandle))
	If qHandle = "" {
		Set Row = ""
		Set AtEnd = 1
	}
	Else {
		Set Row = $LB(qHandle)
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="EnumerateCategoriesClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateCategoriesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set qHandle = ""
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="EnumerateAlertGroups">
<Description>
Returns an alphabetically sorted list of all non-blank Alert Groups that are used by host items in the identified production. </Description>
<Type>%Query</Type>
<FormalSpec>Production:%String</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="AlertGroup:%String"/>
</Query>

<Method name="EnumerateAlertGroupsExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,Production:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If $get(Production) = "" Quit $$$ERROR($$$LoadObjectNotFound,"Ens.Config.Production",Production)
	Set qHandle = ""
	Set qHandle("production") = Production
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="EnumerateAlertGroupsFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set qHandle = $order(^Ens.Config.ItemI("AlertGroup",qHandle("production"),qHandle))
	If qHandle = "" {
		Set Row = ""
		Set AtEnd = 1
	}
	Else {
		Set Row = $LB(qHandle)
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="EnumerateAlertGroupsClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set qHandle = ""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnAddToSaveSet">
<FormalSpec>depth:%Integer=3,insert:%Integer=0,callcount:%Integer=0</FormalSpec>
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If $data($$$EnsProdSettings) && '$IsObject($get($$$EnsProdSettingsProperty("prod"))) {
		Set $$$EnsProdSettingsProperty("prod") = $this
	}
	For i=1:1:..Items.Count() {
		Set tItem = ..Items.GetAt(i)
		If tItem.ProductionGetObjectId() '= ..%Id() {
			Set tItem.Production = $this
			Do tItem.%AddToSaveSet(depth)
		}
	}
	Do ..ModifiedSettings.%SetModified(0)
	If ..%IsModified() {
		If $data($$$EnsProdSettings) {
			$$$EnsProdSettingsSetModified(1)
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnAfterSave">
<FormalSpec>insert:%Boolean</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If $$$EnsProdSettingsModified || $data($$$EnsProdSettings("orefs")) {
		Do ..SetModified(..Name)
		$$$EnsProdSettingsSetModified(0)
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set id=$$$oidPrimary(oid)
	&sql(Delete from Ens_Config.Item where Production=:id)
	quit $$$OK
]]></Implementation>
</Method>

<Trigger name="OnDelete">
<Code><![CDATA[	new id
	set id={%%ID}
	&sql(Delete from Ens_Config.Item where Production=:id)
	quit]]></Code>
<Event>DELETE</Event>
</Trigger>

<Method name="FindItemByConfigName">
<Description>
Locate the config item matching the given config name. It may be a simple name or a fully qualified one as described in ParseConfigName()</Description>
<FormalSpec>pConfigItemName:%String,*pStatus:%Status=$$$OK</FormalSpec>
<ReturnType>Ens.Config.Item</ReturnType>
<Implementation><![CDATA[
	Do ##class(Ens.Director).ParseConfigItemName(pConfigItemName,.tProductionName,.tItemName,.tCommentOrClass)
	Set:tProductionName=##class(Ens.Director).GetActiveProductionName() tProductionName=..Name ; override default
	If tProductionName'=..Name Set pStatus=$$$ERROR($$$EnsErrGeneral,"Can't find item from Production '"_pConfigItemName_"' in Production '"_..Name_"'")  Quit $$$NULLOREF
	If tProductionName=$G($$$EnsRuntime("Name")) && (""=tCommentOrClass) && (tItemName=$G($$$DispatchNameToConfigName(tItemName),"|")) {
		Set tFound=##class(Ens.Config.Item).%OpenId(+$G($$$ConfigId(tItemName)))
		Quit:$IsObject(tFound) tFound
	}
	Quit ..findItemByName(tItemName,tCommentOrClass,.pStatus)
]]></Implementation>
</Method>

<Method name="OpenItemByConfigName">
<Description>
Open the config item matching the given config name. It may be a simple name or a fully qualified one as described in ParseConfigName()</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pConfigItemName:%String,*pStatus:%Status=$$$OK</FormalSpec>
<ReturnType>Ens.Config.Item</ReturnType>
<Implementation><![CDATA[
	Do ##class(Ens.Director).ParseConfigItemName(pConfigItemName,.tProductionName,.tItemName,.tCommentOrClass)
	If tProductionName=$G($$$EnsRuntime("Name")) && (""=tCommentOrClass) && (tItemName=$G($$$DispatchNameToConfigName(tItemName),"|")) {
		Set tFound=##class(Ens.Config.Item).%OpenId(+$G($$$ConfigId(tItemName)))
		Quit:$IsObject(tFound) tFound
	}
	Set tItemId=..findItemIdByName(tProductionName,tItemName,tCommentOrClass,.pStatus)  Quit:$$$ISERR(pStatus) $$$NULLOREF
	Quit ##class(Ens.Config.Item).%OpenId(tItemId,,.pStatus)
]]></Implementation>
</Method>

<Method name="FindSettingByName">
<Description>
Locate the first setting with a given name.</Description>
<FormalSpec>pName:%String,pTarget:%String=""</FormalSpec>
<ReturnType>Setting</ReturnType>
<Implementation><![CDATA[
	Set tFound = $$$NULLOREF
	For i=1:1:..Settings.Count() {
		#dim tSetting As Setting
		Set tSetting = ..Settings.GetAt(i)

		#; Match the name, and target (if specified)
		If tSetting.Name=pName && (""=pTarget || (tSetting.Target=pTarget)) {
			Set tFound = tSetting
			Quit
		}
	}
	Quit tFound
]]></Implementation>
</Method>

<Method name="findItemByName">
<Description>
finds an item by name in the current Ens.Config.Production object's Items list, forces it to be swizzled</Description>
<Internal>1</Internal>
<FormalSpec>pItemName:%String,pCommentOrClass:%String,*pStatus:%Status,*pEnabledItems</FormalSpec>
<ReturnType>Ens.Config.Item</ReturnType>
<Implementation><![CDATA[
	Set tItemObj=$$$NULLOREF, tItemId=..findItemIdByName(..Name,.pItemName,.pCommentOrClass,.pStatus,.pEnabledItems)  Quit:$$$ISERR(pStatus) $$$NULLOREF
	For i=1:1:pEnabledItems { Set tId=pEnabledItems(i)
		Set tItemPos=..Items.FindObjectId(tId)
		Set pEnabledItems(i)= ..Items.GetAt(tItemPos)
		Set:tId=tItemId tItemObj=pEnabledItems(i)
	}
	Quit:$IsObject(tItemObj) tItemObj
	Set tItemPos=..Items.FindObjectId(tItemId)
	Quit ..Items.GetAt(tItemPos)
]]></Implementation>
</Method>

<Method name="findItemIdByName">
<Description>
finds a config item's Ens.Config.Item id by name in the named Ens.Config.Production</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pProductionName:%String,pItemName:%String,pCommentOrClass:%String,*pStatus:%Status,*pEnabledItemIds=0</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	If ""=pItemName Set pStatus=$$$ERROR($$$EnsErrGeneral,"Empty ItemName")  Quit ""
	#; Scan list of all matching enabled production items, and select the first we find that's a perfect match
	Set tEnabled=0, tFoundID="", pStatus=$$$OK
	&sql(DECLARE CNAMEDITEM CURSOR FOR
		SELECT ID,ClassName,Comment,Enabled INTO :tID,:tClassname,:tComment,:tEnabled FROM Ens_Config.Item WHERE Production = :pProductionName AND Name = :pItemName)
	&sql(OPEN CNAMEDITEM)
	For i=1:1 { &sql(FETCH CNAMEDITEM)  Quit:SQLCODE
		Continue:$$$eHostTypeUnknown=##class(Ens.Config.Item).GetBusinessType(tClassname,$$$NULLOREF)
		Set:tEnabled pEnabledItemIds($I(pEnabledItemIds))=tID
		#; If CommentOrClass is specified, then it must match either tItem.ClassName or tItem.Comment
		Continue:(""'=pCommentOrClass)&&(pCommentOrClass'=tClassname)&&(pCommentOrClass'=tComment)

		#; Save the found ones, with the subscript indicating the degree of preference; prefer an enabled one over a disabled one and a comment match over a classname match
		If (tID=$G($$$ConfigId(pItemName))) {
			Set tFoundItems(0.5)=tID ; prefer the one that's running
			Continue
		}
		If (""=pCommentOrClass)||(pCommentOrClass=tClassname) {
			Set tFoundItems($S(tEnabled:1,1:3))=tID
			Continue
		}
		If (""=pCommentOrClass)||(pCommentOrClass=tComment) {
			Set tFoundItems($S(tEnabled:2,1:4))=tID
			Continue
		}
	} Set tCode=SQLCODE &sql(CLOSE CNAMEDITEM) Set:'SQLCODE SQLCODE=tCode
	If SQLCODE'=100&&SQLCODE Set pStatus=$$$ERROR($$$EnsErrGeneral,"SQL Error finding config item "_pItemName_$S(""=pCommentOrClass:"",1:"|"_pCommentOrClass)_" in Production "_pProductionName_" : SQLCODE="_SQLCODE_" / "_$G(%msg))  Quit ""
	If '$O(tFoundItems(""),1,tFoundID)||'$L(tFoundID) Set pStatus=$$$ERROR($$$EnsErrConfigItemNotFound,pItemName_$S(""=pCommentOrClass:"",1:"|"_pCommentOrClass),pProductionName)  Quit ""
	Quit tFoundID
]]></Implementation>
</Method>

<Method name="PopulateModifiedSettings">
<Description>
Call this method to initialize the ModifiedSettings collection.
The collection includes Settings defined in production as well as those ones with default setting overrides.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	do ..ModifiedSettings.Clear()
	set tIndex="" for  {
		set tIndex = ..Settings.Next(tIndex)  quit:tIndex=""
		set tOneSetting = ..Settings.GetAt(tIndex)
		set tAlreadyDefined(tOneSetting.Name)=""
		do ..ModifiedSettings.Insert(tOneSetting)
	}
	;
	set tClassname = ..Name
	set rs = ##class(%ResultSet).%New()
	set rs.ClassName = tClassname
	set rs.QueryName = "EnumerateSettings"
	if ('rs.QueryIsValid()) quit $$$OK
	set tSC = rs.Execute()
	while (rs.Next()) {
		set tName = $G(rs.Data("Name"))
		if $d(tAlreadyDefined(tName)) continue
		if '##class(Ens.Config.DefaultSettings).%GetSetting(tClassname,"$Production",tClassname,"Production",tName,.tValue) set tValue=$G(rs.Data("Default"))
		set tOneSetting=##class(Ens.Config.Setting).%New()
		set tOneSetting.Name = tName
		set tOneSetting.Value = tValue
		do ..ModifiedSettings.Insert(tOneSetting)
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="GetStaticSettings">
<Description>
Return a list of all the common static settings properties for the current Production</Description>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[&pList]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do %code.WriteLine(" Kill pList  Set tSC=$$$OK")
	For tProp="Description","ActorPoolSize","TestingEnabled","LogGeneralTraceEvents" {
		#; Target,Name,Value,ValueType,Default,DefaultType,Description,Type,MAXLEN,MINVAL,MAXVAL,VALUELIST,DISPLAYLIST,IsRequired,LocalizedName,Category,LocalizedCategory,EditorContext
		Do %code.WriteLine(" ; ** "_tProp_" **")
		Set tInitVal=$$$defMemberKeyGet("Ens.Config.Production",$$$cCLASSproperty,tProp,$$$cPROPinitialexpression)
		Set tDesc=$$$defMemberKeyGet("Ens.Config.Production",$$$cCLASSproperty,tProp,$$$cPROPdescription)
		Do %code.WriteLine(" Set tVal=.."_tProp)
		Do %code.WriteLine(" Set Row=$lb(""Core"","""_tProp_""",tVal,$S(tVal="""_tInitVal_""":$$$eConfigSettingValueTypeProperty,1:$$$eConfigSettingValueTypeProduction))")
		Do %code.WriteLine(" Set Row=Row_$lb("_tInitVal_",$$$eConfigSettingValueTypeProperty)")

		Set tDesc=$Replace( $TR( $Replace(tDesc,$C(13,10),$C(13)), $C(10),$C(13)) ,$C(13),"""_"_$C(13,10)_"   """)
		Do %code.WriteLine(" Set Row=Row_$lb("""_tDesc_""")")
		Do %code.WriteLine(" Set Row=Row_$lb("""_$$$NormalizeClassname($$$defMemberKeyGet("Ens.Config.Production",$$$cCLASSproperty,tProp,$$$cPROPtype)_""")"))
		For tParam="MAXLEN","MINVAL","MAXVAL","VALUELIST","DISPLAYLIST" {
			Do %code.WriteLine(" Set Row=Row_$lb("""_$$$defMemberArrayGet("Ens.Config.Production",$$$cCLASSproperty,tProp,$$$cPROPparameter,tParam)_""")")
		}
		Do %code.WriteLine(" Set Row=Row_$lb("_$$$defMemberKeyGet("Ens.Config.Production",$$$cCLASSproperty,tProp,$$$cPROPrequired)_")")
		Do %code.WriteLine(" Set Row=Row_$lb($$$GetLocalizedName("""_tProp_"""))")
		Set tCat=$Case(tProp
			,"Description":"Info"
			,"ActorPoolSize":"Basic"
			,"TestingEnabled":"Dev"
			,"LogGeneralTraceEvents":"Dev"
			,:"Additional"
			)
		Do %code.WriteLine(" Set Row=Row_$lb("""_tCat_""")")
		Do %code.WriteLine(" Set Row=Row_$lb($$$GetLocalizedName("""_tCat_"""))")
		Set tEdContext=""
		Do %code.WriteLine(" Set Row=Row_$lb("""_$Replace(tEdContext,"""","""""")_""")")
		Do %code.WriteLine(" Set pList($I(tIndex))=Row")
	}
	Do %code.WriteLine(" Quit tSC")
]]></Implementation>
</Method>

<Method name="PopulateVirtualSettings">
<Description>
Populate the VirtualSettings collection</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	do ..VirtualSettings.Clear()
	set tIndex="" for  {
		set tIndex = ..Settings.Next(tIndex)  quit:tIndex=""
		set tOneSetting = ..Settings.GetAt(tIndex)
		set tAlreadyDefined(tOneSetting.Name)=tOneSetting.Value
	}
	;
	set tClassname = ..Name
	set rs = ##class(%ResultSet).%New()
	set rs.ClassName = tClassname
	set rs.QueryName = "EnumerateSettings"
	if ('rs.QueryIsValid()) quit $$$OK
	set tSC = rs.Execute()
	while (rs.Next()) {
		set tName = $G(rs.Data("Name"))
		set tDefault = $G(rs.Data("Default"))
		set tDefaultType=$$$eConfigSettingValueTypeProperty
		set tValue=tDefault
		set tValueType=$$$eConfigSettingValueTypeProperty
		if ##class(Ens.Config.DefaultSettings).%GetSetting(tClassname,"$Production",tClassname,"Production",tName,.tThisValue) {
			set tDefault = tThisValue
			set tDefaultType = $$$eConfigSettingValueTypeSystem
			set tValue = tThisValue
			set tValueType = $$$eConfigSettingValueTypeSystem
		}
		if $d(tAlreadyDefined(tName),tThisValue) {
			set tValue=tThisValue
			set tValueType=$$$eConfigSettingValueTypeProduction
		}
		#; Target,Name,Value,ValueType,Default,DefaultType,Description,Type,MAXLEN,MINVAL,MAXVAL,VALUELIST,DISPLAYLIST,IsRequired,LocalizedName,Category,LocalizedCategory,EditorContext
		set tData = $lb("",tName,tValue,tValueType,tDefault,tDefaultType)
		set tData = tData _ $lb($g(rs.Data("Description")))
		set tData = tData _ $lb($g(rs.Data("Type")))
		set tData = tData _ $lb($g(rs.Data("MAXLEN")))
		set tData = tData _ $lb($g(rs.Data("MINVAL")))
		set tData = tData _ $lb($g(rs.Data("MAXVAL")))
		set tData = tData _ $lb($g(rs.Data("VALUELIST")))
		set tData = tData _ $lb($g(rs.Data("DISPLAYLIST")))
		set tData = tData _ $lb($g(rs.Data("IsRequired")))
		set tData = tData _ $lb($$$GetLocalizedName(tName))
		set tGroup = $g(rs.Data("Category"))
		set tData = tData _ $lb(tGroup)
		set tData = tData _ $lb($$$GetLocalizedName(tGroup))
		set tData = tData _ $lb($g(rs.Data("EditorContext")))
		do ..VirtualSettings.Insert(tData)
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="UpdateSettings">
<Description><![CDATA[
This method updates the Settings collection with the data from <var>pArray</var>
Settings collection is cleared first, then the entries in <var>pArray</var> is used to update it.
The format of <var>pArray</var> is of the following:
pArray = total number of entries
pArray(i) = $lb(Target, Name, Value)]]></Description>
<FormalSpec>pArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	do ..Settings.Clear()
	for i=1:1:pArray {
		set tOneSetting = ##class(Ens.Config.Setting).%New()
		set tOneSetting.Target = $li(pArray(i),1)
		set tOneSetting.Name = $li(pArray(i),2)
		set tOneSetting.Value = $li(pArray(i),3)
		do ..Settings.Insert(tOneSetting)
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="CreateDocumentHTML">
<Description><![CDATA[
Create a HTML document containing the production configuration details.
The HTML document appears in InterSystems online documentation style and provide links into
the online documentation set in DOCBOOK. <br>
How to use: Invoke this method passing the production name <var>ProductionClass</var> and 
a flag <var>IncludeIntro</var> to include a terminology introduction chapter (default is true).  
The method returns a status code.
It also returns as output parameters the <var>URL</var> to display the documentation in a browser 
and the <var>LogFileName</var> to be checked in case an error occurs (if an error status code is returned). <br>
Example: <example language="cos">
  Set status = ##class(Ens.Config.Production).CreateDocumentHTML("Demo.Loan.FindRateProduction",1,.URL,.ErrLog)
</example>
Once the documentation is created, it will be available to be viewed from the Productions page
of the Ensemble Management Portal, or by pointing a browser to the returned <var>URL</var>. <br>
The document is built by applying a XSL transformation to create a document expressed as DocBook XML,
then using the InterSystems' DocBook utilities to load the book. <br>
The documentation may be removed by invoking <method>RemoveDocumentHTML</method>. <br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ProductionClass:%String,IncludeIntro:%Boolean=1,*URL:%String,*LogFileName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ##class(%SYS.Ensemble).CreateDocumentation($G(ProductionClass), IncludeIntro, "HTML", .LogFileName, .URL)
	If $G(URL)'="" {
		Set s = ##class(%RoutineMgr).GetWebServerPort(.WebPort)
		Set URL = "http://"_$system.INetInfo.HostNameToAddr($P($system,":",1))_":"_WebPort_URL
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="CreateDocumentPDF">
<Description><![CDATA[
Create a PDF file containing the production configuration details.
The generated PDF file allows customization of the cover page (logo image, company name and address) 
and of the colors used for the titles and links. <br>
How to use: Invoke this method passing the production name <var>ProductionClass</var>,  
a flag <var>IncludeIntro</var> to include a terminology introduction chapter (default is true), 
the file name <var>PDFFileName</var> on the Ensemble server where the PDF output should be written to, 
and an optional array <var>Params</var> of customization parameters in case you wish to override the defaults.<br>
You may also pass a <var>PDFRenderer</var> as an optional string containing the full pathname of the script that 
runs the FOP or RenderX (XEP) rendering engine.
If a PDF renderer is already configured for Zen, it will be used by default,
so if you wish to use it there's no need to provide it as a parameter. 
If no PDF renderer is configured for Zen, the built-in FOP renderer will be used.<br>
Examples: <example language="cos">
  Set status = ##class(Ens.Config.Production).CreateDocumentPDF("Demo.Loan.FindRateProduction",1,"C:\Temp\DemoFindRate.pdf",.ErrLog)
</example>
The example below shows how to provide a PDF renderer and custom parameters:
<example language="cos">
  Set Config("title-color") = "green"
  Set Config("href-color") = "red"
  Set Config("logo-image") = "C:\MyLogo.jpg"
  Set Config("logo-name") = "ACME Inc."
  Set Config("logo-address1") = "1 Main St"
  Set Config("logo-address2") = "1st floor"
  Set Config("logo-citystatezip") = "Anytown, USA"
  Set Config("logo-website") = "www.mywebsite.com"
  Set Production = "ACME.Test.Production"
  Set status = ##class(Ens.Config.Production).CreateDocumentPDF(Production,0,"C:\Temp\ACME.pdf",.ErrLog,"C:\fop\fop-0.95\fop.bat",.Config)
</example>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[ProductionClass:%String,IncludeIntro:%Boolean=1,&PDFFileName:%String,*LogFileName:%String,PDFRenderer:%String,&Params:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set exe = ""
	If ($G(PDFRenderer) = "") {
		If $G(^%SYS("zenreport","transformerpath"))'="" {
			Set exe=^%SYS("zenreport","transformerpath")
		} 
		ElseIf (##class(%File).Exists($$$fopbat)) {
			Set exe=$$$fopbat
		} 
		Else {
			Quit $$$ERROR($$$GeneralError,"You must set ^%SYS(""zenreport"",""transformerpath"") to the location of your PDF transformer.")
		}
	}
	Else {
		Set exe = $G(PDFRenderer)
	}
	Set tSC = ##class(%SYS.Ensemble).CreateDocumentation($G(ProductionClass), IncludeIntro, "PDF", .LogFileName, , , .PDFFileName, exe, .Params)
	Quit tSC
]]></Implementation>
</Method>

<Method name="RemoveDocumentHTML">
<Description>
Remove the HTML documentation for a given production in the current namespace.
This method may be used in case you wish to remove the HTML documentation that was created for a given production.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ProductionClass:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If $G(ProductionClass)="" Quit $$$ERROR($$$EnsErrGeneral, "A production class must be provided")
	Do ##class(Ens.Util.Documentation).BookName(ProductionClass, .BookName)
	If $G(BookName)="" Quit $$$ERROR($$$EnsErrGeneral, "Unable to get corresponding book name")
	Set tSC = $$$OK
	
	Try {
		Set Nsp = $ZU(5)
		Do $ZU(5,"DOCBOOK")
		Set tSC = ##class(DocBook.Utils).RemoveBook(BookName)
		Do $ZU(5,Nsp)
	}
	Catch {
		Do $ZU(5,Nsp)
		Set tSC = $$$SystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="CreateStudioProject">
<Description>
Create and save a studio project that contains all the detectable elements of the named Production.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pProductionName:%String="",pProjectName:%String="",*pProject:%Studio.Project</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC=$$$OK
	try {
		set tProduction = ##class(Ens.Config.Production).%OpenId(pProductionName,,.tSC)
		quit:'$IsObject(tProduction)
		set tSC=..getProjectArrayFromProduction(tProduction,.tProjectItems) quit:$$$ISERR(tSC)
		set tSC=..expandProjectArray(.tProjectItems) quit:$$$ISERR(tSC)
		set pProjectName = $s(pProjectName'="":pProjectName,1:pProductionName)
		set tDescription="Studio Project generated from Ensemble Production '"_pProductionName_"'"
		set tSC=..createStudioProjectFromArray(.pProject,.tProjectItems,pProjectName,tDescription) quit:$$$ISERR(tSC)
		set tSC=pProject.%Save()
	} catch {
		set tSC=$$$ERROR($$$GeneralError,$ze)
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="CreateStudioProjectFromConfigItem">
<Description>
Create and save a studio project that contains all the detectable elements related to the named config item</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pConfigItem:Ens.Config.Item,pProjectName:%String="",*pProject:%Studio.Project</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC=$$$OK
	try {
		set tSC=..getProjectArrayFromConfigItem(pConfigItem,.tProjectItems) quit:$$$ISERR(tSC)
		set tSC=..expandProjectArray(.tProjectItems) quit:$$$ISERR(tSC)
		set pProjectName = $s(pProjectName'="":pProjectName,1:pConfigItem.Production.Name_"-"_$TR(pConfigItem.Name,":","-"))
		set tDescription="Studio Project generated from Ensemble Production Item "_pConfigItem.Production.Name_" : "_pConfigItem.Name
		set tSC=..createStudioProjectFromArray(.pProject,.tProjectItems,pProjectName,tDescription) quit:$$$ISERR(tSC)
		set tSC=pProject.%Save()
	} catch {
		set tSC=$$$ERROR($$$GeneralError,$ze)
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="FindStudioProjectItems">
<ClassMethod>1</ClassMethod>
<FormalSpec>pProductionName:%String="",*pProjectItems</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC=$$$OK
	try {
		set tProduction = ##class(Ens.Config.Production).%OpenId(pProductionName,,.tSC) quit:'$IsObject(tProduction)
		set tSC=..getProjectArrayFromProduction(tProduction,.pProjectItems) quit:$$$ISERR(tSC)
		set tSC=..expandProjectArray(.pProjectItems) quit:$$$ISERR(tSC)
		quit
	} catch {
		set tSC=$$$ERROR($$$GeneralError,$ze)
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="createStudioProjectFromArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pProject:%Studio.Project,pProjectItems:%String,pProjectName:%String="",pDescription:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC=$$$OK
	if ##class(%Studio.Project).%ExistsId(pProjectName) quit $$$ERROR($$$GeneralError,"Project '"_pProjectName_"' already exists.")
	set pProject=##class(%Studio.Project).%New()
	if '$IsObject(pProject) quit $$$ERROR($$$GeneralError,"Failed to create project object.")
	set pProject.Name=pProjectName
	set pProject.Description=pDescription
	set name="" for  {
		set name=$o(pProjectItems("rul",name)) quit:name=""
		set name2 = ##class(Ens.Projection.Rule).ResolveRuleAlias(name)
		if name2'="" set pProjectItems("cls",name2)=""
	}
	kill pProjectItems("rul")
	set ext="" for  {
		set ext=$o(pProjectItems(ext)) quit:ext=""
		set name="" for  {
			set name=$o(pProjectItems(ext,name)) quit:name=""
			do pProject.AddItem(name_"."_ext)
		}
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="getProjectArrayFromProduction">
<ClassMethod>1</ClassMethod>
<FormalSpec>pProduction:Ens.Config.Production,*pProjectItems</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC=$$$OK
	// add production class itself
	do ..addClass(pProduction.Name,.pProjectItems)
	// call getProjectArrayFromConfigItem for each config item
	for i=1:1:pProduction.Items.Count() {
		set tOneItem = pProduction.Items.GetAt(i)
		set tSC=..getProjectArrayFromConfigItem(tOneItem,.pProjectItems) Quit:$$$ISERR(tSC)
	}
	quit:$$$ISERR(tSC) tSC
	// recursively go to subproduction
	for i=1:1:pProduction.SubProductions.Count() {
		kill tSubProjectItems
		set tSC=..getProjectArrayFromProduction(pProduction.SubProductions.GetAt(i),.tSubProjectItems) quit:$$$ISERR(tSC)
		merge pProjectItems = tSubProjectItems
	}
	// all done
	quit tSC
]]></Implementation>
</Method>

<Method name="getProjectArrayFromConfigItem">
<ClassMethod>1</ClassMethod>
<FormalSpec>pConfigItem:Ens.Config.Item,*pProjectItems</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC=$$$OK
	// add all host and adapter classnames of each config item, and all the rules used by HL7 message routers 
	do ..addClass(pConfigItem.ClassName,.pProjectItems)
	do ..addClass(pConfigItem.AdapterClassName(),.pProjectItems)
	// get routine rule names
	if $classmethod(pConfigItem.ClassName,"%IsA","EnsLib.MsgRouter.RoutingEngine") {
		do pConfigItem.PopulateModifiedSettings()
		for j=1:1:pConfigItem.ModifiedSettings.Count() {
			if pConfigItem.ModifiedSettings.GetAt(j).Name="BusinessRuleName" {
				set tRuleName = pConfigItem.ModifiedSettings.GetAt(j).Value
				if tRuleName'="" set tRoutingRules(tRuleName)=""
			}
		}
	}
	// find customer schemas
	do ..getItemSchema(pConfigItem,.pProjectItems)
	// merge rule data into pProjectItems
	merge pProjectItems("rul")=tRoutingRules
	// all done
	quit tSC
]]></Implementation>
</Method>

<Method name="expandProjectArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>pProjectItems:%String,pExistingClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// include all auxiliary items
	Set tSC=..expandProjectArrayAuxiliary(.pProjectItems,.pExistingClasses)  Quit:$$$ISERR(tSC)
	// find all the predecessor classes
	do ..getDependentPredecessor(.pProjectItems,.tNewItems,.pExistingClasses)
	if $d(tNewItems)=0 quit $$$OK
	// recursively expand the additional classes
	Set tSC=..expandProjectArray(.tNewItems,.pExistingClasses) Quit:$$$ISERR(tSC)
	merge pProjectItems=tNewItems
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="expandProjectArrayAuxiliary">
<Description>
expandProjectArrayAuxiliary merges all the classes in pProjectItems into pExistingClasses before starting
it also updates pExistingClasses with all the new classes it added before exiting</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pProjectItems:%String,pExistingClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	merge pExistingClasses("cls")=pProjectItems("cls")
	merge tRoutingRules=pProjectItems("rul")
	// recursively, find out all the delegated rules used by the routing rules, also find all the transformations
	for  {
		kill tNewRules
		do ..getRoutingRuleDelegatesAndTransformations(.tRoutingRules,.tNewRules,.tTransforms)
		set tAddedNewRules=0
		set rule="" for  {
			set rule=$o(tNewRules(rule)) quit:rule=""
			if $d(tRoutingRules(rule))=0 set tRoutingRules(rule)="",tAddedNewRules=1
		}
		if tAddedNewRules=0 quit
	}
	// find all the <rule> tags used in BPL
	set tClass="" for  {
		set tClass=$o(pProjectItems("cls",tClass)) quit:tClass=""
		kill tResults
		do ..findClassXDATATagAttributeValue(tClass,"BPL","rule","rule",.tResults)
		for i=1:1:tResults {
			set tOneResult=tResults(i)
			if tOneResult'="",$e(tOneResult)'="@" set:tOneResult'["." tOneResult=tClass_"."_tOneResult set tRules(tOneResult)=""
		}
	}
	// find all the <transform> tags used in BPL
	set tClass="" for  {
		set tClass=$o(pProjectItems("cls",tClass)) quit:tClass=""
		kill tResults
		do ..findClassXDATATagAttributeValue(tClass,"BPL","transform","class",.tResults)
		for i=1:1:tResults {
			set tOneResult=tResults(i)
			if tOneResult'="",$e(tOneResult)'="@" set tTransforms(tOneResult)=""
		}
	}
	// recursively, find out all the sub-transform used by any DTL's
	for  {
		kill tNewTransforms
		do ..getSubTransformations(.tTransforms,.tNewTransforms)
		if $d(tNewTransforms)=0 quit
		merge tTransforms=tNewTransforms
	}
	// find all source and target classes used by DTL
	set tClass="" for  {
		set tClass=$o(tTransforms(tClass)) quit:tClass=""
		kill tResults
		do ..findClassXDATATagAttributeValue(tClass,"DTL","transform","sourceClass",.tResults)
		for i=1:1:tResults if tResults(i)'="",$e(tResults(i))'="@" do ..addClass(tResults(i),.pProjectItems,.pExistingClasses)
		kill tResults
		do ..findClassXDATATagAttributeValue(tClass,"DTL","transform","targetClass",.tResults)
		for i=1:1:tResults if tResults(i)'="",$e(tResults(i))'="@" do ..addClass(tResults(i),.pProjectItems,.pExistingClasses)
	}
	// find schemas used by all DTL's
	do ..getDTLSchemas(.tTransforms,.tSchemas)
	// find all FunctionSet subclass used by DTL and Rules
	if $d(tTransforms)||$d(tRoutingRules)||$d(tRules) {
		set tRS = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
		if $IsObject(tRS) {
			do tRS.%Execute("Ens.Rule.FunctionSet")
			while (tRS.%Next(.tSC)) {
				do ..addClass($g(tRS.Data("Name")),.pProjectItems,.pExistingClasses)
			}
		}
	}
	// merge DTL's into classes
	merge pProjectItems("cls")=tTransforms
	// scan all the methods to find all the other classes they reference to
	// TODO
	// any include files used by the classes
	set class="" for  {
		set class=$o(pProjectItems("cls",class)) quit:class=""
		set file="" for  {
			set file=$$$comClassArrayNext(class,$$$cCLASSincludecodeall,file) q:file=""
			if (file'="")&&($e(file)'="%")&&($e(file,1,3)'="Ens") set tItem("inc",file)=""
		}
	}
	// construct pProjectItems
	merge pExistingClasses("cls")=pProjectItems("cls")
	merge pProjectItems("rul")=tRoutingRules
	merge pProjectItems("rul")=tRules
	merge pProjectItems=tSchemas
	// all done
	quit $$$OK
]]></Implementation>
</Method>

<Method name="addClass">
<ClassMethod>1</ClassMethod>
<FormalSpec>class,pNewClasses,pExistingList</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		if class="" { quit } // the class name is empty
		if $d(pExistingList("cls",class)) { quit } // we already have this class
		if $e(class,1)="%" { quit } // the class name starts with "%"
		
		// Find out if the class is mapped from a system namespace
		set tLocation = $ZCVT(##class(%SYS.Namespace).GetRoutineDest($NAMESPACE, class _ ".0", "OBJ"),"U")
		Set tMgr = $SYSTEM.Util.ManagerDirectory()
		if (tLocation = ("^" _ $ZCVT(##class(%File).SubDirectoryName(tMgr, "ENSLIB", 1),"U"))) { quit }
		if (tLocation = ("^" _ $ZCVT(##class(%File).SubDirectoryName(tMgr, "HSLIB", 1),"U"))) { quit }
		if (tLocation = ("^" _ $ZCVT(##class(%File).SubDirectoryName(tMgr, "CACHELIB", 1),"U"))) { quit }
		if (tLocation = ("^" _ $ZCVT(##class(%File).SubDirectoryName(tMgr, "CACHESYS", 1),"U"))) { quit }
		
		// Include the class in the list
		set pNewClasses("cls",class)=""
	} 
	catch {
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="getItemSchema">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pItem:Ens.Config.Item,&pSchemas]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap"
	Set tDocClass=$$$GetClassParameter(pItem.ClassName,"DOCCLASS")
	If ##class(%Dictionary.CompiledClass).%ExistsId(tDocClass) {
		If pItem.GetSetting($S($classmethod(tDocClass,"%Extends","EnsLib.HL7.Message"):"MessageSchemaCategory",1:"DocSchemaCategory"),.tValue) {
			Set nc=$L(tValue,",") For i=1:1:nc { Set tDocType=$P(tValue,",",i)  Continue:""=tDocType
				Set:tDocType["=" tDocType=$P(tDocType,"=",2)
				Do ..addSchema(tDocClass,$P(tDocType,":"),.pSchemas)
			}
		}
	}
Trap
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getDTLSchemas">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&tTransforms,&pSchemas]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set class="" for  { set class=$o(tTransforms(class))  quit:class=""
		try {
			do ..addSchema($zobjclassmethod(class,"GetSourceType"),$p($zobjclassmethod(class,"GetSourceDocType"),":",1),.pSchemas)
			do ..addSchema($zobjclassmethod(class,"GetTargetType"),$p($zobjclassmethod(class,"GetTargetDocType"),":",1),.pSchemas)
		}
		catch(ex) {
		}
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="addSchema">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pType,pName,&pSchemas]]></FormalSpec>
<Implementation><![CDATA[
	Quit:""=pName
	Try {
		Set tRS = ##class(%ResultSet).%New("Ens.VDoc.Utils:EnumerateVDocSchemas")  Quit:'$IsObject(tRS) 
		Set tSC = tRS.Execute(pType,"+")  Quit:$$$ISERR(tSC) 
		While (tRS.Next(.tSC)) {
			Set cat = $G(tRS.Data("Category"))
			Set ext = $G(tRS.Data("SchemaDocExt"))
			If ((""'=cat)&&(""'=ext))&&(pName=cat) Set pSchemas($ZCVT(ext,"L"),pName)=""  Quit
		} Do tRS.Close()
	}
	Catch {
	}
]]></Implementation>
</Method>

<Method name="getDependentPredecessor">
<ClassMethod>1</ClassMethod>
<FormalSpec>pClasses,pNewClasses,pExistingClasses</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set class="" for  {
		set class=$o(pClasses("cls",class)) quit:class=""
		#; add super classes
		set superclasses=$$$comClassKeyGet(class,$$$cCLASSsuper)
		for i=1:1:$l(superclasses,",") do ..addClass($p(superclasses,",",1),.pNewClasses,.pExistingClasses)
		#; add property types classes
		set property="" for  {
			set property=$$$comMemberNext(class,$$$cCLASSproperty,property) quit:property=""
			do ..addClass($$$comMemberKeyGet(class,$$$cCLASSproperty,property,$$$cPROPtype),.pNewClasses,.pExistingClasses)
		}
		#; add method signature classes
		set method="" for  {
			set method=$$$comMemberNext(class,$$$cCLASSmethod,method) quit:method=""
			if $$$comMemberKeyGet(class,$$$cCLASSmethod,method,$$$cMETHstub)'="" {
				set stub=$$$comMemberKeyGet(class,$$$cCLASSmethod,method,$$$cMETHstub)
				set elem=$p(stub,".",1),meth=$p(stub,".",2),kind=$p(stub,".",3)
				set return=$$$comSubMemberKeyGet(class,kind,elem,$$$cCLASSmethod,meth,$$$cMETHreturntype)
				set formal=$$$comSubMemberKeyGet(class,kind,elem,$$$cCLASSmethod,meth,$$$cMETHformalspecparsed)
			} else {
				set return=$$$comMemberKeyGet(class,$$$cCLASSmethod,method,$$$cMETHreturntype)
				set formal=$$$comMemberKeyGet(class,$$$cCLASSmethod,method,$$$cMETHformalspecparsed)
			}
			do ..addClass(return,.pNewClasses,.pExistingClasses)
			for i=1:1:$ll(formal) do ..addClass($li($li(formal,i),2),.pNewClasses,.pExistingClasses)
		}
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="getRoutingRuleDelegatesAndTransformations">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRules,pNewRules,pTransformations</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC=$$$OK
	set rule="" for  {
		set rule = $o(pRules(rule)) quit:rule=""
		set ruleClass = ##class(Ens.Projection.Rule).ResolveRuleAlias(rule)
		set tSC=##class(Ens.Rule.Generator).correlateByName(ruleClass,.ruleModel) quit:$$$ISERR(tSC)
		for rc=1:1:ruleModel.ruleSets.Count() {
			set ruleSet = ruleModel.ruleSets.GetAt(rc)
			for ac=1:1:ruleSet.actions.Count() {
				set action = ruleSet.actions.GetAt(ac)
				set tSC = ..getActionDelegateTransform(action,.pNewRules,.pTransformations) quit:$$$ISERR(tSC)
			}
		}
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="getActionDelegateTransform">
<ClassMethod>1</ClassMethod>
<FormalSpec>pAction:Ens.Rule.Model.action,pNewRules,pTransformations</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC=$$$OK
	if ( pAction.type = "rule" ) {
		for wc=1:1:pAction.whens.Count() {
			set whens = pAction.whens.GetAt(wc)
			for ac = 1:1:whens.actions.Count() {
				set action = whens.actions.GetAt(ac)
				set tSC = ..getActionDelegateTransform(action,.pNewRules,.pTransformations) quit:$$$ISERR(tSC)
			}
		}
		if $isObject(pAction.otherwise) {
			for ac = 1:1:pAction.otherwise.actions.Count() {
				set action = pAction.otherwise.actions.GetAt(ac)
				set tSC = ..getActionDelegateTransform(action,.pNewRules,.pTransformations) quit:$$$ISERR(tSC)
			}
		}
	} elseif ( pAction.type = "send" ) {
		if pAction.transform'="" {
			for tc=1:1:$l(pAction.transform,",") {
				set tTransform = $zstrip($p(pAction.transform,",",tc),"<>W")
				set:(tTransform'="") pTransformations(tTransform)=""
			}
		}
	} elseif ( pAction.type = "delegate" ) {
		if pAction.ruleName'="" {
			set pNewRules(pAction.ruleName)=""
		}
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="findClassXDATATagAttributeValue">
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassname,pXDATAname,pTagname,pAttributename,pResults</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC=$$$OK
	do {
		set pResults=0
		// Get a stream of XML from the ExampleXML block contained in this class
		set tXDATAobj=##class(%Dictionary.CompiledXData).%OpenId(pClassname_"||"_pXDATAname)
		if '$IsObject(tXDATAobj) Quit
		set tStream=tXDATAobj.Data
		if '$IsObject(tStream) Set tSC=%objlasterror Quit
		// Create an XPATH Document instance from the stream of XML
		set tSC=##class(%XML.XPATH.Document).CreateFromStream(tStream,.tDocument)
		if $$$ISERR(tSC) quit
		// Search the document
		set tSC=tDocument.EvaluateExpression("//"_pTagname,".",.tDOMResults)
		if $$$ISERR(tSC) quit
		// loop through the results and find the attribute values
		for tI=1:1:tDOMResults.Count() {
			set tDOMResult=tDOMResults.GetAt(tI)
			while tDOMResult.Read() {
				for tJ=1:1:tDOMResult.AttributeCount {
					do tDOMResult.MoveToAttributeIndex(tJ)
					if tDOMResult.Name=pAttributename set pResults($i(pResults))=tDOMResult.Value
				}
			}
		}
	} while (0)
	quit tSC
]]></Implementation>
</Method>

<Method name="getSubTransformations">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTransforms,pNewTransforms</FormalSpec>
<Implementation><![CDATA[
	set tClass="" for  {
		set tClass=$o(pTransforms(tClass)) quit:tClass=""
		kill tResults
		do ..findClassXDATATagAttributeValue(tClass,"DTL","subtransform","class",.tResults)
		for i=1:1:tResults {
			set tOneResult=tResults(i)
			if tOneResult'="",$d(pTransforms(tOneResult))=0 set pNewTransforms(tOneResult)=""
		}
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="Checksum">
<Description>
Checksum used in updating production.</Description>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tValue=..ActorPoolSize_..TestingEnabled_..LogGeneralTraceEvents
	Set tIndex="" For { Set tIndex = ..ModifiedSettings.Next(tIndex)  Quit:tIndex=""
		Set tSetting = ..ModifiedSettings.GetAt(tIndex)
		Set tValue=tValue_tSetting.Target_tSetting.Name_tSetting.Value
	}
	Quit $zcrc(tValue,7)
]]></Implementation>
</Method>

<Method name="SetModified">
<Description><![CDATA[
Wrapper method to ensure that we only increment the production modification
counter when <var>pProduction</var> is currently running in this namespace.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pProduction:%String=""</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tOldValue = 0
	If (pProduction '= "") && ..%ExistsId(pProduction) && ##class(Ens.Director).IsProductionRunning(.tRunningProduction) && (pProduction = tRunningProduction) {
		#; Increment counter and set old value to 1 less than that
		Set tOldValue = $$$EnsProdModCounterIncAndGet
	}
	Quit tOldValue
]]></Implementation>
</Method>

<Trigger name="OnChange">
<Description>
Ensure we update the modified flag after SQL changes.</Description>
<Code>	If ({Name} '= "") {
		Do ##class(Ens.Config.Production).SetModified({Name})
	}</Code>
<Event>INSERT/UPDATE/DELETE</Event>
<Time>AFTER</Time>
</Trigger>

<Query name="Extent">
<Description>
This is a system provided query that provides a result set containing every 
instance within this extent.</Description>
<Type>%ExtentSQLQuery</Type>
<SqlProc>1</SqlProc>
<Parameter name="CONTAINID" value="1"/>
</Query>

<Method name="GetRuntimePortsArray">
<Description>
Get an array of all ports in use by the running Production.
Value = config id|code|agentInterface
Code "o" = TCP Outbound (in listen mode), "i" = TCP Inbound, "L" = Agent Listener Relay port, "C" = Agent Connect Relay port</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pArray]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	/*
	/// Find all normal config ports
	Set tHost="" For { Set tHost=$O($$$ConfigRoot(tHost))  Quit:""=tHost
		Set tPort=$G($$$ConfigSetting(tHost,"Adapter","Port"))
		Continue:"@"=$E(tPort)
		Set tIPAddress=$G($$$ConfigSetting(tHost,"Adapter","IPAddress"))
		Continue:"@"=$E(tIPAddress)

		If ("!"=$E(tIPAddress)) { ; connect-out mode
			Set:""'=tPort pArray(tPort)=tHost_"|o"
		} ElseIf ""=tIPAddress { ; inbound
			Set:""'=tPort&&("!"'=$E($G($$$ConfigSetting(tHost,"Adapter","AllowedIPAddresses")))) pArray(tPort)=tHost_"|i" ; normal listen-for-connection mode
		}
	}
	/// Find all Agent relay ports
	&sql(DECLARE A1 CURSOR FOR
		SELECT %ID,Type,RelayPort,ConfigItem INTO :tID,:tType,:tRelayPort,:tItem FROM EnsLib_Agent.Interface)
	&sql(OPEN A1) For { &sql(FETCH A1)  Quit:SQLCODE
		Set:""'=tRelayPort pArray(tRelayPort)=tItem_$S(tType="TCP_Listen":"|L|",1:"|C|")_tID
	} Set tCode=SQLCODE &sql(CLOSE A1) Set:'SQLCODE SQLCODE=tCode

	Quit:SQLCODE'=100&&SQLCODE $$$ERROR($$$EnsErrGeneral,"SQLCODE error scanning Agent ports:"_SQLCODE)
	*/
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Ens.Config.ProductionD</DataLocation>
<DefaultData>ProductionDefaultData</DefaultData>
<IdLocation>^Ens.Config.ProductionD</IdLocation>
<IndexLocation>^Ens.Config.ProductionI</IndexLocation>
<StreamLocation>^Ens.Config.ProductionS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="ProductionDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ActorPoolSize</Value>
</Value>
<Value name="3">
<Value>Description</Value>
</Value>
<Value name="4">
<Value>Items</Value>
</Value>
<Value name="5">
<Value>LogGeneralTraceEvents</Value>
</Value>
<Value name="6">
<Value>TestingEnabled</Value>
</Value>
<Value name="7">
<Value>Settings</Value>
</Value>
<Value name="8">
<Value>SubProductions</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Ens.Config.Setting">
<ClassType>serial</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>%SerialObject,%XML.Adaptor</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59508,73016.819746</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="XMLIGNORENULL">
<Default>1</Default>
</Parameter>

<Property name="Target">
<Type>%String</Type>
<InitialExpression>"Adapter"</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Name">
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Value">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
<Parameter name="XMLPROJECTION" value="CONTENT"/>
</Property>

<Method name="ValueSet">
<FormalSpec>initval</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%Value=$ZSTrip(initval,"<>WC")
	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<State>SettingState</State>
<StreamLocation>^Ens.Conf.SettingS</StreamLocation>
<Data name="SettingState">
<Structure>listnode</Structure>
<Subscript>"Ens.Config.Setting"</Subscript>
<Value name="1">
<Value>Name</Value>
</Value>
<Value name="2">
<Value>Target</Value>
</Value>
<Value name="3">
<Value>Value</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Ens.DataTransform">
<Description>
This class provides the framework for encoding a series of operations which transform
a specified input type to a specfied output type</Description>
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>Ensemble</IncludeCode>
<IncludeGenerator>Ensemble</IncludeGenerator>
<ProcedureBlock>1</ProcedureBlock>
<Super>%RegisteredObject,Ens.Util.FunctionSet</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59309,65317.672</TimeCreated>
<Inheritance>right</Inheritance>

<Method name="GetSourceType">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<GenerateAfter>Transform</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	do {
		#; Find the first arg type of the Transform method for the current subclass
		Set tIndex = %compiledclass.Methods.FindObjectId(%class.Name_"||Transform")
		Set tFormalSpec = %compiledclass.Methods.GetAt(tIndex).FormalSpec
		Do %code.WriteLine(" Quit """_$P($P(tFormalSpec,",",1),":",2)_"""")
	} while (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$ERROR($$$CacheError,$ZE)
	Goto Exit
]]></Implementation>
</Method>

<Method name="GetSourceDocType">
<Description>
Return the virtual document type of the source document.
This is used by the Test Transform dialog to determine whether
the initial document should have a DocType assigned.
A return value of the empty string (i.e. "") indicates no DocType should be used.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ""
]]></Implementation>
</Method>

<Method name="GetTargetType">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>*pCreate:%String</FormalSpec>
<GenerateAfter>Transform</GenerateAfter>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	do {
		#; Find the second arg type of the Transform method for the current subclass
		Set tIndex = %compiledclass.Methods.FindObjectId(%class.Name_"||Transform")
		Set tFormalSpec = %compiledclass.Methods.GetAt(tIndex).FormalSpec
		Do %code.WriteLine(" Set pCreate=""""")
		Do %code.WriteLine(" Quit """_$P($P(tFormalSpec,",",2),":",2)_"""")
	} while (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$ERROR($$$CacheError,$ZE)
	Goto Exit
]]></Implementation>
</Method>

<Method name="GetTargetDocType">
<Description>
Return the virtual document type of the target document.
This is used by the Test Transform dialog to determine whether
the document produced by the transform should have a DocType assigned.
A return value of the empty string (i.e. "") indicates no DocType should be used.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ""
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[/* TransformMulti() removed - use multiple DTLs with create=existing option */
]]></Content>
</UDLText>

<Method name="Transform">
<Description>
Transform an input object into an output object</Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[source:%RegisteredObject,&target:%RegisteredObject,&aux]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	do {
		$$$ASSERT("0:Subclass Responsibility")
		Set tSC = $$$EnsError($$$EnsErrNotImplemented,$$$CurrentClass,$$$CurrentMethod)
} while (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="instantiateProps">
<Description>
Instantiates intermediate objects, collections and collection elements on the pVarName path, but does not do collection elements at the final level. Use Action=insert for that.
Note: uses parallel construction to Ens.BPL.Transform.isProperty(); depends on pVarName having passed that test first.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTopObj:%RegisteredObject,pVarName:%String,pVarArgs...</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set numd=$L(pVarName,".")  Quit:numd<2 1
	// Shortcut for standard properties to see whether we can avoid work for previously swizzled properties
	If ('$data(pVarArgs)) && (pVarName=$TR(pVarName,"()")) && (numd > 2) {
		Set tSwizzled = 0
		Try {
			New %EnsTmpObj,%EnsIsObj
			Set %EnsTmpObj = pTopObj
			Set %EnsIsObj = 0
			Xecute "Set %EnsIsObj = $IsObject(%EnsTmpObj."_$P(pVarName,".",2,numd-1)_")"
			Set tSwizzled = $get(%EnsIsObj,0)
		}
		Catch {
			Set tSwizzled = 0
		}
		If tSwizzled Quit 1
	}
	#; loop over dot pieces
	Set $ZT="TrapIP", (dot,qc,pc,tLevel,iArgs)=0, pp=""
	#; variable names:d= dot piece index, dp= dot piece, q= quote piece index, qp= quote piece, qc= quote count, pp= parens piece, pc= parens count
	For d=1:1:numd { Set dp=$P(pVarName,".",d)
		#; remove delimited name if dot piece starts and ends with "
		If ($extract(dp,1) = """") && ($extract(dp,*) = """") Set dp = $extract(dp,2,*-1)
		#; loop over quote pieces
		Set numq=$L(dp,""""), qc=qc-1
		For q=1:1:numq { Set qp=$P(dp,"""",q)  Set qc=qc+1
			If qc#2=0 {
				#; if not inside quotes, abort if fragment contains non-identifier or non-array characters
				//If $E(qp,2,*)["%" || (qp'=$TR(qp,"^+-='_*/\#$&|,![]{}")) Set qc=-1  Quit
				#; quit if last piece
				If d=numd&&(q=numq) Set qc=-2  Quit
				Set:pc pp=pp_$S(d>1&&(q=1):".",1:"")_$S(q>1:"""",1:"")_qp
				If qp'=$TR(qp,"()") {
					#; has parens; balance them
					Set:'pc pd=d
					Set pc=pc+($L(qp)-$L($TR(qp,"(")))-($L(qp)-$L($TR(qp,")")))
					If pc<0 { Set qc=-1  Quit }
					ElseIf pc=0 {
						Set pp=pp_$S(d>pd&&(q=1):".",1:"")_$S(q>1:"""",1:"")_qp
						new %val
						Set %val=tObj
						Set tFunc=$P(pp,"("), tArgs=$E(pp,$L(tFunc)+1,*)
						If ""=tFunc { Set tFunc=$Case(tArgs,"()":"Append","(-)":"GetPrevious("""")",:"GetAt")  Set:"GetAt"=tFunc iArgs=iArgs+1  Set pp=tFunc_$S("(-)"=tArgs:"", $D(pVarArgs(iArgs))#2:"("_pVarArgs(iArgs)_")", 1:tArgs) }
						ElseIf "()"'=tArgs { Set iArgs=iArgs+1  Set:$D(pVarArgs(iArgs))#2 pp=tFunc_"("_pVarArgs(iArgs)_")" }
						If "Append"'=tFunc { Xecute "Set %val=%val."_pp }
						Else { Set %val=$$$NULLOREF }
						If '$IsObject(%val) {
							#; note: No GetPrevious("") support here; it should have been Xecuted successfully already; if not it will trap out
							If $Case(tFunc,"GetAt":0, "Append":0, :1)  Set qc=-1  Quit ; Not a GetAt() or Append() collection accessor
							#; Get key and set new element at that key
							If "()"=tArgs { Set %val="" }
							Else {
								If $D(pVarArgs(iArgs))#2 { Set %val=pVarArgs(iArgs) }
								Else { Xecute "Set %val="_tArgs }
							}
							Set tElem=$zobjclassmethod(tObj.ElementType,"%New")
							If tObj.%Extends("%Collection.AbstractListOfObj") {
								Do $Case(tArgs,"()":tObj.Insert(tElem), :tObj.InsertAt(tElem,%val))
							} Else {
								Do tObj.SetAt(tElem,%val)
							}
							Set %val=tElem
						}
						Set tObj=%val  Kill %val
						Set pp=""
					}
				} Else {
					If 0=tLevel { Set tObj=pTopObj }
					Else {
						Set tVal=$zobjproperty(tObj,qp)
						Set:$$$NULLOREF=tVal tVal=$zobjmethod(tObj,qp_"NewObject")
						Set tObj=tVal
					}
				}
				Set tLevel=tLevel+1
			}
			If pc { Set pp=pp_$S(d>pd&&(q=1):".",1:"")_$S(q>1:"""",1:"")_qp }
		}
		Quit:qc<0
		Set:qc#2=0&&(d<numd) dot=1
	}
	Quit:qc#2 0 ; unbalanced quotes -or- not a simple property
	#; w "numd=",numd,", numq=",numq,", dp=",dp,", qp=",qp,", qc=",qc#2,",",qc,", d=",d,", q=",q,!
	Quit dot ; found dot not quoted
TrapIP
	Quit 0 ; exception - unable to instantiate all
]]></Implementation>
</Method>
</Class>


<Class name="Ens.DataTransformDTL">
<Description>
This class provides the framework for defining a data transformation by encoding the 
operations in the data transform language (DTL)</Description>
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>Ensemble,EnsCompiler</IncludeCode>
<IncludeGenerator>Ensemble,EnsCompiler</IncludeGenerator>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.DataTransform</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59309,65317.687</TimeCreated>

<Parameter name="REPORTERRORS">
<Description>
Override this parameter to 1 in your DTL subclass to make it log and return all errors encountered
while executing the transform. When this parameter is set to 0 the DTL will silently
log them as Trace messages with category 'xform'.</Description>
<Type>%Boolean</Type>
<Default>0</Default>
</Parameter>

<Parameter name="IGNOREMISSINGSOURCE">
<Description>
Override this parameter to 1 in your DTL subclass to make it ignore errors resulting from an attempt
to use a value from a source property or virtual property that does not exist in the provided source object</Description>
<Type>%Boolean</Type>
<Default>0</Default>
</Parameter>

<Parameter name="TREATEMPTYREPEATINGFIELDASNULL">
<Description>
Override this parameter to 1 in your DTL subclass to prevent 'for each' loops from being implemented when 
the property to iterate over is a repeating field and that field is empty</Description>
<Type>%Boolean</Type>
<Default>0</Default>
</Parameter>

<Method name="GetSourceType">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	do {
		#; Don't run this method on the base class
		If %compiledclass.Name="Ens.DataTransformDTL" Quit
		
		#; Find XDATA block named DTL
		Set tIndex = %compiledclass.XDatas.FindObjectId(%class.Name_"||DTL")
		If tIndex="" {
			Set tSC=$$$ERROR($$$EnsErrXDataBlockNotDefined,%class.Name,"DTL")
			Quit
		}
		
		#; Get XDATA as a stream
		Set tStream = %compiledclass.XDatas.GetAt(tIndex).Data
		Do tStream.Rewind()
	
		Set tSC=##class(Ens.DTL.Compiler).ParseStream(.tTransform,tStream)
		If $$$ISERR(tSC) Quit
		
		Set %code.Language=$Case(tTransform.Language,$$$objectscript:"cache",$$$basic:"basic")
		
		If tTransform.Language=$$$basic {
			Do %code.WriteLine(" Return """_tTransform.SourceClass_"""")
		} else {
			Do %code.WriteLine(" Quit """_tTransform.SourceClass_"""")
		}
		
	} while (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$ERROR($$$CacheError,$ZE)
	Goto Exit
]]></Implementation>
</Method>

<Method name="GetSourceDocType">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	do {
		#; Don't run this method on the base class
		If %compiledclass.Name="Ens.DataTransformDTL" Quit
		
		#; Find XDATA block named DTL
		Set tIndex = %compiledclass.XDatas.FindObjectId(%class.Name_"||DTL")
		If tIndex="" {
			Set tSC=$$$ERROR($$$EnsErrXDataBlockNotDefined,%class.Name,"DTL")
			Quit
		}
		
		#; Get XDATA as a stream
		Set tStream = %compiledclass.XDatas.GetAt(tIndex).Data
		Do tStream.Rewind()
	
		Set tSC=##class(Ens.DTL.Compiler).ParseStream(.tTransform,tStream)
		If $$$ISERR(tSC) Quit
		
		Set %code.Language=$Case(tTransform.Language,$$$objectscript:"cache",$$$basic:"basic")
		
		If tTransform.Language=$$$basic {
			Do %code.WriteLine(" Return """_tTransform.SourceDocType_"""")
		} else {
			Do %code.WriteLine(" Quit """_tTransform.SourceDocType_"""")
		}
		
	} while (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$ERROR($$$CacheError,$ZE)
	Goto Exit
]]></Implementation>
</Method>

<Method name="GetTargetType">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>*pCreate:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	do {
		#; Don't run this method on the base class
		If %compiledclass.Name="Ens.DataTransformDTL" Quit
		
		#; Find XDATA block named DTL
		Set tIndex = %compiledclass.XDatas.FindObjectId(%class.Name_"||DTL")
		If tIndex="" {
			Set tSC=$$$ERROR($$$EnsErrXDataBlockNotDefined,%class.Name,"DTL")
			Quit
		}
		
		#; Get XDATA as a stream
		Set tStream = %compiledclass.XDatas.GetAt(tIndex).Data
		Do tStream.Rewind()
	
		Set tSC=##class(Ens.DTL.Compiler).ParseStream(.tTransform,tStream)
		If $$$ISERR(tSC) Quit
		
		Set %code.Language=$Case(tTransform.Language,$$$objectscript:"cache",$$$basic:"basic")
		
		If tTransform.Language=$$$objectscript {
			Do %code.WriteLine(" Set pCreate="""_tTransform.Create_"""")
			Do %code.WriteLine(" Quit """_tTransform.TargetClass_"""")
		} Else {
			Do %code.WriteLine(" pCreate="""_tTransform.Create_"""")
			Do %code.WriteLine(" Return """_tTransform.TargetClass_"""")
		}
	} while (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$ERROR($$$CacheError,$ZE)
	Goto Exit
]]></Implementation>
</Method>

<Method name="GetTargetDocType">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	do {
		#; Don't run this method on the base class
		If %compiledclass.Name="Ens.DataTransformDTL" Quit
		
		#; Find XDATA block named DTL
		Set tIndex = %compiledclass.XDatas.FindObjectId(%class.Name_"||DTL")
		If tIndex="" {
			Set tSC=$$$ERROR($$$EnsErrXDataBlockNotDefined,%class.Name,"DTL")
			Quit
		}
		
		#; Get XDATA as a stream
		Set tStream = %compiledclass.XDatas.GetAt(tIndex).Data
		Do tStream.Rewind()
	
		Set tSC=##class(Ens.DTL.Compiler).ParseStream(.tTransform,tStream)
		If $$$ISERR(tSC) Quit
		
		Set %code.Language=$Case(tTransform.Language,$$$objectscript:"cache",$$$basic:"basic")
		
		If tTransform.Language=$$$objectscript {
			Do %code.WriteLine(" Quit """_tTransform.TargetDocType_"""")
		} else {
			Do %code.WriteLine(" Return """_tTransform.TargetDocType_"""")
		}
		
	} while (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$ERROR($$$CacheError,$ZE)
	Goto Exit
]]></Implementation>
</Method>

<Method name="Transform">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[source:%RegisteredObject,&target:%RegisteredObject,&aux=""]]></FormalSpec>
<PublicList>process,context</PublicList>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	do {
		#; Don't run this method on the base class
		If %compiledclass.Name="Ens.DataTransformDTL" Quit
		
		#; Find XDATA block named DTL
		Set tIndex = %compiledclass.XDatas.FindObjectId(%class.Name_"||DTL")
		If tIndex="" {
			Set tSC=$$$ERROR($$$EnsErrXDataBlockNotDefined,"DTL",%class.Name)
			Quit
		}
		
		#; Get XDATA as a stream
		Set tStream = %compiledclass.XDatas.GetAt(tIndex).Data
		Do tStream.Rewind()
	
		Set tSC=##class(Ens.DTL.Compiler).CompileStream(tStream,%class,%code)
		
	} while (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$ERROR($$$CacheError,$ZE)
	Goto Exit
]]></Implementation>
</Method>
</Class>


<Class name="Ens.DataType.ConfigName">
<Description>
Datatype for a config name (i.e. a configuration or class name)</Description>
<Super>%String</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>60562,37292.609</TimeCreated>

<Parameter name="MAXLEN">
<Description>
The maximum number of characters a classname can contain.</Description>
<Default>128</Default>
</Parameter>

<Method name="ParseConfigNameSpec">
<Description>
Parse a config name spec using the specified delimiter and quote mark.  Returns the results byref in pResults
which contains each individual configname indexed in the order of appearance.  Returns $$$OK on success, or
an error if the spec string had problems (such as unbalanced quotes).</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pSpec:%String,pSeparator:%String,&pResults,pQuote:%String="""",pStrip:%Boolean=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status = $$$OK
	Set $ZT="Trap"
	Do {
		#dim tIndex  As %Integer
		#dim tDelim  As %Integer
		#dim tStart  As %Integer
		#dim tLength As %Integer
		#dim tQuote  As %Integer
		#dim tQuote2 As %Integer
		#dim tName   As %String
	
		Kill pResults
	
		Set (tStart,tIndex)=1
		Set tLength=$LENGTH(pSpec)
	
		While (tIndex'>tLength) {
		
			// Look for both the delimiter and the quote mark and take
			// whichever is first.
			
			If $L(pSeparator) {
				Set tDelim = $FIND(pSpec, pSeparator, tIndex)
				Set tDelim = $CASE(tDelim,0:tLength,:tDelim-($L(pSeparator)+1))
			} Else {
				// No separator allowed
				Set tDelim = tLength
			}
		
			If $L(pQuote) {
				Set tQuote = $FIND(pSpec, pQuote, tIndex)
				Set tQuote = $CASE(tQuote,0:0,:tQuote-$L(pQuote))
			} Else {
				// No quote allowed
				Set tQuote = 0
			}
		
			If tQuote,tQuote'>tDelim {
				// If we found a quote and it is before (or at) the delimiter, then
				// we need to find the closing quote ignoring any further delimiters
				// until we see that quote.  Note that we may encounter doubled 
				// quotes which we should handle.
			
				Set tQuote2 = tQuote + $L(pQuote)
				For {
					Set tQuote2 = $FIND(pSpec, pQuote, tQuote2)
					If 'tQuote2 {
						// We haven't found a closing quote ... error!
						Set tSC = $$$ERROR($$$UnbalancedQuotes)
						Quit
					}

					// We must advance tIndex to cover what we've scanned so far
					Set tIndex = tQuote2
				
					// Quit if there's not another quote immediately following this one
					If $FIND(pSpec, pQuote, tIndex) '= (tIndex + $L(pQuote)) Quit
				}
				
				// If we encountered an error, quit out
				If $$$ISERR(tSC) Quit
			
				// At this point, tIndex either points to the end of the string (i.e.
				// we're done) or just beyond the last quote.  At this point
				// we can go back to looking for a delimiter
				If tIndex<tLength Continue
				
				// Note, reset tDelim to point at the end of the string ...
				Set tDelim = tLength

			} Else {
				// No quote, use the delimiter
			}
			
			// Extract and strip leading and trailing whitespace (if requested)
			Set tName = $E(pSpec, tStart, tDelim)
			Set:pStrip tName = $ZSTRIP(tName,"<>W")
		
			// Store the result (don't bother with empty strings)
			If tName'="" {
				Set pResults($I(pResults)) = tName
			}
			
			// Move to the next element
			Set (tStart,tIndex) = tDelim + $L(pSeparator) + 1
		}
		
	} While (0)
Exit
	Quit tSC
Trap
	Set tSC=$$$ERROR($$$CacheError,$ZE)
	Goto Exit
]]></Implementation>
</Method>
</Class>


<Class name="Ens.DataType.MessagePriority">
<Description>
Encapsulate a MessageHeader type value
value = 3 is no longer in use. It was used for Normal pripority in the past, and is only defined here for displaying older messages.</Description>
<ClassType>datatype</ClassType>
<IncludeCode>Ensemble</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Integer</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59269,35355.671</TimeCreated>

<Parameter name="DISPLAYLIST">
<Default>,HighSync,Sync,Normal,SimSync,Async</Default>
</Parameter>

<Parameter name="VALUELIST">
<Default>,1,2,3,4,6</Default>
</Parameter>
</Class>


<Class name="Ens.DataType.MessageStatus">
<Description>
Encapsulate a Priority value</Description>
<ClassType>datatype</ClassType>
<IncludeCode>Ensemble</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Integer</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59269,35355.671</TimeCreated>

<Parameter name="DISPLAYLIST">
<Default>,Created,Queued,Delivered,Discarded,Suspended,Deferred,Aborted,Error,Completed</Default>
</Parameter>

<Parameter name="VALUELIST">
<Default>,1,2,3,4,5,6,7,8,9</Default>
</Parameter>
</Class>


<Class name="Ens.DataType.RunStatus">
<Description>
Encapsulate a RunStatus value</Description>
<ClassType>datatype</ClassType>
<IncludeCode>Ensemble</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Integer</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59270,25904.029</TimeCreated>

<Parameter name="DISPLAYLIST">
<Default>,Ready,Completed,Waiting,Errored</Default>
</Parameter>

<Parameter name="VALUELIST">
<Default>,1,2,3,4</Default>
</Parameter>
</Class>


<Class name="Ens.DataType.UTC">
<ClassType>datatype</ClassType>
<ClientDataType>TIMESTAMP</ClientDataType>
<IncludeCode>Ensemble</IncludeCode>
<OdbcType>TIMESTAMP</OdbcType>
<ProcedureBlock>1</ProcedureBlock>
<SqlCategory>TIMESTAMP</SqlCategory>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59493,78734.915003</TimeCreated>

<Method name="LogicalToDisplay">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>%val:%TimeStamp</FormalSpec>
<ReturnType>%TimeStamp</ReturnType>
<Implementation><![CDATA[$s(%val="":"",1:$$$timeUTCHtoUTC($zdTH($$$timeUTCtoUTCH(%val),-3)))
]]></Implementation>
</Method>

<Method name="LogicalToOdbc">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>%val:%TimeStamp</FormalSpec>
<ReturnType>%TimeStamp</ReturnType>
<Implementation><![CDATA[$s(%val="":"",1:$$$timeUTCHtoUTC($zdTH($$$timeUTCtoUTCH(%val),-3)))
]]></Implementation>
</Method>

<Method name="OdbcToLogical">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>%val:%TimeStamp</FormalSpec>
<ReturnType>%TimeStamp</ReturnType>
<Implementation><![CDATA[$s(%val="":"",1:$$$timeUTCHtoUTC($zdT($$$timeUTCtoUTCH(%val),-3)))
]]></Implementation>
</Method>

<Method name="DisplayToLogical">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>%val:%TimeStamp</FormalSpec>
<ReturnType>%TimeStamp</ReturnType>
<Implementation><![CDATA[$s(%val="":"",1:$$$timeUTCHtoUTC($zdT($$$timeUTCtoUTCH(%val),-3)))
]]></Implementation>
</Method>

<Method name="timeUTCtoUTCH">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>%utc:%TimeStamp</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$timeUTCtoUTCH(%utc)
]]></Implementation>
</Method>

<Method name="timeUTCHtoUTC">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>%utch:%String</FormalSpec>
<ReturnType>%TimeStamp</ReturnType>
<Implementation><![CDATA[$$$timeUTCHtoUTC(%utch)
]]></Implementation>
</Method>

<Method name="timeUTC">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%TimeStamp</ReturnType>
<Implementation><![CDATA[$$$timeUTC
]]></Implementation>
</Method>

<Method name="timeUTCH">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$timeUTCH
]]></Implementation>
</Method>

<Method name="timeLocal">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%TimeStamp</ReturnType>
<Implementation><![CDATA[$$$timeLocal
]]></Implementation>
</Method>

<Method name="timeUTCtoLocal">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>%utc:%TimeStamp</FormalSpec>
<ReturnType>%TimeStamp</ReturnType>
<Implementation><![CDATA[$$$timeUTCtoLocal(%utc)
]]></Implementation>
</Method>

<Method name="timeLocaltoUTC">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>%utc:%TimeStamp</FormalSpec>
<ReturnType>%TimeStamp</ReturnType>
<Implementation><![CDATA[$$$timeLocaltoUTC(%utc)
]]></Implementation>
</Method>

<Method name="timeCmp">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>%t2:%TimeStamp,%t1:%TimeStamp</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[$$$timeCmp(%t2,%t1)
]]></Implementation>
</Method>

<Method name="timeDiff">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>%t2:%TimeStamp,%t1:%TimeStamp</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[$$$timeDiff(%t2,%t1)
]]></Implementation>
</Method>

<Method name="Normalize">
<Description>
Strip off trailing zeros and trailing dot for normalized form</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>%val:%CacheString</FormalSpec>
<ReturnType>%TimeStamp</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	if $p(%val,":",3)'["." quit %val
	for i=1:1:3 quit:$e(%val,*)'="0"  set %val=$e(%val,1,*-1)
	if $e(%val,*)="." set %val=$e(%val,1,*-1)
	quit %val
]]></Implementation>
</Method>

<Method name="StorageToLogical">
<ClassMethod>1</ClassMethod>
<FormalSpec>%val:%TimeStamp</FormalSpec>
<ReturnType>%TimeStamp</ReturnType>
<Implementation><![CDATA[	quit ..Normalize(%val)
]]></Implementation>
</Method>
</Class>


<Class name="Ens.Host">
<Description>
Common base class for all Ensemble config item instances</Description>
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>Ensemble</IncludeCode>
<IncludeGenerator>Ensemble</IncludeGenerator>
<ProcedureBlock>1</ProcedureBlock>
<Super>%RegisteredObject</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59266,28403.249</TimeCreated>

<Parameter name="INVOCATION">
<Description>
2 modes: Queue, InProc</Description>
<Default>Queue</Default>
</Parameter>

<Property name="ThrottleDelay">
<Description>
Duration of forced idleness before processing the next message, in milliseconds</Description>
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="AlertOnError">
<Description>
Send an Alert message whenever an error occurs here</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="InactivityTimeout">
<Description><![CDATA[
Send an Alert message if this number of seconds elapses with no messages being processed by this item. <br/>
Note that this alert will be sent even if AlertOnError is False. <br/>
Zero means no alerts of this type will be sent.]]></Description>
<Type>%Numeric</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="BusinessPartner">
<Description>
Name of a Business Partner Profile associated with this item</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
</Property>

<Property name="AlertGroups">
<Description>
The Alert Groups to which this item belongs.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="2500"/>
</Property>

<Parameter name="SETTINGS">
<Description>
Users can specify these values in the Ensemble Configuration Editor</Description>
<Type>%String</Type>
<Default><![CDATA[ThrottleDelay,AlertOnError:Alerting,InactivityTimeout:Alerting,BusinessPartner:Info:partnerSelector,AlertGroups:Alerting:selector?multiSelect=1&context={Ens.ContextSearch/ProductionAlertGroups?productionName=@productionId}]]></Default>
</Parameter>

<Property name="%QuitTask">
<Description>
Flag for returning an error that will exit the OnTask() loop and terminate the Job</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="%SessionId">
<Description>
The session id of the current message being processed</Description>
<Type>%Integer</Type>
</Property>

<Property name="%LastHandledTime">
<Description>
If doing keepalives, the time of the last return from MessageHeaderHandler()</Description>
<Type>%String</Type>
<Transient>1</Transient>
</Property>

<Property name="%LastActionTime">
<Description>
If doing keepalives, the time of the last return from MessageHeaderHandler() or OnKeepalive()</Description>
<Type>%String</Type>
<Transient>1</Transient>
</Property>

<Property name="%LastReportedError">
<Description>
Copy of the text of the last error we reported, so we can avoid alerting more than once</Description>
<Type>%String</Type>
<Transient>1</Transient>
</Property>

<Property name="%WarnedLatest">
<Description>
Flag whether we have already warned about the class being recompiled</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Transient>1</Transient>
</Property>

<Property name="%isShadow">
<Description>
Is this a real live instance or a shadow instance used just to hold config settings.</Description>
<Type>%String</Type>
<Transient>1</Transient>
</Property>

<Property name="%SuperSession">
<Description>
The SuperSession id of the current message being processed</Description>
<Type>%String</Type>
</Property>

<Method name="SendRequestSync">
<FormalSpec><![CDATA[pTargetDispatchName:%String,pRequest:%Library.Persistent,&pResponse:%Library.Persistent,pTimeout:%Numeric=-1,pDescription:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$EnsError($$$NotImplemented)
]]></Implementation>
</Method>

<Method name="SendRequestSyncMultiple">
<Description>
Use this method to dispatch multiple Ensemble business invocation synchronously</Description>
<Internal>1</Internal>
<FormalSpec>pCallStructList:%String,pTimeout:%Numeric=-1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC=$$$OK, pResponse=$$$NULLOREF
	try {
		for i=1:1:pCallStructList {
			set tCallStruct=pCallStructList(i)
			set tTargetDispatchName=tCallStruct.TargetDispatchName
			set tTargetConfigName=$get($$$DispatchNameToConfigName(tTargetDispatchName))
			if tTargetConfigName="" set tSC=$$$EnsError($$$EnsErrBusinessDispatchNameNotRegistered,tTargetDispatchName) quit
			set tTargetBusinessClass = $$$ConfigClassName(tTargetConfigName)
			set tINVOCATION=$classmethod(tTargetBusinessClass,"%GetParameter","INVOCATION")
			if (tINVOCATION'="Queue")&&(tINVOCATION'="InProc") set tSC=$$$ERROR($$$EnsErrParameterInvocationInvalid,tTargetBusinessClass) quit
			;
			set tArray(i,"TargetConfigName") = tTargetConfigName
			set tArray(i,"TargetBusinessClass") = tTargetBusinessClass
			set tArray(i,"INVOCATION")=tINVOCATION
		}
		quit:$$$ISERR(tSC)
		;
		set tStartTime=$zh,tRespondedCount=0
		set:pTimeout'=-1 tEndTime=$zh+pTimeout
		for i=1:1:pCallStructList {
			if tArray(i,"INVOCATION")="InProc" {
				set tTimeout=$s(pTimeout=-1:-1,1:tEndTime-$zh)
				if (pTimeout'=-1)&&(tTimeout<0) quit
				set tSC=..SendRequestSync(tArray(i,"TargetConfigName"),pCallStructList(i).Request,.tResponse,tTimeout,pCallStructList(i).Description)
				set pCallStructList(i).Response=tResponse
				set tRespondedCount=tRespondedCount+1
			} elseif tArray(i,"INVOCATION")="Queue" {
				Set tSessionId=..%SessionId
				Set tSuperSession = ..%SuperSession
				Set tSC = ##class(Ens.MessageHeader).NewRequestMessage(.tRequestHeader,pCallStructList(i).Request,.tSessionId,.tSuperSession) quit:$$$ISERR(tSC)
				Set ..%SessionId=tSessionId
				Set ..%SuperSession=tSuperSession
				set tArray(i,"RequestHeader")=tRequestHeader
				Set tRequestIndex(tRequestHeader.MessageId()) = i
				Set tRequestHeader.SourceConfigName = ..%ConfigName
				Set tRequestHeader.TargetConfigName = tArray(i,"TargetConfigName")
				Set tRequestHeader.SourceBusinessType = $$$ConfigBusinessType($$$DispatchNameToConfigName(..%ConfigName))
				Set tRequestHeader.TargetBusinessType = $$$ConfigBusinessType($$$DispatchNameToConfigName(tArray(i,"TargetConfigName")))
				Set tRequestHeader.TargetQueueName = $$$getConfigQueueName($$$DispatchNameToConfigName(tArray(i,"TargetConfigName")),..%SessionId)
				Set tRequestHeader.ReturnQueueName = $$$queueSyncCallQueueName
				Set tRequestHeader.BusinessProcessId = ""
				Set tRequestHeader.Priority = $$$eMessagePrioritySync
				Set tRequestHeader.Description = pCallStructList(i).Description
				Set tSC = ##class(Ens.Queue).Create($$$queueSyncCallQueueName) quit:$$$ISERR(tSC)
				Set tSC = ##class(Ens.Queue).EnQueue(tRequestHeader) quit:$$$ISERR(tSC)
			}
			quit:$$$ISERR(tSC)
		}
		quit:$$$ISERR(tSC)
		;
		while tRespondedCount<pCallStructList {
			set tTimeout=$s(pTimeout=-1:-1,1:tEndTime-$zh) if (pTimeout'=-1)&&(tTimeout<0) quit
			set tSC = ##class(Ens.Queue).DeQueue($$$queueSyncCallQueueName,.tResponseHeader,tTimeout,.tIsTimedOut,0) Quit:$$$ISERR(tSC)
			quit:tIsTimedOut 
			continue:$IsObject(tResponseHeader)=0
			set tFound = $select(tResponseHeader.CorrespondingMessageId: $get(tRequestIndex(tResponseHeader.CorrespondingMessageId),0), 1: 0)
			if tFound=0 {
				$$$sysTRACE("Out-of-band message '"_tResponseHeader.%Id()_"' discarded")
				do tResponseHeader.SetStatus($$$eMessageStatusDiscarded)
				continue
			}
			if tResponseHeader.IsError {
				set pCallStructList(tFound).ResponseCode=tResponseHeader.ErrorStatus
				set tRespondedCount=tRespondedCount+1
				do tResponseHeader.SetStatus($$$eMessageStatusCompleted)
				continue
			}
			if tResponseHeader.MessageBodyClassName'="" {
				set tResponse = $classmethod(tResponseHeader.MessageBodyClassName,"%OpenId",tResponseHeader.MessageBodyId,,.tSC)
				if '$IsObject(tResponse) Set tSC=$$$EnsError($$$EnsErrGeneral,"Could not open MessageBody "_tResponseHeader.MessageBodyId_" for MessageHeader #"_tResponseHeader.%Id()_" with body class "_tResponseHeader.MessageBodyClassName_":"_$$$StatusDisplayString(tSC))  Quit
			} else {
				set tResponse=$$$NULLOREF
			}
			set pCallStructList(tFound).Response=tResponse
			set tRespondedCount=tRespondedCount+1
			do tResponseHeader.SetStatus($$$eMessageStatusCompleted)
			continue
		}
		Set tSC2 = ##class(Ens.Queue).Delete($$$queueSyncCallQueueName,"*") quit:$$$ISERR(tSC2)
		;
		$$$catTRACE("timing","duration of sync call: "_($zh-tStartTime))
		quit
	}
	catch {
		set tSC = $$$EnsSystemError
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="acceptRequestSync">
<Description>
This method is for internal use.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec><![CDATA[pSourceConfigName:%String,pTargetConfigName:%String,pRequest:%Library.Persistent,&pResponse:%Library.Persistent,&pSessionId:%String,pTimeout:%Numeric,&pRequestHeader:Ens.MessageHeader,pDescription:%String="",&pSuperSession:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set invocation=%parameter("INVOCATION")
	If ( invocation="Queue" ) {
		$$$GENERATE(" Quit ..queueRequestSync(pSourceConfigName,pTargetConfigName,pRequest,.pResponse,.pSessionId,pTimeout,.pRequestHeader,pDescription,.pSuperSession)")
	} Elseif invocation="InProc" {
		$$$GENERATE(" Quit ..inprocRequest(pSourceConfigName,pTargetConfigName,pRequest,.pResponse,"""",.pSessionId,"""",.pRequestHeader,pDescription,,.pSuperSession)")
	} Else {
		Quit $$$ERROR($$$EnsErrParameterInvocationInvalid,%class)
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="acceptRequestAsync">
<Description>
This method is for internal use.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec><![CDATA[pSourceConfigName:%String,pTargetConfigName:%String,pRequest:Request,pPriority:Ens.DataType.MessagePriority,pReturnQueueName:%String,&pSessionId:%String,pBusinessProcessId:%String,&pRequestHeader:Ens.MessageHeader,pDescription:%String="",&pSuperSession:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set invocation=%parameter("INVOCATION")
	If ( invocation="Queue" ) {
		$$$GENERATE(" Quit ..queueRequestAsync(pSourceConfigName,pTargetConfigName,pRequest,.pPriority,.pReturnQueueName,.pSessionId,pBusinessProcessId,.pRequestHeader,pDescription,.pSuperSession)")
	} Elseif invocation="InProc" {
		$$$GENERATE(" Quit ..inprocRequest(pSourceConfigName,pTargetConfigName,pRequest,,.pReturnQueueName,.pSessionId,pBusinessProcessId,.pRequestHeader,pDescription,pPriority,.pSuperSession)")
	} Else {
		Quit $$$ERROR($$$EnsErrParameterInvocationInvalid,%class)
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="queueRequestAsync">
<Description>
This method is for internal use.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pSourceConfigName:%String,pTargetConfigName:%String,pRequest:Request,pPriority:Ens.DataType.MessagePriority,pReturnQueueName:%String,&pSessionId:%String,pBusinessProcessId:%String,*pRequestHeader:Ens.MessageHeader,pDescription:%String="",&pSuperSession:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap", tSC=$$$OK
	Do {
		Set tSC = ##class(Ens.MessageHeader).NewRequestMessage(.pRequestHeader,pRequest,.pSessionId,.pSuperSession) Quit:$$$ISERR(tSC)
		Set pRequestHeader.SourceConfigName = pSourceConfigName
		Set pRequestHeader.TargetConfigName = pTargetConfigName
		Set pRequestHeader.SourceBusinessType = $$$ConfigBusinessType($$$DispatchNameToConfigName(pSourceConfigName))
		Set pRequestHeader.TargetBusinessType = $$$ConfigBusinessType($$$DispatchNameToConfigName(pTargetConfigName))
		Set pRequestHeader.TargetQueueName = $$$getConfigQueueName($$$DispatchNameToConfigName(pTargetConfigName),pSessionId)
		Set pRequestHeader.ReturnQueueName = pReturnQueueName
		Set pRequestHeader.BusinessProcessId = pBusinessProcessId
		Set pRequestHeader.Description = pDescription
		Set pRequestHeader.Priority = pPriority

		Set tSC = ##class(Ens.Queue).EnQueue(pRequestHeader) Quit:$$$ISERR(tSC)
	} While 0
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="queueRequestSync">
<Description>
This method is for internal use.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pSourceConfigName:%String,pTargetConfigName:%String,pRequest:%Library.Persistent,&pResponse:%Library.Persistent,&pSessionId:%String,pTimeout:%Numeric,*pRequestHeader:Ens.MessageHeader,pDescription:%String="",&pSuperSession:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap", tSC=$$$OK, pResponse=$$$NULLOREF
	Do {
		Set tSC = ##class(Ens.MessageHeader).NewRequestMessage(.pRequestHeader,pRequest,.pSessionId,.pSuperSession)
		If $$$ISOK(tSC) {
			Set pRequestHeader.SourceConfigName = pSourceConfigName
			Set pRequestHeader.TargetConfigName = pTargetConfigName
			Set pRequestHeader.SourceBusinessType = $$$ConfigBusinessType($$$DispatchNameToConfigName(pSourceConfigName))
			Set pRequestHeader.TargetBusinessType = $$$ConfigBusinessType($$$DispatchNameToConfigName(pTargetConfigName))
			Set pRequestHeader.TargetQueueName = $$$getConfigQueueName($$$DispatchNameToConfigName(pTargetConfigName),pSessionId)
			Set pRequestHeader.ReturnQueueName = $$$queueSyncCallQueueName
			Set pRequestHeader.BusinessProcessId = ""
			Set pRequestHeader.Priority = $$$eMessagePrioritySync
			Set pRequestHeader.Description = pDescription

			Set tSC = ##class(Ens.Queue).Create($$$queueSyncCallQueueName)
			If $$$ISOK(tSC) {
				Set tSC = ##class(Ens.Queue).EnQueue(pRequestHeader)
				If $$$ISERR(tSC) {
					Set tSC2 = ##class(Ens.Queue).Delete($$$queueSyncCallQueueName,"*")
					If $$$ISERR(tSC2) Set tSC = $$$ADDSC(tSC,tSC2)
					Quit
				}
			} Else {
				Quit
			}
		} Else {
			Quit	
		}
		While 1 {
			Set tSC = ##class(Ens.Queue).DeQueue($$$queueSyncCallQueueName,.tResponseHeader,pTimeout,.tIsTimedOut,0) Quit:$$$ISERR(tSC)
			Quit:tIsTimedOut 
			Continue:$IsObject(tResponseHeader)=0
			If tResponseHeader.CorrespondingMessageId=pRequestHeader.%Id() {
				If tResponseHeader.IsError {
					Set tSC=tResponseHeader.ErrorStatus
					Do tResponseHeader.SetStatus($$$eMessageStatusCompleted)
					Quit
				}
				If tResponseHeader.MessageBodyClassName'="" {
					Set pResponse = $classmethod(tResponseHeader.MessageBodyClassName,"%OpenId",tResponseHeader.MessageBodyId,,.tSC)
					If '$IsObject(pResponse) Set tSC=$$$EnsError($$$EnsErrGeneral,"Could not open MessageBody "_tResponseHeader.MessageBodyId_" for MessageHeader #"_tResponseHeader.%Id()_" with body class "_tResponseHeader.MessageBodyClassName_":"_$$$StatusDisplayString(tSC)) Quit
				}
				Do tResponseHeader.SetStatus($$$eMessageStatusCompleted)
				Quit
			}
			$$$sysTRACE("Out-of-band message '"_tResponseHeader.%Id()_"' discarded")
			Do tResponseHeader.SetStatus($$$eMessageStatusDiscarded)
		}
		Set tSC2 = ##class(Ens.Queue).Delete($$$queueSyncCallQueueName,"*")  Quit:$$$ISERR(tSC2)
	} While 0
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="inprocRequest">
<Description>
This method is for internal use.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pSourceConfigName:%String,pTargetConfigName:%String,pRequest:%Library.Persistent,&pResponse:%Library.Persistent,pReturnQueueName:%String,&pSessionId:%String,pBusinessProcessId:%String,&pRequestHeader:Ens.MessageHeader,pDescription:%String="",pPriority:Ens.DataType.MessagePriority=$$$eMessagePrioritySync,&pSuperSession:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap", tSC=$$$OK, pResponse=$$$NULLOREF
	Do {
		Set tSC=..findCachedObject(pTargetConfigName,.tInstance) Quit:$$$ISERR(tSC)
		$$$ASSERT($IsObject(tInstance))
		
		If $G($$$EnsInProcPersist,1) {
			Set tSC = ##class(Ens.MessageHeader).NewRequestMessage(.pRequestHeader,pRequest,.pSessionId,.pSuperSession) Quit:$$$ISERR(tSC)
			Set pRequestHeader.SourceConfigName = pSourceConfigName
			Set pRequestHeader.TargetConfigName = pTargetConfigName
			Set pRequestHeader.SourceBusinessType = $$$ConfigBusinessType($$$DispatchNameToConfigName(pSourceConfigName))
			Set pRequestHeader.TargetBusinessType = $$$ConfigBusinessType($$$DispatchNameToConfigName(pTargetConfigName))
			Set pRequestHeader.TargetQueueName = ""
			Set pRequestHeader.ReturnQueueName = pReturnQueueName
			Set pRequestHeader.BusinessProcessId = pBusinessProcessId
			Set pRequestHeader.Priority = pPriority
			Set pRequestHeader.Invocation = $$$eMessageInvocationInProc
			Set pRequestHeader.Description = pDescription

			Set tSC=pRequestHeader.%Save() If $$$ISERR(tSC) $$$LOGSTATUS(tSC) Quit
			Set tSC = tInstance.MessageHeaderHandler(pRequestHeader,.tResponseHeader) Quit:$$$ISERR(tSC)
			If $IsObject(tResponseHeader) {
				If tResponseHeader.TargetQueueName'="" {
					Set tSC = ##class(Ens.Queue).EnQueue(tResponseHeader) Quit:$$$ISERR(tSC)
				} Else {
					Set tSC=tResponseHeader.%Save()  If $$$ISERR(tSC) $$$LOGSTATUS(tSC) Quit
					If tResponseHeader.MessageBodyClassName'="" {
						Set pResponse = $classmethod(tResponseHeader.MessageBodyClassName,"%OpenId",tResponseHeader.MessageBodyId,,.tSC)
						If '$IsObject(pResponse) Set tSC=$$$EnsError($$$EnsErrGeneral,"Could not open MessageBody "_tResponseHeader.MessageBodyId_" for MessageHeader #"_tResponseHeader.%Id()_" with body class "_tResponseHeader.MessageBodyClassName_":"_$$$StatusDisplayString(tSC))  Quit
					}
					Do tResponseHeader.SetStatus($$$eMessageStatusCompleted)
				}
			} Else {
				Set pResponse=$$$NULLOREF
			}
		} Else {
			Set tSC = tInstance.OnMessage(pRequest, .pResponse)
			$$$IncHostCounterTime(pTargetConfigName)
		}
	} While 0
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="findCachedObject">
<Description>
This method is for internal use.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTargetConfigName:%String,*pInstance:Ens.Host</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	Do {
		Set pInstance=$g($$$staticCachedObject(pTargetConfigName))
		Set pChecksum=$g($$$staticCachedChecksum(pTargetConfigName))
		If $IsObject(pInstance),pChecksum=$$$ConfigChecksum($$$DispatchNameToConfigName(pTargetConfigName)) Quit
		Set pInstance=..%New($$$DispatchNameToConfigName(pTargetConfigName))
		Set pChecksum=$$$ConfigChecksum($$$DispatchNameToConfigName(pTargetConfigName))
		$$$ASSERT($IsObject(pInstance))
		Set $$$staticCachedObject(pTargetConfigName)=pInstance
		Set $$$staticCachedChecksum(pTargetConfigName)=pChecksum
	} While 0
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="%OnNew">
<Description>
initialize Business Host object</Description>
<FormalSpec>pConfigName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $method($this,"initConfig",.pConfigName) ; call subclass
]]></Implementation>
</Method>

<Method name="initConfig">
<Description>
initialize Business Host object</Description>
<Internal>1</Internal>
<FormalSpec>pConfigName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	Do {
		Set ..%ConfigName = pConfigName
		Set ..%ConfigQueueName = $G($$$ConfigQueueName(pConfigName))
		If ..#ADAPTER'="" {
			Set ..Adapter = $classmethod(..#ADAPTER,"%New")
			Set ..Adapter.BusinessHost = $this
		}
		If ..Adapter'=$$$NULLOREF {
			Set tSettingName="" For { Set tSettingName=$O($$$ConfigSetting(pConfigName,"Adapter",tSettingName))  Quit:""=tSettingName
				Set tValue=$$$ConfigSetting(pConfigName,"Adapter",tSettingName)
				Do ..Adapter.AssignOneSetting(tSettingName,tValue,pConfigName)
			}
		}
		Set tSettingName="" For { Set tSettingName=$O($$$ConfigSetting(pConfigName,"Host",tSettingName))  Quit:""=tSettingName
			Set tValue=$$$ConfigSetting(pConfigName,"Host",tSettingName)
			Do $this.AssignOneSetting(tSettingName,tValue,pConfigName)
		}
	} While 0
	Set ..%isShadow=$G(%DoShadowNew)||'$D($$$ConfigOnTaskClassName(pConfigName))
	Quit:$$$ISERR(tSC)||..%isShadow tSC ; no OnInit() for Shadow instances
	Set tSC = ..OnInit() Quit:$$$ISERR(tSC) tSC
	If $IsObject(..Adapter) Set tSC = ..Adapter.OnInit() Quit:$$$ISERR(tSC) tSC
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="%OnClose">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If '..%isShadow {
		Set tNS=$Namespace  ZN ..%OriginalNamespace()
		If $IsObject(..Adapter) Set tSC = ..Adapter.OnTearDown() Quit:$$$ISERR(tSC) tSC
		Set tSC = ..OnTearDown() Quit:$$$ISERR(tSC) tSC
		ZN tNS
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnInit">
<Description>
This user callback method is called via initConfig() from %OnNew() or in the case of SOAP Services from OnPreSOAP()</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnTearDown">
<Description>
This user callback method is called from %OnClose()</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnProductionStart">
<Description>
This user callback method is called when the system is being started</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pConfigName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnProductionStop">
<Description>
This user callback method is called when the system is being stopped</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pConfigName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnMonitor">
<Description><![CDATA[
This user callback method is called by the Ensemble Monitor Service
(<class>Ens.MonitorService</class>) immediately after it has checked
on the status of this host class.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pHostName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnTask">
<Description>
Event loop for Actor and BusinessOperation.
This is called only when INVOCATION is Queue.</Description>
<Internal>1</Internal>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	Do {
		If '..%WarnedLatest&&'..%ClassIsLatestVersion() {
			$$$LOGWARNING("Host Class "_$classname()_" has been recompiled; continuing to run using code from previous version")
			Set ..%WarnedLatest=1
		}
		If $IsObject(..Adapter)&&'..Adapter.%WarnedLatest&&'..Adapter.%ClassIsLatestVersion() {
			$$$LOGWARNING("Adapter Class "_$classname(..Adapter)_" has been recompiled; continuing to run using code from previous version")
			Set ..Adapter.%WarnedLatest=1
		}
		If ..ThrottleDelay>0 {
			Set tRemaining=..ThrottleDelay/1000, t0=$ZH, tSBQ=0
			$$$catTRACE("ontask","hanging for "_(..ThrottleDelay/1000)_" ThrottleDelay seconds")
			While tRemaining>0&&'tSBQ {
				If tRemaining<5 { Hang tRemaining  Set tRemaining=0 }
				Else {
					Hang 5  Set tNow=$ZH, tRemaining = t0+tRemaining-tNow, t0=tNow
					Set tSBQ=##class(Ens.Job).ShouldBeQuiescent()
				}
			}
		}
		#; Calculate keepalive wait time
		If $IsObject(..Adapter) {
			Set tWait=..Adapter.KeepaliveInterval
			If tWait>0 {
				Set:..%LastActionTime tNow=$ZH, tWait=$S(tNow-..%LastActionTime>=tWait:0, 1:tWait-(tNow-..%LastActionTime))
			} Else { Set tWait=-1 }
		} Else { Set tWait=-1 }
		Set tSC = ##class(Ens.Queue).DeQueue(..QueueName(),.tRequestHeader,tWait,.tTimedOut,1) Quit:$$$ISERR(tSC)
		If '$IsObject(tRequestHeader) {
			If tWait>=0&&tTimedOut {
				Set $EC="" try {
					Set tSC=..Adapter.OnKeepalive()
				} catch {
					Set tSC=$$$ADDSC(tSC,$$$SystemError)
				}
				If $TLevel>0 Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found after Adapter.OnKeepalive(); committing before proceeding")
				Set ..%LastActionTime=$ZH
				If $$$ISERR(tSC) $$$LOGWARNING("OnKeepalive() returned "_$$$StatusDisplayString(tSC)) Set tSC=$$$OK
			}
			Quit
		}
		Set tSC=..MessageHeaderHandler(tRequestHeader,.tResponseHeader)
		Set:tWait>=0 tNow=$ZH, ..%LastActionTime=tNow, ..%LastHandledTime=tNow
		If $$$ISERR(tSC),tRequestHeader.ReturnQueueName'="" {
			Set tSC = tRequestHeader.NewErrorResponse(.tResponseHeader,tSC) Quit:$$$ISERR(tSC)
		} Else { Set tSC=$$$OK } ; we don't pass on user errors here.
		If $IsObject($G(tResponseHeader)),tResponseHeader.TargetQueueName'="" {
			Set tSC = ##class(Ens.Queue).EnQueue(tResponseHeader) Quit:$$$ISERR(tSC)
		}
	} While 0
Exit
	Kill $$$EnsActiveMessage($$$SystemName_":"_$Job)
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="OnKeepalive">
<Description>
This method will be called within KeepaliveInterval of the last return from OnTask() or OnKeepalive().
It is called via the Adapter's OnKeepalive() method, which is called from the Host.OnTask() method;
if there is no Adapter there is no keepalive call.</Description>
<FormalSpec>pAdapterStatus:%Status</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit pAdapterStatus
]]></Implementation>
</Method>

<Method name="GetDeferredResponseToken">
<FormalSpec>pMessageHeader:Ens.MessageHeader</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit pMessageHeader.%Id()_"|"_$$$EnsRuntime("Name")
]]></Implementation>
</Method>

<Method name="SendDeferredResponse">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDeferredResponseToken:%String,pResponse:%Library.Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Try {
		Set tMessageHeaderId=$p(pDeferredResponseToken,"|",1)
		Set tProductionName=$p(pDeferredResponseToken,"|",2)
		Set tCurrentProduction=$g($$$EnsRuntime("Name")) 
		If (tCurrentProduction = "") || '##class(Ens.Director).IsProductionRunning() {
			Set tSC=$$$EnsError($$$EnsErrProductionNotRunning)
			Quit
		}
		If (tProductionName '= tCurrentProduction) {
			Set tSC=$$$EnsError($$$EnsErrProductionMismatchInDeferredResponse)
			Quit
		}
		Set tRequestHeader=##Class(Ens.MessageHeader).%OpenId(tMessageHeaderId,,.tSC) Quit:$$$ISERR(tSC)
		$$$ASSERT($IsObject(tRequestHeader))
		If ""=tRequestHeader.ReturnQueueName {
			$$$LOGWARNING("No Return Queue - Unable to send deferred Response to Request "_tRequestHeader.%Id())
		} Else {
			Set tSC = tRequestHeader.NewResponseMessage(.tResponseHeader,pResponse) Quit:$$$ISERR(tSC)
			$$$sysTRACE("Sending deferred Response "_tResponseHeader.MessageId()_" to Request "_tRequestHeader.%Id())
			Set tSC = ##class(Ens.Queue).EnQueue(tResponseHeader) Quit:$$$ISERR(tSC)
		}
		Do tRequestHeader.SetStatus($$$eMessageStatusCompleted)
	}
	Catch {
		Set tSC=$$$EnsSystemError
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="MessageHeaderHandler">
<Internal>1</Internal>
<FormalSpec>pRequestHeader:Ens.MessageHeader,*pResponseHeader:Ens.MessageHeader</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; subclass responsibility
	Quit $$$ERROR($$$NotImplemented)
]]></Implementation>
</Method>

<Method name="QueueName">
<CodeMode>generator</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set invocation=%parameter("INVOCATION")
	If ( invocation="Queue" ) {
		$$$GENERATE(" Quit ..%ConfigQueueName")
	} Elseif invocation="InProc" {
		$$$GENERATE(" Quit ..%ConfigQueueName_"":""_$Job")
	} Else {
		Quit $$$ERROR($$$EnsErrParameterInvocationInvalid,%class)
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Parameter name="ADAPTER">
<Description>
The type of adapter used to communicate with external systems</Description>
</Parameter>

<Property name="Adapter">
<Description>
The adapter instance</Description>
<Type>Ens.Adapter</Type>
</Property>

<Method name="AdapterName">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..#ADAPTER
]]></Implementation>
</Method>

<Property name="%ConfigQueueName">
<Description>
return the name of queue as returned by the config item</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
</Property>

<Property name="%ConfigName">
<Description>
return the name of config item</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
</Property>

<Method name="GetShadowInstance">
<Description>
Get a "shadow" instance of the named ConfigItem, live if the Production is running; otherwise static but fully populated with all its Settings values.
See method Ens.Director:ParseConfigName() for full syntax of the ConfigItem name specification string.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pConfigItemName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>Ens.Host</ReturnType>
<Implementation><![CDATA[
	Set pStatus=$$$OK, tHost=$$$NULLOREF, $ZT="NewTrap"
	Do ##class(Ens.Director).ParseConfigItemName(pConfigItemName,.tProductionName,.tItemName,.tCommentOrClass)
 	If $Case($ZCVT($ZStrip(tProductionName,"*W"),"L"),"class":1,"":1,:0)&&(""=tCommentOrClass) {
		#; No Production; try opening Raw class
		Set tSC=$$$OK, %DoShadowNew=1
		Set tHost=$classmethod(tItemName,"%New",0)
NewContinue
		Kill %DoShadowNew
		If '$IsObject(tHost) Set pStatus=$$$ERROR($$$EnsErrGeneral,"Unable to instantiate class '"_tItemName_'":"_$$$StatusDisplayString(tSC))
		Quit tHost
	}
	If ""'=$G($$$EnsRuntime("Name"))&&(tProductionName'=$$$EnsRuntime("Name")) Set pStatus=$$$ERROR($$$EnsErrGeneral,"Cannot get instance of item "_pConfigItemName_" while production "_$$$EnsRuntime("Name")_" is running")  Quit $$$NULLOREF

	Lock +$$$ConfigRoot(tItemName)
	#; If running production, get the running item
	If $D($$$ConfigRoot(tItemName)) {
		Set %DoShadowNew=1
		Set pStatus=$classmethod($$$ConfigClassName(tItemName),"findCachedObject",tItemName,.tHost)
		Kill %DoShadowNew
		Lock -$$$ConfigRoot(tItemName)
		Quit tHost
	}
	Set $ZT="Trap"
	&sql(select ID,ClassName into :tID,:tClassname from Ens_Config.Item
			Where Production=:tProductionName and Name=:tItemName
			Order By Enabled desc)
	Set tConfigObj=$S(SQLCODE=0:##class(Ens.Config.Item).%OpenId(tID),1:$$$NULLOREF)
	If '$IsObject(tConfigObj) {
		Lock -$$$ConfigRoot(tItemName)
		Set pStatus=$$$ERROR($$$EnsErrGeneral,"No Config Item found for '"_pConfigItemName_"'in Production '"_tProductionName_"'"_$S(SQLCODE=0:"",1:" ; SQLCODE="_SQLCODE))
		Quit tHost
	}
	Set tSC = tConfigObj.PopulateModifiedSettings()
	Set tIndex="" For { Set tIndex = tConfigObj.ModifiedSettings.Next(tIndex)  Quit:tIndex=""
		Set tSetting = tConfigObj.ModifiedSettings.GetAt(tIndex)
		Set $$$ConfigSetting(tItemName,tSetting.Target,tSetting.Name)=tSetting.Value
	}
	Set %DoShadowNew=1
	Set tHost=$classmethod(tClassname,"%New",tItemName)
	Kill %DoShadowNew
	Kill $$$ConfigRoot(tItemName)
	Lock -$$$ConfigRoot(tItemName)
	Set:'$IsObject(tHost) pStatus=$$$ERROR($$$EnsErrGeneral,"Could not create Config Item for "_tProductionName_":"_tItemName)
Exit
	Quit tHost
Trap
	Set $ZT="",pStatus=$$$SystemError
	Kill %DoShadowNew
	Kill $$$ConfigRoot(tItemName)
	Lock -$$$ConfigRoot(tItemName)
	Goto Exit
NewTrap
	Set $ZT="",tSC=$$$SystemError
	Goto NewContinue
]]></Implementation>
</Method>

<Method name="GetProductionSettingValue">
<CodeMode>expression</CodeMode>
<FormalSpec>pName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[##class(Ens.Director).GetCurrProductionSettingValue(.pName,.pStatus)
]]></Implementation>
</Method>

<Method name="GetProductionSettings">
<CodeMode>expression</CodeMode>
<FormalSpec>*pSettings</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(Ens.Director).GetCurrProductionSettings(.pSettings)
]]></Implementation>
</Method>

<Method name="OnGetConnections">
<Description>
This method is called when Ensemble Portal is drawing the production diagram
pArray contains the config names the scanner found.
Users can remove or add new names</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pArray:%String,pItem:Ens.Config.Item</FormalSpec>
<Implementation><![CDATA[
	Do ..GetPropertyConnections(.pArray,pItem)
	Quit
]]></Implementation>
</Method>

<Method name="GetPropertyConnections">
<Description>
Helper method for OnGetConnections</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec>*pArray:%String,pItem:Ens.Config.Item</FormalSpec>
<Implementation><![CDATA[
	Set tProperty = ""  For { Set tProperty = $$$comMemberNext(%class,$$$cCLASSproperty,tProperty)  Quit:""=tProperty
		// Look for datatypes that are of type Ens.DataType.ConfigName, or a subclass
		$$$comMemberKeyGetLvar(tRuntimeType,%class,$$$cCLASSproperty,tProperty,$$$cPROPruntimetype)
		If ($$$getClassType(tRuntimeType)=$$$cCLASSCLASSTYPEDATATYPE)
		 && ((tRuntimeType="Ens.DataType.ConfigName") || $$IsDerivedFrom^%occLibrary(tRuntimeType,"Ens.DataType.ConfigName")) {
			$$$GENERATE("	If pItem.GetModifiedSetting("""_tProperty_""",.tValue) Do:tValue'="""" ..makeConnections(tValue,.pArray,"""_tRuntimeType_""")")
		}
	}
	$$$GENERATE("	If pItem.GetModifiedSetting(""AlertOnError"",.tValue),+tValue { Set pArray(""Ens.Alert"")="""" }")
	$$$GENERATE("	ElseIf pItem.GetModifiedSetting(""AlertOnError"",.tValue) { Kill pArray(""Ens.Alert"") }")
	$$$GENERATE("	Quit")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="makeConnections">
<Description>
Helper method for OnGetConnections</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pConfigNames:Ens.DataType.ConfigName,&pArray,pConfigNameType:%String="Ens.DataType.ConfigName"]]></FormalSpec>
<Implementation><![CDATA[
	For i=1:1:$L(pConfigNames,",") {
		Set tConfigName = $ZStrip($P(pConfigNames,",",i),"<>W")

		// For ConfigNames that use template replacement, don't include them unless it's a canonical value
		Continue:pConfigNameType="Ens.DataType.ConfigNameTemplate"&&'##class(Ens.DataType.ConfigNameTemplate).IsCanonical(tConfigName)

		Set:tConfigName'="" pArray(tConfigName)=""
	}
]]></Implementation>
</Method>

<Method name="GetRequestClassList">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#; subclass responsibility
	Quit ""
]]></Implementation>
</Method>

<Method name="GetResponseClassList">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRequest:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#; subclass responsibility
	Quit ""
]]></Implementation>
</Method>
</Class>


<Class name="Ens.MessageBody">
<Description>
Base class for simple Ensemble message classes, and for the sub- base classes Ens.Request and Ens.Response.
Note however that any persistent or serial object can be sent as a message body. It is not required that all message body
object classes to be derived from this class.  Also note that all message classes derived from this class will share the
same storage extent in the database.</Description>
<Super>%Persistent,Ens.Util.MessageBodyMethods,%XML.Adaptor</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59262,38857.096</TimeCreated>

<Parameter name="DOMAIN">
<Description>
Override DOMAIN inherited from %CSP.Util.AutoForm</Description>
</Parameter>

<Parameter name="EXTENTSIZE">
<Default>2000000</Default>
</Parameter>

<Parameter name="XMLIGNORENULL">
<Default>1</Default>
</Parameter>

<Parameter name="XMLTYPE">
<Description>
Prevent this class from having the same default XML Type and Name as any of its subclasses that have the short classname.</Description>
<Type>%String</Type>
<Default>Ens_Messagebody</Default>
</Parameter>

<Parameter name="XMLINCLUDEINGROUP">
<Description>
Prevent the XML Type and Name of classes derived from this class from interfering with one another if they have the same short classname.</Description>
<Type>%Boolean</Type>
<Default>0</Default>
</Parameter>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Ens.MessageBodyD</DataLocation>
<DefaultData>MessageBodyDefaultData</DefaultData>
<IdLocation>^Ens.MessageBodyD</IdLocation>
<IndexLocation>^Ens.MessageBodyI</IndexLocation>
<StreamLocation>^Ens.MessageBodyS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="MessageBodyDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Ens.MessageHeader">
<IncludeCode>Ensemble</IncludeCode>
<IncludeGenerator>%occInclude</IncludeGenerator>
<Super>%Persistent,Ens.MessageHeaderBase,%XML.Adaptor</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59262,38857.143</TimeCreated>

<Parameter name="EXTENTSIZE">
<Default>20000000</Default>
</Parameter>

<Index name="Extent">
<Type>bitmap</Type>
<Extent>1</Extent>
</Index>

<Index name="TimeCreated">
<Properties>TimeCreated</Properties>
</Index>

<Index name="Status">
<Type>bitmap</Type>
<Properties>Status</Properties>
</Index>

<Index name="SourceConfigName">
<Type>bitmap</Type>
<Properties>SourceConfigName</Properties>
</Index>

<Index name="TargetConfigName">
<Type>bitmap</Type>
<Properties>TargetConfigName</Properties>
</Index>

<Index name="SessionId">
<Properties>SessionId</Properties>
</Index>

<Index name="MessageBodyClassName">
<Type>bitmap</Type>
<Properties>MessageBodyClassName</Properties>
</Index>

<Index name="MessageBodyId">
<Properties>MessageBodyId</Properties>
</Index>

<Property name="Banked">
<Description>
Have this header and its MessageBody and SearchTable been archived to the Enterprise Message Bank already? Header=1, Body=2, SearchTable=4, all=7</Description>
<Type>%Integer</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {Banked}=$S(""={ID}:"",1:$G(^Ens.MsgBank.Banked({ID}),0)) </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Method name="BankedGet">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	Set tID=..%Id()  Quit:""=tID ""  Quit $G(^Ens.MsgBank.Banked(tID),0)
]]></Implementation>
</Method>

<Method name="NewRequestMessage">
<Description>
Create a new request header</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pHeader:Ens.MessageHeader,pMessageBody:%Library.Persistent,&pSessionId:%String,&pSuperSession:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	If $IsObject(pMessageBody) {
		Set:pMessageBody.%IsA("%Library.Persistent")||pMessageBody.%IsA("%Stream.Object") tSC=pMessageBody.%Save()
		Set:$$$ISOK(tSC) tSC=pMessageBody.%GetSwizzleObject(0,.tOID)
		If $$$ISERR(tSC) $$$LOGSTATUS(tSC)  Set pHeader=$$$NULLOREF  Quit tSC
	}
	Set:'$$$IsdefObject(pHeader)||(""'=pHeader.TimeCreated) pHeader = ##class(Ens.MessageHeader).%New()  $$$ASSERT($IsObject(pHeader))
	Set pHeader.TimeCreated = $$$timeUTC
	Set pHeader.Type = $$$eMessageTypeRequest
	Set pHeader.Priority = $$$eMessagePriorityAsync
	Set pHeader.CorrespondingMessageId = ""
	If $G(pSessionId)="" Set pSessionId=pHeader.MessageId()
	Set pHeader.SessionId = pSessionId
	If $G(pSuperSession)'="" Set pHeader.SuperSession = pSuperSession
	If '$IsObject(pMessageBody) {
		Set pHeader.MessageBodyClassName=""
		Set pHeader.MessageBodyId=pMessageBody
	} Else {
		Set pHeader.MessageBodyClassName=$classname(pMessageBody)
		Set pHeader.MessageBodyId=$$$oidPrimary(tOID)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="NewResponseMessage">
<Description>
Create a response message header from a request message header</Description>
<FormalSpec>*pHeader:Ens.MessageHeader,pMessageBody:%Library.Persistent</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	If $IsObject(pMessageBody) {
		Set:pMessageBody.%IsA("%Library.Persistent")||pMessageBody.%IsA("%Stream.Object") tSC=pMessageBody.%Save()
		Set:$$$ISOK(tSC) tSC=pMessageBody.%GetSwizzleObject(0,.tOID)
		If $$$ISERR(tSC) $$$LOGSTATUS(tSC)  Quit ..NewErrorResponse(.pHeader,tSC)
	}
	Set pHeader = ##class(Ens.MessageHeader).%New()  $$$ASSERT($IsObject(pHeader))
	Set pHeader.TimeCreated = $$$timeUTC
	Set pHeader.Type = $$$eMessageTypeResponse
	Set pHeader.SourceConfigName = ..TargetConfigName
	Set pHeader.TargetConfigName = ..SourceConfigName
	Set pHeader.SourceBusinessType = ..TargetBusinessType
	Set pHeader.TargetBusinessType = ..SourceBusinessType
	Set pHeader.BusinessProcessId = ..BusinessProcessId
	Set pHeader.Priority = ..Priority
	Set pHeader.Invocation = ..Invocation
	Set pHeader.TargetQueueName = ..ReturnQueueName
	Set pHeader.ReturnQueueName = ""
	Set pHeader.SessionId = ..SessionId
	Set pHeader.SuperSession = ..SuperSession
	If pHeader.TargetQueueName'="" {
		Set pHeader.CorrespondingMessageId = ..MessageId()
		Set ..CorrespondingMessageId = pHeader.MessageId()
		Set tSC=..%Save()  $$$ASSERT(tSC=$$$OK)
	}
	If '$IsObject(pMessageBody) {
		Set pHeader.MessageBodyClassName=""
		Set pHeader.MessageBodyId=pMessageBody
	} Else {
		Set pHeader.MessageBodyClassName=$classname(pMessageBody)
		Set pHeader.MessageBodyId=$$$oidPrimary(tOID)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="NewErrorResponse">
<Description>
creates an error message response header from a request message header</Description>
<FormalSpec>*pHeader:Ens.MessageHeader,pStatus:%Status</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..NewResponseMessage(.pHeader,$$$NULLOREF)  Quit:$$$ISERR(tSC) tSC
	Set pHeader.IsError=1
	Set pHeader.ErrorStatus=pStatus
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SetStatus">
<Description>
set and immediately save the status field of this object</Description>
<FormalSpec>pStatus:Ens.DataType.MessageStatus</FormalSpec>
<Implementation><![CDATA[
	#; Note: SetStatus is called from Ens.Director:moveEnsRuntimeToEnsSuspended() inside a transaction
	New %tId, %tStatus, %tTimeUtc  Set %tId=..%Id(), %tStatus=pStatus, %tTimeUtc=$$$timeUTC
	If $TLevel>0&&'$G($$$EnsJobLocal("SkipTLevelCheck")) Set tTL=$TLevel  While $TLevel>0 { TCommit } $$$LOGWARNING(tTL_" open user transaction"_$S(tTL>1:"s",1:"")_" found; committing before SetStatus("_%tId_")")
	&sql(UPDATE Ens.MessageHeader Set Status = :%tStatus, TimeProcessed = :%tTimeUtc where %ID = :%tId)
	If 'SQLCODE {
		Set ..Status=%tStatus, ..TimeProcessed=%tTimeUtc
		#; Bank the status change if we're configured for banking headers, or if this header was previously banked and needs its status updated
		#; (Bank other stuff too if we're configured for it)
		Set tFlags=$$$DoArchive,tBank=0
		If ('tFlags&&(0'=tFlags))||(tFlags&&'$$$AND(tFlags,$$$eMsgBankHeader)) {
			Set tBanked=..BankedGet()
			If $$$AND(tBanked,$$$eMsgBankHeader) { Set tFlags=tFlags+$$$eMsgBankHeader }
			ElseIf $$$AND(tBanked,$$$eMsgBankFlagged) { Set tBank=1 If 'tFlags Set tFlags="" } // Ensure we clear tFlags if Banking
		}
		If tFlags {
			If '$D(tBanked) Set tBanked=..BankedGet()
			If '$$$AND(tBanked,$$$eMsgBankFlagged) Set ^(%tId)=tBanked+$$$eMsgBankFlagged
		}
		Do:tFlags||tBank ##class(Ens.Queue).EnQueueId(tFlags_"_"_$Case($$$JobConfigName,..SourceConfigName:1,..TargetConfigName:2,"":0,:3)_"_"_%tId,"Ens.Enterprise.MsgBankOperation")
	}
]]></Implementation>
</Method>

<Method name="%OnAfterSave">
<FormalSpec>insert:%Boolean</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set tFlags=$$$DoArchive  If tFlags {Set:'..Banked ^Ens.MsgBank.Banked(..%Id())=$$$eMsgBankFlagged  Do ##class(Ens.Queue).EnQueueId(tFlags_"_"_$Case($$$JobConfigName,..SourceConfigName:1,..TargetConfigName:2,"":0,:3)_"_"_..%Id(),"Ens.Enterprise.MsgBankOperation")}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="MessageId">
<Description>
The same as %Id(), but works even if the object hasn't been saved already</Description>
<CodeMode>generator</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	$$$GENERATE(" If ..%Id()="""" Do ..%IdSet($increment("_$$$EXTidlocation($$$pEXT,%class)_"))")
	$$$GENERATE(" Quit ..%Id()")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ResendMessage">
<Description>
Deprecated - use ResendDuplicatedMessage() or ResubmitMessage()</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pHeaderId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..ResubmitMessage(.pHeaderId)
]]></Implementation>
</Method>

<Method name="ResubmitMessage">
<Description><![CDATA[
Resubmit the message header identified by <var>pHeaderId</var> to its target queue.
Optional arguments <var>pNewTarget</var> and <var>pNewBody</var> specify replacement values for key header properties.
If these are given, the Description property is updated with annotations giving the previous values.
Finally the boolean <var>pHeadOfQueue</var> argument specifies whether the header should be resubmitted at the end of the target queue or at the head of the line.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pHeaderId:%String,pNewTarget:%String,pNewBody:%RegisteredObject,pHeadOfQueue:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=..PrepareResubmitMessage(.tHeaderObj,.pHeaderId,.pNewTarget,.pNewBody)  Quit:$$$ISERR(tSC) tSC
	Set tSC = ##class(Ens.Queue).EnQueue(tHeaderObj,.pHeadOfQueue)  Quit:$$$ISERR(tSC) $$$EnsError($$$EnsErrGeneral,"Error from EnQueue(); not resubmitting message '"_pHeaderId_"' : "_$$$StatusDisplayString(tSC))
	Quit tSC
]]></Implementation>
</Method>

<Method name="PrepareResubmitMessage">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pHeaderObj:Ens.MessageHeader,pHeaderId:%String,pNewTarget:%String="",pNewBody:%RegisteredObject=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pHeaderObj=$$$NULLOREF, tSC=$$$OK
	If '##class(Ens.Director).IsProductionRunning() Quit $$$EnsError($$$EnsErrGeneral,"ProductionNotRunning; not resubmitting message '"_pHeaderId_"'")
	Set tHdr = ##class(Ens.MessageHeader).%OpenId(pHeaderId,,.tSC)
	Quit:'$IsObject(tHdr) $$$EnsError($$$EnsErrGeneral,"Not resubmitting; can not open message header '"_pHeaderId_"' : "_$$$StatusDisplayString(tSC))

	Set:pNewTarget=tHdr.TargetConfigName pNewTarget=""
	Set:""'=pNewTarget tOldTarget=tHdr.TargetConfigName_"( "_tHdr.TargetBusinessType_") / "_tHdr.TargetQueueName, tHdr.TargetConfigName=pNewTarget
	Set tHdr.TargetQueueName=$G($$$ConfigQueueName($G($$$DispatchNameToConfigName(tHdr.TargetConfigName),0)))
	Quit:""=tHdr.TargetQueueName $$$ERROR($$$EnsErrGeneral,"Target config item '"_tHdr.TargetConfigName_"' is not running")
	Set tHdr.TargetBusinessType=$$$ConfigBusinessType(tHdr.TargetConfigName)
	If ""'=pNewBody {
		Set tOldClass=tHdr.MessageBodyClassName, tOldBodyId=tHdr.MessageBodyId
		If '$IsObject(pNewBody) {
			Set tHdr.MessageBodyClassName=""
			Set tHdr.MessageBodyId=pNewBody
		} Else {
			Set tHdr.MessageBodyClassName=$classname(pNewBody)
			Set:pNewBody.%IsA("%Library.Persistent")||pNewBody.%IsA("%Stream.Object") tSC=pNewBody.%Save()
			Set:$$$ISOK(tSC) tSC=pNewBody.%GetSwizzleObject(0,.tOID)
			If $$$ISERR(tSC) Set tHdr.MessageBodyId=""  Quit tSC
			Set tHdr.MessageBodyId=$$$oidPrimary(tOID)
		}
	}
	Set tHdr.Description="Resubmitted"_$S(""=pNewTarget:"",1:"; old Target = "_tOldTarget)_$S(""=pNewBody:"",1:"; old body = '"_tOldClass_" : "_tOldBodyId_"'")_$S(""=tHdr.Description:"", "Resubmitted"=$E(tHdr.Description,1,$L("Resubmitted")):","_$E(tHdr.Description,$L("Resubmitted")+1,*), 1:": "_tHdr.Description)
	Kill ^Ens.MsgBank.Banked(pHeaderId) ; resubmit to the MsgBank too, if banking is active
	Set pHeaderObj = tHdr
	Quit tSC
]]></Implementation>
</Method>

<Method name="ResendDuplicatedMessage">
<Description><![CDATA[
Resend the message header identified by <var>pOriginalHeaderId</var> by constructing a copy of it and submitting the copy to its target queue.
Optional arguments <var>pNewTarget</var>, <var>pNewBody</var> and <var>pNewSource</var> specify replacement values for key header properties.
The Description property is updated with an annotation giving the original header ID.
Finally the boolean <var>pHeadOfQueue</var> argument specifies whether the new header should be submitted at the end of the target queue or at the head of the line.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pOriginalHeaderId:%String,*pNewHeaderId:%String,pNewTarget:%String,pNewBody:%RegisteredObject,pNewSource:%String,pHeadOfQueue:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pNewHeaderId="", tSC=..NewDuplicatedMessage(.tNewHeader,.pOriginalHeaderId,.pNewTarget,.pNewBody,.pNewSource)  Quit:$$$ISERR(tSC) tSC
	Set tSC = ##class(Ens.Queue).EnQueue(tNewHeader,.pHeadOfQueue)  Quit:$$$ISERR(tSC) $$$EnsError($$$EnsErrGeneral,"Error from EnQueue(); not resending copy of original message '"_pOriginalHeaderId_"' : "_$$$StatusDisplayString(tSC))
	Set pNewHeaderId=tNewHeader.%Id()
	Quit tSC
]]></Implementation>
</Method>

<Method name="NewDuplicatedMessage">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pNewHeader:Ens.MessageHeader,pOriginalHeaderId:%String,pNewTarget:%String="",pNewBody:%RegisteredObject=$$$NULLOREF,pNewSource:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pNewHeader=$$$NULLOREF, tSC=$$$OK
	If '##class(Ens.Director).IsProductionRunning() Quit $$$ERROR($$$EnsErrProductionNotRunning)

	Set tOldHdr = ##class(Ens.MessageHeader).%OpenId(pOriginalHeaderId)
	If '$IsObject(tOldHdr) Quit $G(%objlasterror,$$$ERROR($$$EnsErrGeneral,"Can not open message header "_pOriginalHeaderId))

	Set tNewHdr=tOldHdr.%ConstructClone() $$$ASSERT($IsObject(tNewHdr))
	Set tNewHdr.TimeCreated = $$$timeUTC

	If tNewHdr.Type = $$$eMessageTypeRequest {
		Set tNewHdr.CorrespondingMessageId = ""
		Set:""'=pNewTarget tNewHdr.TargetConfigName=pNewTarget
		Set tNewHdr.TargetQueueName=$G($$$ConfigQueueName($G($$$DispatchNameToConfigName(tNewHdr.TargetConfigName),0)))
		Quit:""=tNewHdr.TargetQueueName $$$ERROR($$$EnsErrGeneral,"Target config item '"_tNewHdr.TargetConfigName_"' is not running")
		Set tNewHdr.TargetBusinessType=$$$ConfigBusinessType(tNewHdr.TargetConfigName)
	} Else {
		Quit:""'=pNewTarget $$$ERROR($$$EnsErrGeneral,"Can not send response messages to new target")
		Quit:'##class(Ens.Queue).Exists(tNewHdr.TargetQueueName) $$$ERROR($$$EnsErrGeneral,"Target reply queue '"_tNewHdr.TargetQueueName_"' no longer exists")
	}
	If ""'=pNewSource {
		Quit:""'=tOldHdr.ReturnQueueName $$$ERROR($$$EnsErrGeneral,"Cannot override source for synchronous request message "_pOriginalHeaderId)
		Set tNewHdr.SourceConfigName = pNewSource
		Set tNewHdr.SourceBusinessType = $$$ConfigBusinessType(pNewSource)
		Set:""=tNewHdr.SourceBusinessType tNewHdr.SourceBusinessType=$$$eHostTypeService
		Set tNewHdr.BusinessProcessId = ""
	}
	If ""'=pNewBody {
		If '$IsObject(pNewBody) {
			Set tNewHdr.MessageBodyClassName=""
			Set tNewHdr.MessageBodyId=pNewBody
		} Else {
			Set tNewHdr.MessageBodyClassName=$classname(pNewBody)
			Set:pNewBody.%IsA("%Library.Persistent")||pNewBody.%IsA("%Stream.Object") tSC=pNewBody.%Save()
			Set:$$$ISOK(tSC) tSC=pNewBody.%GetSwizzleObject(0,.tOID)
			If $$$ISERR(tSC) Set tNewHdr.MessageBodyId=""  Quit tSC
			Set tNewHdr.MessageBodyId=$$$oidPrimary(tOID)
		}
	}
	Set tNewHdr.Description="Resent "_pOriginalHeaderId_$S(""=tOldHdr.Description:"", "Resent "=$E(tOldHdr.Description,1,$L("Resent ")):","_$E(tOldHdr.Description,$L("Resent ")+1,*), 1:": "_tOldHdr.Description)
	Set pNewHeader=tNewHdr
	Quit tSC
]]></Implementation>
</Method>

<Method name="Purge">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pDeletedCount:%Integer,pDaysToKeep:%Integer=7,pKeepIntegrity:%Boolean=1,pBodiesToo:%Boolean=0,pBitmapChunkLimit:%Integer=500</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill ^CacheTemp.EnsPurgeMessage($Job) // This global will hold errors and warnings for the message purge
	Set ^CacheTemp.EnsPurgeMessage($Job) = $ZDT($H,3)
	New %tDoNotDeleteDate,%tID,%tBodyId,%tBodyClassname Set %tID="", %tDoNotDeleteDate = $$$timeUTCHtoUTC($s($ztimezone'<0:($H-pDaysToKeep+1)_","_($ztimezone*60),1:($H-pDaysToKeep)_","_($ztimezone*60+86400)))
	If '$data($$$EnsJobLocal) New $$$EnsJobLocal Set $$$EnsJobLocal = ""
	Set tSC=$$$OK, SQLCODE=0, pDeletedCount=0, pDeletedCount("bodies")=0
	If pBodiesToo {
		If pKeepIntegrity {
			&sql(DECLARE C1 CURSOR FOR
				Select TOP 100000000 ID,MessageBodyId,MessageBodyClassName Into :%tID,:%tBodyId,:%tBodyClassname From Ens.MessageHeader h
					Where (TimeCreated < :%tDoNotDeleteDate)
						And 0 = ( Select Count(*) From Ens.MessageHeader
									Where (SessionId = h.SessionId)
										And (Status<>$$$eMessageStatusCompleted)
										And (Status<>$$$eMessageStatusAborted)
										And (Status<>$$$eMessageStatusError)
										And (Status<>$$$eMessageStatusDiscarded) )
					Order By TimeCreated
				)
			&sql(OPEN C1)
			For { &sql(FETCH C1)  Quit:SQLCODE
				If %tBodyId'="" {
					#; Delete body if body class exists and is persistent and ENSPURGE is NOT explicitly set to 0 (i.e. ENSPURGE=1 by default)
					Set:""=%tBodyClassname&&(%tBodyId=+%tBodyId) %tBodyClassname="Ens.MessageBody"
					If ""'=%tBodyClassname {
						Set tExists=$G(aClass(%tBodyClassname))
						If 0'=tExists {
							If ""=tExists&&'($$$comClassDefined(%tBodyClassname)&&($classmethod(%tBodyClassname,"%IsA","%Persistent")||$classmethod(%tBodyClassname,"%IsA","%Stream.Object")))||($parameter(%tBodyClassname,"ENSPURGE")=0) {
								Set aClass(%tBodyClassname)=0
							} Else {
								try {
									Set tSC1=$classmethod(%tBodyClassname,"%DeleteId",%tBodyId)
									Set:""=tExists aClass(%tBodyClassname)=1, tExists=1 ; , aClass(%tBodyClassname,"extent")=##class(Ens.VDoc.SearchTableGenerator).GetExtentSuperclass(%tBodyClassname)
								} catch {
									Set tSC1 = $$$SystemError
									//Set:""=tExists aClass(%tBodyClassname)=0  Set:'$G(aClass(%tBodyClassname,"doneErr")) tSC1=$$$SystemError // This was preventing subsequent messages to be deleted (HCR374)
								}
								If $$$ISOK(tSC1) || $$$StatusEquals(tSC1,$$$DeleteObjectNotFound,$$$FileCanNotDelete,$$$NotAnInstanceError) {
									Set tSC2 = ##class(Ens.SearchTableBase).RemoveSearchTableEntries(%tBodyClassname,%tBodyId,1)
									If $$$ISERR(tSC2)&&'$G(aClass(%tBodyClassname,"doneErrST")) && '$$$StatusEquals(tSC2,$$$DeleteObjectNotFound,$$$FileCanNotDelete,$$$NotAnInstanceError) { ; || ($$$StatusEquals(tSC2,$$$NotAnInstanceError) && '$classmethod(aClass(%tBodyClassname,"extent"),"%ExistsId",%tBodyId))
										//Set aClass(%tBodyClassname,"doneErrST")=1 // This was preventing subsequent message's search table entries to be deleted (HCR374)
										Set tMsg = "Failed to purge SearchTable entries for deleted body with BodyClassname='"_%tBodyClassname_"', BodyId='"_%tBodyId_"' from header "_%tID_" :"_$$$StatusDisplayString(tSC2)
										Set tSC = ..PurgeSetTemp(3,tMsg,tSC,tSC2)
									}
								} Else { //ElseIf '$G(aClass(%tBodyClassname,"doneErr")) { // This was causing inadequate error reporting (HCR374)
									//Set aClass(%tBodyClassname,"doneErr")=1 // This was preventing subsequent message bodies to be deleted (HCR374)
									Set tMsg = "Failed to purge body for header "_%tID_", BodyClassname='"_%tBodyClassname_"':"_$$$StatusDisplayString(tSC1)
									Set tSC = ..PurgeSetTemp(2,tMsg,tSC,tSC1)
								}
								Set pDeletedCount("bodies")=pDeletedCount("bodies")+$$$ISOK(tSC1)
							}
						}
					}
				}
				&sql(DELETE From Ens.MessageHeader Where ID = :%tID)
				Set pDeletedCount=pDeletedCount+%ROWCOUNT
				If SQLCODE {
					Set tMsg = "Failed to purge message header "_%tID_": SQLCODE="_SQLCODE Set:$G(%msg)'="" tMsg = tMsg_", %msg="_%msg
					Set tSC = ..PurgeSetTemp(1,tMsg,tSC,$$$ERROR($$$EnsErrGeneral,tMsg))
				}
			} Set tCode=SQLCODE &sql(CLOSE C1) Set:'SQLCODE SQLCODE=tCode
		} Else {
			&sql(DECLARE C2 CURSOR FOR
				Select ID,MessageBodyId,MessageBodyClassName Into :%tID,:%tBodyId,:%tBodyClassname From Ens.MessageHeader
					Where (TimeCreated < :%tDoNotDeleteDate))
			&sql(OPEN C2)
			For { &sql(FETCH C2)  Quit:SQLCODE
				If %tBodyId'="" {
					#; Delete body if body class exists and is persistent and ENSPURGE is NOT explicitly set to 0 (i.e. ENSPURGE=1 by default)
					Set:""=%tBodyClassname&&(%tBodyId=+%tBodyId) %tBodyClassname="Ens.MessageBody"
					If ""'=%tBodyClassname {
						Set tExists=$G(aClass(%tBodyClassname))
						If 0'=tExists {
							If ""=tExists&&'($$$comClassDefined(%tBodyClassname)&&($classmethod(%tBodyClassname,"%IsA","%Persistent")||$classmethod(%tBodyClassname,"%IsA","%Stream.Object")))||($parameter(%tBodyClassname,"ENSPURGE")=0) {
								Set aClass(%tBodyClassname)=0
							} Else {
								try {
									Set tSC1=$classmethod(%tBodyClassname,"%DeleteId",%tBodyId)
									Set:""=tExists aClass(%tBodyClassname)=1, tExists=1 ;, aClass(%tBodyClassname,"extent")=##class(Ens.VDoc.SearchTableGenerator).GetExtentSuperclass(%tBodyClassname)
								} catch {
									Set tSC1 = $$$SystemError
									//Set:""=tExists aClass(%tBodyClassname)=0  Set:'$G(aClass(%tBodyClassname,"doneErr")) tSC1=$$$SystemError // This was preventing subsequent messages to be deleted (HCR374)
								}
								If $$$ISOK(tSC1) || $$$StatusEquals(tSC1,$$$DeleteObjectNotFound,$$$FileCanNotDelete,$$$NotAnInstanceError) {
									Set tSC2 = ##class(Ens.SearchTableBase).RemoveSearchTableEntries(%tBodyClassname,%tBodyId,1)
									If $$$ISERR(tSC2)&&'$G(aClass(%tBodyClassname,"doneErrST")) && '$$$StatusEquals(tSC2,$$$DeleteObjectNotFound,$$$FileCanNotDelete,$$$NotAnInstanceError) { ; || ($$$StatusEquals(tSC2,$$$NotAnInstanceError) && '$classmethod(aClass(%tBodyClassname,"extent"),"%ExistsId",%tBodyId))
										//Set aClass(%tBodyClassname,"doneErrST")=1 // This was preventing subsequent message's search table entries to be deleted (HCR374)
										Set tMsg = "Failed to purge SearchTable entries for deleted body with BodyClassname='"_%tBodyClassname_"', BodyId='"_%tBodyId_"' from header "_%tID_" :"_$$$StatusDisplayString(tSC2)
										Set tSC = ..PurgeSetTemp(3,tMsg,tSC,tSC2)
									}
								} Else { //ElseIf '$G(aClass(%tBodyClassname,"doneErr")) { // This was causing inadequate error reporting (HCR374)
									//Set aClass(%tBodyClassname,"doneErr")=1 // This was preventing subsequent message bodies to be deleted (HCR374)
									Set tMsg = "Failed to purge body for header "_%tID_", BodyClassname='"_%tBodyClassname_"':"_$$$StatusDisplayString(tSC1)
									Set tSC = ..PurgeSetTemp(2,tMsg,tSC,tSC1)
								}
								Set pDeletedCount("bodies")=pDeletedCount("bodies")+$$$ISOK(tSC1)
							}
						}
					}
				}
				&sql(DELETE From Ens.MessageHeader Where ID = :%tID)
				Set pDeletedCount=pDeletedCount+%ROWCOUNT
				If SQLCODE {
					Set tMsg = "Failed to purge message header "_%tID_": SQLCODE="_SQLCODE Set:$G(%msg)'="" tMsg = tMsg_", %msg="_%msg
					Set tSC = ..PurgeSetTemp(1,tMsg,tSC,$$$ERROR($$$EnsErrGeneral,tMsg))
				}
			} Set tCode=SQLCODE &sql(CLOSE C2) Set:'SQLCODE SQLCODE=tCode
		}
	} Else {
		If pKeepIntegrity {
			&sql(DECLARE C3 CURSOR FOR
				Select TOP 100000000 ID Into :%tID From Ens.MessageHeader h
					Where TimeCreated < :%tDoNotDeleteDate
						And 0 = ( Select Count(*) From Ens.MessageHeader
								Where (SessionId = h.SessionId)
									And (Status<>$$$eMessageStatusCompleted)
									And (Status<>$$$eMessageStatusAborted)
									And (Status<>$$$eMessageStatusError)
									And (Status<>$$$eMessageStatusDiscarded) )
					Order By TimeCreated
				)
			&sql(OPEN C3) For { &sql(FETCH C3)  Quit:SQLCODE
				&sql(Delete From Ens.MessageHeader Where ID=:%tID)
				Set pDeletedCount=pDeletedCount+%ROWCOUNT
				If SQLCODE {
					Set tMsg = "Failed to purge message header "_%tID_": SQLCODE="_SQLCODE Set:$G(%msg)'="" tMsg = tMsg_", %msg="_%msg
					Set tSC = ..PurgeSetTemp(1,tMsg,tSC,$$$ERROR($$$EnsErrGeneral,tMsg))
				}
			} Set tCode=SQLCODE &sql(CLOSE C3) Set:'SQLCODE SQLCODE=tCode
		} Else {
			&sql(DECLARE C4 CURSOR FOR
				Select ID Into :%tID From Ens.MessageHeader Where TimeCreated < :%tDoNotDeleteDate)
			&sql(OPEN C4) For { &sql(FETCH C4)  Quit:SQLCODE
				Set %ROWCOUNT=0
				&sql(Delete From Ens.MessageHeader Where ID=:%tID)
				Set pDeletedCount=pDeletedCount+%ROWCOUNT
				If SQLCODE {
					Set tMsg = "Failed to purge message header "_%tID_": SQLCODE="_SQLCODE Set:$G(%msg)'="" tMsg = tMsg_", %msg="_%msg
					Set tSC = ..PurgeSetTemp(1,tMsg,tSC,$$$ERROR($$$EnsErrGeneral,tMsg))
				}
			} Set tCode=SQLCODE &sql(CLOSE C4) Set:'SQLCODE SQLCODE=tCode
		}
	}
	Set:SQLCODE&&(SQLCODE'=100) tSC=$$$ADDSC(tSC,$$$ERROR($$$EnsErrGeneral,"Purge error at ID "_$G(%tID)_"; SQLCODE = "_SQLCODE))
	Set tBitmapSC = ..PurgeBitmaps(pBitmapChunkLimit,.tDeletedChunks)
	Merge pDeletedCount("bitmaps") = tDeletedChunks
	Quit $$$ADDSC(tSC,tBitmapSC)
]]></Implementation>
</Method>

<Method name="PurgeSetTemp">
<Description><![CDATA[
Log a warning in the Event Log; add to tSC status; set error/warning in a temp global as below: <br>
Total error count is in subscript 0. <br>
Errors while deleting message headers are in subscript 1. <br>
Errors while deleting message bodies are in subscript 2. <br>
Errors while deleting search table entries are in subscript 3.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pType:%Integer,pMsg:%String,pSC:%Status,pSC2:%Status</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$LOGWARNING(pMsg)
	Set tCount0 = $I(^CacheTemp.EnsPurgeMessage($Job,0))
	Set tCount = $I(^CacheTemp.EnsPurgeMessage($Job,pType))
	Set:$G(%tID)'="" ^CacheTemp.EnsPurgeMessage($Job,pType,%tID) = pMsg
	If tCount0<11 {
		Set pSC = $$$ADDSC(pSC,pSC2)
	}
	ElseIf tCount0=11 {
		Set pSC = $$$ADDSC(pSC,$$$ERROR($$$GeneralError,"There are more errors and/or warnings, see the Ensemble Event Log and ^CacheTemp.EnsPurgeMessage("_$Job_") for the full list"))
	}
	Else {
		// do not put into pSC more than 10 messages
	}
	Quit pSC
]]></Implementation>
</Method>

<Method name="needsReply">
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[(""'=..ReturnQueueName) || (..Priority<=$$$eMessagePrioritySync)
]]></Implementation>
</Method>

<Method name="%OnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tID=$$$oidPrimary(oid)
	Kill:""'=tID ^Ens.MsgBank.Banked(tID)
	Quit $$$OK
]]></Implementation>
</Method>

<Trigger name="OnDelete">
<Code>	Set tID={%%ID}
	Kill ^Ens.MsgBank.Banked(tID)
	Quit</Code>
<Event>DELETE</Event>
</Trigger>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Ens.MessageHeaderD</DataLocation>
<DefaultData>MessageHeaderDefaultData</DefaultData>
<IdLocation>^Ens.MessageHeaderD</IdLocation>
<IndexLocation>^Ens.MessageHeaderI</IndexLocation>
<StreamLocation>^Ens.MessageHeaderS</StreamLocation>
<ExtentSize>20000000</ExtentSize>
<Data name="MessageHeaderDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>BusinessProcessId</Value>
</Value>
<Value name="3">
<Value>Category</Value>
</Value>
<Value name="4">
<Value>CorrespondingMessageId</Value>
</Value>
<Value name="5">
<Value>ErrorStatus</Value>
</Value>
<Value name="6">
<Value>Invocation</Value>
</Value>
<Value name="7">
<Value>IsError</Value>
</Value>
<Value name="8">
<Value>MessageBody</Value>
</Value>
<Value name="9">
<Value>Priority</Value>
</Value>
<Value name="10">
<Value>ReturnQueueName</Value>
</Value>
<Value name="11">
<Value>SessionId</Value>
</Value>
<Value name="12">
<Value>SourceConfigName</Value>
</Value>
<Value name="13">
<Value>Status</Value>
</Value>
<Value name="14">
<Value>TargetConfigName</Value>
</Value>
<Value name="15">
<Value>TargetQueueName</Value>
</Value>
<Value name="16">
<Value>TimeCreated</Value>
</Value>
<Value name="17">
<Value>TimeProcessed</Value>
</Value>
<Value name="18">
<Value>Type</Value>
</Value>
<Value name="19">
<Value>MessageBodyId</Value>
</Value>
<Value name="20">
<Value>SourceBusinessType</Value>
</Value>
<Value name="21">
<Value>TargetBusinessType</Value>
</Value>
<Value name="22">
<Value>MessageBodyClassName</Value>
</Value>
<Value name="23">
<Value>Description</Value>
</Value>
<Value name="24">
<Value>SuperSession</Value>
</Value>
<Value name="25">
<Value>Resent</Value>
</Value>
</Data>
<Property name="MessageBodyClassName">
<Selectivity>10%</Selectivity>
</Property>
<Property name="MessageBodyId">
<Selectivity>0.0001%</Selectivity>
</Property>
<Property name="Priority">
<Selectivity>20%</Selectivity>
</Property>
<Property name="SessionId">
<Selectivity>20</Selectivity>
</Property>
<Property name="SourceConfigName">
<Selectivity>5%</Selectivity>
</Property>
<Property name="Status">
<Selectivity>11%</Selectivity>
</Property>
<Property name="TargetConfigName">
<Selectivity>5%</Selectivity>
</Property>
<Property name="TimeCreated">
<Selectivity>5</Selectivity>
</Property>
<Property name="TimeProcessed">
<Selectivity>5</Selectivity>
</Property>
</Storage>
</Class>


<Class name="Ens.Production">
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>Ensemble</IncludeCode>
<IncludeGenerator>Ensemble</IncludeGenerator>
<ProcedureBlock>1</ProcedureBlock>
<Super>%RegisteredObject,Ens.Settings</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59312,71352.764</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="ShutdownTimeout">
<Description>
Amount of time to wait for a click on Stop Production to succeed</Description>
<Type>%Numeric</Type>
<InitialExpression>120</InitialExpression>
</Property>

<Property name="UpdateTimeout">
<Description><![CDATA[
Amount of time to wait for Production updates to succeed <br>
This means both clicking UpdateProduction and clicking Apply for changes to a configuration item in a running production.]]></Description>
<Type>%Numeric</Type>
<InitialExpression>10</InitialExpression>
</Property>

<Property name="AlertNotificationManager">
<Description>
The default Alert Notification Manager for use by the Managed Alert framework.</Description>
<Type>Ens.DataType.ConfigName</Type>
</Property>

<Property name="AlertNotificationOperation">
<Description>
The default Alert Notification Operation for use by the Managed Alert framework.
The Notification Manager can be configured to send notifications to other hosts within the production,
but this setting provides a fallback for situations which are not captured by the logic in the Notification Manager.</Description>
<Type>Ens.DataType.ConfigName</Type>
</Property>

<Property name="AlertNotificationRecipients">
<Description>
A comma-separated list of recipients that should be used for alert notifications
when no other recipients have been specified by the notification framework.</Description>
<Type>%Library.String</Type>
<Parameter name="MAXLEN" value="2048"/>
</Property>

<Property name="AlertActionWindow">
<Description>
The default number of minutes within which a Managed Alert should be acted upon.</Description>
<Type>%Library.Integer</Type>
<InitialExpression>##class(Ens.Alerting.Utils).#DEFAULTACTIONWINDOW</InitialExpression>
</Property>

<Parameter name="SETTINGS">
<Default>ShutdownTimeout,UpdateTimeout,AlertNotificationManager:Alerting,AlertNotificationOperation:Alerting,AlertNotificationRecipients:Alerting,AlertActionWindow:Alerting</Default>
</Parameter>

<Projection name="Production">
<Type>Ens.Projection.Production</Type>
</Projection>

<Method name="Start">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ##class(Ens.Director).StartProduction($classname())
]]></Implementation>
</Method>

<Method name="Update">
<ClassMethod>1</ClassMethod>
<FormalSpec>pTimeout:%Numeric,pForce:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ##class(Ens.Director).UpdateProduction(.pTimeout,.pForce)
]]></Implementation>
</Method>

<Method name="Stop">
<ClassMethod>1</ClassMethod>
<FormalSpec>pTimeout:%Numeric,pForce:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ##class(Ens.Director).StopProduction(.pTimeout,.pForce)
]]></Implementation>
</Method>

<Method name="OnStart">
<Description>
Override this in your Production class to do setup before the Production starts</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTimeStarted:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnStop">
<Description>
Override this in your Production class to do cleanup after the Production stops</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTimeStarted:%String,pForced:%Boolean</FormalSpec>
<Implementation><![CDATA[	Quit
]]></Implementation>
</Method>

<Method name="Register">
<Description>
Deprecated</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	Do {
		Set tSC=##class(Ens.Config.Production).LoadFromClass($classname())
		Do:$$$ISERR(tSC) $system.OBJ.DisplayError(tSC)
	} while (0)
Exit
	Quit tSC
Trap
 	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="TestStart">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ##class(Ens.Director).GetProductionStatus(.tProductionName,.tState)
	If $$$ISERR(tSC) {
		$$$LOGSTATUS(tSC)
		Quit tSC
	}
	If tState=$$$eProductionStateRunning {
		if tProductionName '= $$$CurrentClass {
			w !,"Stop production "_tProductionName_"? [No] "  Read tInput,!  Quit:$Case($ZCVT(tInput,"L"),"yes":0,"y":0,:1) $$$ERROR($$$EnsErrGeneral,"Not stopping Production "_tProductionName)
			w "Stopping production ",tProductionName,!
			Set tSC = ..Stop() Quit:$$$ISERR(tSC) tSC
			Set tState=0
		}
		else { w !,"Already running "_$$$CurrentClass,! }
	}
	If tState'=$$$eProductionStateRunning {
		Set tSC = ..Start()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetSettingValue">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pName:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[##class(Ens.Director).GetProductionSettingValue("",.pName,.pStatus)
]]></Implementation>
</Method>

<Method name="GetSettingsArray">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>*pSettings</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(Ens.Director).GetProductionSettings("",.pSettings)
]]></Implementation>
</Method>

<Method name="ApplySettings">
<Description><![CDATA[
Apply multiple settings to a production
<var>pProductionName</var> is the name of the Production to which to apply the settings <br/>
<var>pSettings</var> is a local array of settings structured in the following way: <br/>
   pSettings(&lt;itemName&gt;,&lt;target&gt;,&lt;settingName&gt;)=&lt;settingValue&gt; <br/>
Where:  <br/>
   &lt;itemName&gt; is the configuration item name in the production  <br/>
    &lt;target&gt; Is one of:  <br/>
        Item: Means the setting is a property of the item itself, such as PoolSize  <br/>
        Host: Sets a host setting  <br/>
        Adapter: Sets an adapter setting  <br/>
    &lt;settingName&gt; is the setting name  <br/>
    &lt;settingValue&gt; is the desired value of the setting. <br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pProductionName:%String,&pSettings]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status
	Set tSC=$$$OK,$ZT="Trap"
	Do {
		#dim tState As %Integer
		#dim tRunningProduction As %String
		#dim tProduction As Ens.Config.Production
		#dim tItem,tTarget,tSetting
		
		// Grab the state of the production
		Set tSC = ##class(Ens.Director).GetProductionStatus(.tRunningProduction,.tState)
		If $$$ISERR(tSC) {
			$$$LOGSTATUS(tSC)
			Quit
		}
		
		// Open the production up
		Set tProduction = ##class(Ens.Config.Production).%OpenId(pProductionName,,.tSC) Quit:$$$ISERR(tSC)
		
		// Walk the bag of settings
		Set tItem = ""
		While ($$$ISOK(tSC)) {
			Set tItem = $ORDER(pSettings(tItem))
			Quit:tItem=""
			
			#dim tItemObj As Ens.Config.Item
			
			Set tItemObj = tProduction.FindItemByConfigName(tItem)
			If '$IsObject(tItemObj) {
				Set tSC=$$$ERROR($$$EnsErrProductionSettingInvalid,pProductionName,tItem)
				Quit
			}
			
			// Now, for each item, we must see what we're applying it to
			Set tTarget = ""
			While ($$$ISOK(tSC)) {
				Set tTarget = $ORDER(pSettings(tItem,tTarget))
				Quit:tTarget=""
				
				// And what actual setting this is ...
				Set tSetting = ""
				While ($$$ISOK(tSC)) {
					Set tSetting = $ORDER(pSettings(tItem,tTarget,tSetting))
					Quit:tSetting=""
				
					If tTarget="Item" {
						// If the target is an item, then we're setting a property *on* the config item
						If $$$comMemberDefined("Ens.Config.Item",$$$cCLASSproperty,tSetting) {
							Set $ZOBJPROPERTY(tItemObj,tSetting) = pSettings(tItem,tTarget,tSetting)
						} Else {
							// No such property, report an error
							Set tSC=$$$ERROR($$$PropertyDoesNotExist,tSetting)
							Quit
						}
					} Else {
						// Apply the setting
						#dim tSettingObj As Ens.Config.Setting
						Set tSettingObj = tItemObj.FindSettingByName(tSetting,tTarget)
						If '$IsObject(tSettingObj) {
							// This is a new setting
							Set tSettingObj = ##class(Ens.Config.Setting).%New()
							Set tSettingObj.Name = tSetting
							Do tItemObj.Settings.Insert(tSettingObj)
						}
						
						// We can finally set the setting
						Set tSettingObj.Target = tTarget
						Set tSettingObj.Value = pSettings(tItem,tTarget,tSetting)
					}
				}
			}
		}
		// If we errored, bail out
		Quit:$$$ISERR(tSC)
				
		// Save the changes we made to the production
		Set tSC = tProduction.%Save(1)
		Quit:$$$ISERR(tSC)
		
		// Regenerate the XData in the corresponding class
		Set tSC = tProduction.SaveToClass()
		Quit:$$$ISERR(tSC)
		
		// Finally, does the production need updating?
		If (tRunningProduction=pProductionName)&&(tState=$$$eProductionStateRunning) {
			// Update the running production with the new settings
			Set tSC = ##class(Ens.Director).UpdateProduction(##class(Ens.Director).GetRunningProductionUpdateTimeout())
		}
		
	} While (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="OnConfigChange">
<Description>
This method is called when config changes to the Production or any item are saved from the portal</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pProduction:Ens.Config.Production,pItem:Ens.Config.Item</FormalSpec>
</Method>
</Class>


<Class name="Ens.Projection.Production">
<ClassType/>
<IncludeCode>Ensemble</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Projection.AbstractProjection</Super>
<System>3</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59368,35929.329855</TimeCreated>

<Method name="CreateProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 	Set $ZT="Trap",tSC=$$$OK
	Do {
		#; Don't run this method on the base class
		If classname="Ens.Production" Quit
		
		If ##class(Ens.Config.Production).%ExistsId(classname) {
			Do ##class(Ens.Config.Production).%DeleteId(classname)
		}
		
		#; Find the XDATA itself
		Set tSC=##class(Ens.Util.XML.XDataEntityResolver).EntityFromXDATA(.tStream,classname,"ProductionDefinition")
		If $$$ISERR(tSC) Quit
		
		#; Create a SAX resolver for the Schema
		Set tResolver=##class(Ens.Util.XML.XDataEntityResolver).%New("Ens.Schema.Production")
 		$$$ASSERT($IsObject(tResolver))
 		
 		Set tSC=##class(Ens.Util.XML.Validator).ValidateStream(tStream,tResolver,"Schema")
 		If $$$ISERR(tSC) {	
			Set tSC=$$$ADDSC($$$ERROR($$$EnsErrInvalidProduction),tSC)
		} Else {
			Set tSC=##class(Ens.Config.Production).LoadFromClass(classname)
		}
	} while (0)
Exit
	Set ^CacheTemp.EnsProdConfigChange($Namespace,classname) = $$$timeUTC // Track compilation
	Set tSC2 = $$$AuditModifyProductionConfig(classname,"","Production class compiled")
	Quit tSC
Trap
 	Set $ZT="",tSC=$$$ERROR($$$CacheError,$ZE)
	Goto Exit
]]></Implementation>
</Method>

<Method name="RemoveProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,recompile:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Don't run this method on the base class
	If classname="Ens.Production" Quit $$$OK
	If ##class(Ens.Config.Production).%ExistsId(classname) {
		Do ##class(Ens.Config.Production).%DeleteId(classname)
	}
	Set ^CacheTemp.EnsProdConfigChange($Namespace,classname) = $$$timeUTC // Track uncompilation
 	Set tSC2 = $$$AuditModifyProductionConfig(classname,"","Production class deleted or uncompiled")
 	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Ens.Request">
<Super>Ens.MessageBody,Ens.Util.RequestBodyMethods</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59270,37668.545</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="RESPONSECLASSNAME">
<Type>%String</Type>
</Parameter>

<Parameter name="XMLTYPE">
<Description>
Prevent this class from having the same default XML Type and Name as any of its subclasses that have the short classname "Request".</Description>
<Type>%String</Type>
<Default>Ens_Request</Default>
</Parameter>

<Parameter name="XMLINCLUDEINGROUP">
<Description>
Prevent the XML Type and Name of classes derived from this class from interfering with one another if they have the same short classname.</Description>
<Type>%Boolean</Type>
<Default>0</Default>
</Parameter>

<Method name="NewResponse">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pResponse:Ens.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	Do {
		If ..#RESPONSECLASSNAME="" Set pResponse=$$$NULLOREF, tSC=$$$ERROR($$$EnsErrGeneral,$$$CurrentClass_" has no value for parameter RESPONSECLASSNAME") Quit
		Set pResponse = $zobjclassmethod(..#RESPONSECLASSNAME,"%New")  Set:'$IsObject(pResponse) tSC=%objlasterror
	} while (0)
Exit
	Quit tSC
Trap
 	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
</Storage>
</Class>


<Class name="Ens.Response">
<Super>Ens.MessageBody,Ens.Util.ResponseBodyMethods</Super>
<System>4</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>59270,37668.576</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="XMLTYPE">
<Description>
Prevent this class from having the same default XML Type and Name as any of its subclasses that have the short classname "Response".</Description>
<Type>%String</Type>
<Default>Ens_Response</Default>
</Parameter>

<Parameter name="XMLINCLUDEINGROUP">
<Description>
Prevent the XML Type and Name of classes derived from this class from interfering with one another if they have the same short classname.</Description>
<Type>%Boolean</Type>
<Default>0</Default>
</Parameter>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
</Storage>
</Class>


<Class name="Ens.Rule.Model.action">
<Abstract>1</Abstract>
<Super>Ens.Rule.Model.base</Super>
<System>3</System>
<TimeChanged>63920,75704</TimeChanged>
<TimeCreated>61978,49738.643827</TimeCreated>
</Class>


<Class name="Ens.Settings">
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>Ensemble</IncludeCode>
<IncludeGenerator>%occInclude,EnsUtil</IncludeGenerator>
<ProcedureBlock>1</ProcedureBlock>
<System>4</System>
<TimeChanged>63920,75705</TimeChanged>
<TimeCreated>59450,80236.833193</TimeCreated>

<Parameter name="SETTINGS">
<Description>
List of properties can be set as settings in the configuration file
format is a comma separated list of property names</Description>
</Parameter>

<Method name="AssignOneSetting">
<FormalSpec>pProperty:%String,pValue:%String,pName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	Do {
		If '$IsValidNum(pValue) {
			Set $property($this,pProperty)=""_pValue
		} Else {
			Set tPropId=$$$CurrentClass_"||"_pProperty
			&sql(SELECT RuntimeType INTO :tType FROM %Dictionary.CompiledProperty Where %ID=:tPropId)
			IF SQLCODE { Set tType="%Library.String" }
			ElseIf "Ens.DataType."=$E(tType,1,$L("Ens.DataType.")) {
				&sql(SELECT Super INTO :tSuper FROM %Dictionary.CompiledClass Where %ID=:tType)
				Set tType=$S('SQLCODE:tSuper, 1:"%Library.String")
			}
			If (tType="%Library.Float")||(tType="%Library.Double") {
				Set $property($this,pProperty)=$Double(pValue)
			} ElseIf tType'="%Library.String" {
				Set $property($this,pProperty)=$Decimal(pValue)
			} Else {
				Set $property($this,pProperty)=""_pValue
			}
		}
	} While 0
Exit
	Quit tSC
Trap
	Set $ZT=""
	If $ZE["<PROPERTY DOES NOT EXIST>" Set tSC=$$$EnsError($$$EnsErrProductionSettingInvalid,pName,pProperty) Goto Exit
	Set tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="GetSettings">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>*pSettings</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK, tSettingsList="", tStack=1, tStack(tStack)=%class.Name
	While 0'=tStack {
		Set tClassList=tStack(tStack)
		Set tClass=$P(tClassList,","), tStack(tStack)=$P(tClassList,",",2,$L(tClassList,","))
		If $Case(tClass,"":0, "Ens.Settings":0, "%Library.RegisteredObject":0, :1) { 
			Set tSettings=$$$comMemberKeyGet(tClass,$$$cCLASSparameter,"SETTINGS",$$$cPARAMdefault)
			#; Loop over all the elements of the SETTINGS parameter from the current class level
			Set url="",depth=0  For i=1:1:$L(tSettings,",") { Set one=$P(tSettings,",",i)
				If ""'=url {
					Set depth=$$bracesDepth(one,.depth)
					Set url=url_one
				} Else {
					Set name=$P(one,":"), attrs=$E(one,2+$L(name),*), name=$ZStrip(name,"<>W")
					Set cat=$P(attrs,":"), url=$E(attrs,2+$L(cat),*), cat=$ZStrip(cat,"<>W"), url=$ZStrip(url,"<>W")
					If ""=name {
						Continue:cat_url=""
						Set tSC=$$$ERROR($$$GeneralError,"Empty setting name at position "_i_" in SETTINGS parameter "_tSettings)
						Quit
					}
					If $TR(name,"""")'=name Set tSC=$$$ERROR($$$GeneralError,"Setting "_name_" contains invalid characters at position "_i_" in SETTINGS parameter "_tSettings)  Quit
					If $TR(cat,"""")'=cat Set tSC=$$$ERROR($$$GeneralError,"Category "_cat_" for Setting "_name_" contains invalid characters at position "_i_" in SETTINGS parameter "_tSettings)  Quit
					Set depth=$$bracesDepth(url,.depth)
				}
				If depth<0 Set tSC=$$$ERROR($$$GeneralError,"Setting "_name_" has excess close braces in its url at position "_i_" in SETTINGS parameter "_tSettings)  Quit
				Continue:depth
				If "-"=$E(name) Set:'$D(tExists($E(name,2,*))) tExists($E(name,2,*))=":"  Continue
				Set:'$D(tExists(name)) tSettingsList=tSettingsList_name_",", tExists(name)=cat, tExists(name,"url")=url
				Set (name,cat,url)=""
			} Quit:$$$ISERR(tSC)
			Set tClassList=$$$comClassKeyGet(tClass,$$$cCLASSsuper)
		} Else { Set tClassList="" }
		If ""'=tClassList Set tStack($I(tStack))=tClassList
		Else  Set:""=tStack(tStack) tStack=tStack-1
	} Quit:$$$ISERR(tSC) tSC
	Kill %EnsSettingsGen
	Set n="" For { Set cat="", n=$O(tExists(n),1,cat)  Quit:""=n  Set:""=cat cat="Additional"
		If ":"=cat {
			Do %code.WriteLine(" Set pSettings("":"",""-"_n_""")=""""")
		} Else {
			If '$D(tCats(cat)) {
				Set tCatLoc = $$$GetLocalizedName(cat)
				Do %code.WriteLine(" Set pSettings("":localizedCategory"","""_cat_""")="""_tCatLoc_"""")
			}
			If $G(tExists(n,"url"))="" {
				Set tPropType = $$$comMemberKeyGet(%class.Name, $$$cCLASSproperty, n, $$$cPROPtype)
				Set tEditor = $case(tPropType, "Ens.DataType.ConfigName": "selector?context={Ens.ContextSearch/ProductionItems?targets=1&productionName=@productionId}", :"")
				If tEditor '= "" Set tExists(n,"url")=tEditor
			}
			Set tSettLoc = $$$GetLocalizedName(n)
			Do %code.WriteLine(" Set pSettings("":"","""_n_""")="""_cat_""", pSettings("""_cat_""","""_n_""")="""_$replace($G(tExists(n,"url")),"""","""""")_""", pSettings("""_cat_""","""_n_""",""loc"")="""_tSettLoc_"""")
			Set tCats(cat)=""
			If '$data(%EnsSettingsGen(n)) {
				Set %EnsSettingsGen(n) = ""
				Set %EnsSettingsGen(n,"cat") = cat
				Set %EnsSettingsGen(n,"loc") = tSettLoc
				Set %EnsSettingsGen(n,"url") = $get(tExists(n,"url"))
			}
		}
	}
	Do %code.WriteLine(" Quit """_$E(tSettingsList,1,*-1)_"""")
	Quit $$$OK
bracesDepth(str,d)
	set d1=d+$L(str)-$L($TR(str,"{"))
	set d1=d1-($L(str)-$L($TR(str,"}")))
	Quit d1
]]></Implementation>
</Method>

<Method name="GetSettingRow">
<Description><![CDATA[
Generated helper method to get the data for setting <var>pSettingName</var> in <var>pSourceClass</var> without referencing ^oddCOM.
For backwards compatibility reasons, the code will fall back on calling <method>GetDynamicSettingRow</method>()
to perform a lookup in ^oddCOM if the specific subclass hasn't yet had the method regenerated.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pSettingName:%String="",pSourceClass:%String=""</FormalSpec>
<GenerateAfter>GetSettings</GenerateAfter>
<Private>1</Private>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Merge tSettings = %EnsSettingsGen
	Kill %EnsSettingsGen
	Do %code.WriteLine($char(9) _ "Set tRow = """"")
	Do %code.WriteLine($char(9) _ "// Check if the class has been compiled with the new generator")
	Do %code.WriteLine($char(9) _ "If (pSourceClass = """ _ %compiledclass.Name _ """) {")
	Do %code.WriteLine($char(9,9) _ "Set tRow = $case(pSettingName,")
	#dim tProp As %Dictionary.CompiledProperty
	For i=%compiledclass.Properties.Count():-1:1 {
		Set tProp = %compiledclass.Properties.GetAt(i)
		If $data(tSettings(tProp.Name)) {
			Set tGenSettings(tProp.Name,1) = $$$quote(tProp.Name)
			Set tGenSettings(tProp.Name,2) = $replace($translate($$$quote(tProp.Description),$c(13),""),$c(10),"""_$char(13,10)_""")
			Set tGenSettings(tProp.Name,3) = $$$quote(tProp.Type)
			Set tGenSettings(tProp.Name,4) = tProp.InitialExpression
			Set tCount = 5
			For tParm = "MAXLEN","MINVAL","MAXVAL","VALUELIST","DISPLAYLIST" {
				Set tParmVal = tProp.Parameters.GetAt(tParm)
				Set tGenSettings(tProp.Name,tCount) = $$$quote(tParmVal)
				Set tCount = tCount + 1
			}
			Set tGenSettings(tProp.Name,10) = +tProp.Required
			Set tGenSettings(tProp.Name,11) = $$$quote($get(tSettings(tProp.Name,"loc")))
			Set tCategory = $get(tSettings(tProp.Name,"cat"))
			Set tLocCategory = $select(tCategory = "": "", 1: $$$GetLocalizedName(tCategory))
			Set tGenSettings(tProp.Name,12) = $$$quote(tCategory)
			Set tGenSettings(tProp.Name,13) = $$$quote(tLocCategory)
			Set tGenSettings(tProp.Name,14) = $$$quote($get(tSettings(tProp.Name,"url")))
			Set tGenSettings(tProp.Name) = 14
		}
	}
	Set tName = ""
	For {
		Set tName = $order(tGenSettings(tName),1,tSettingCount)
		Quit:(tName = "")
		Continue:(tSettingCount '= 14)
		Do %code.Write($char(9,9,9) _ $$$quote(tName) _ ": $LB(")
		For i=1:1:14 {
			Do %code.Write($get(tGenSettings(tName,i)) _ $select(i = 14: ")", 1: ","))
		}
		Do %code.WriteLine(",")
	}
	Do %code.WriteLine($char(9,9,9) _ ": """")")
	Do %code.WriteLine($char(9) _ "}")
	Do %code.WriteLine($char(9) _ "Else { // Fall back on getting the data dynamically ")
	Do %code.WriteLine($char(9,9) _ "Set tRow = ..GetDynamicSettingRow(pSettingName,pSourceClass)")
	Do %code.WriteLine($char(9) _ "}")
	Do %code.WriteLine($char(9) _ "Quit tRow")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetDynamicSettingRow">
<Description><![CDATA[
Helper method to get the data for setting <var>pSettingName</var> in <var>pSourceClass</var> that 
dynamically looks the data up in ^oddCOM. This method should only be invoked when 
<method>GetSettingRow</method>() recognises that it hasn't been regenerated in <var>pSourceClass</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSettingName:%String="",pSourceClass:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set tRow = ""
	If (pSettingName '= "") && (pSourceClass '= "") {
		Set tRow = $LB(pSettingName)
		Set tRow = tRow _ $LB($$$comMemberKeyGet(pSourceClass,$$$cCLASSproperty,pSettingName,$$$cPROPdescription))
		Set tRow = tRow _ $LB($$$comMemberKeyGet(pSourceClass,$$$cCLASSproperty,pSettingName,$$$cPROPtype))
		Set tRow = tRow _ $LB(..EvalInitialExpression(pSettingName))
		For tPropParam = "MAXLEN","MINVAL","MAXVAL","VALUELIST","DISPLAYLIST" {
			Set tRow = tRow _ $LB($$$comMemberArrayGet(pSourceClass,$$$cCLASSproperty,pSettingName,$$$cPROPparameter,tPropParam))
		}
		Set tRow = tRow _ $LB($$$comMemberKeyGet(pSourceClass,$$$cCLASSproperty,pSettingName,$$$cPROPrequired))
		Set tCategory = $get(%EnsEnumSettings(":",pSettingName))
		Set tRow = tRow _ $LB(%EnsEnumSettings(tCategory,pSettingName,"loc"))
		Set tRow = tRow _ $LB(tCategory)
		Set tRow = tRow _ $LB(%EnsEnumSettings(":localizedCategory",tCategory))
		Set tRow = tRow _ $LB(%EnsEnumSettings(tCategory,pSettingName))
	}
	Quit tRow
]]></Implementation>
</Method>

<Query name="EnumerateSettings">
<Type>%Query</Type>
<Parameter name="ROWSPEC" value="Name,Description,Type,Default,MAXLEN,MINVAL,MAXVAL,VALUELIST,DISPLAYLIST,IsRequired,LocalizedName,Category,LocalizedCategory,EditorContext"/>
</Query>

<Method name="EnumerateSettingsExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill qHandle,%EnsEnumSettings Set qHandle="", %EnsEnumSettings=..GetSettings(.%EnsEnumSettings) ; EnumerateSettings will not be called recursively in-process
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="EnumerateSettingsClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateSettingsExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 	Kill qHandle, %EnsEnumSettings
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="EnumerateSettingsFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>EnumerateSettingsExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set settings=$G(%EnsEnumSettings)
	Set size=$S(""=settings:0,1:$L(settings,","))
	Set qHandle=$G(qHandle)+1
	If qHandle>size Set Row="",AtEnd=1,qHandle=qHandle-1 Quit $$$OK
	#;
	Set name=$P(settings,",",qHandle)
	Set Row = ..GetSettingRow(name,$classname($this))
	Set AtEnd=qHandle=size
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="EvalInitialExpression">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pPropName:%String</FormalSpec>
<PublicList>tValue</PublicList>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Do %code.WriteLine("	Set $ZT=""Trap""")
	Do %code.WriteLine("    Set tValue=$Case(pPropName,")
	for i=1:1:%compiledclass.Properties.Count() {
		set property=%compiledclass.Properties.GetAt(i)
		Do %code.WriteLine("                     "_$$$quote(property.Name)_":"_property.InitialExpression_",")
	}
	Do %code.WriteLine("                     :"""")")
	Do %code.WriteLine("Exit")
	Do %code.WriteLine("	Quit tValue")
	Do %code.WriteLine("Trap")
	Do %code.WriteLine(" 	Set $ZT="""",tValue=""""")
	Do %code.WriteLine("	Goto Exit")
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Ens.StringRequest">
<Description>
Deprecated; use Ens.StringContainer</Description>
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Request</Super>
<System>4</System>
<TimeChanged>63920,75705</TimeChanged>
<TimeCreated>59297,36845.961</TimeCreated>

<Property name="StringValue">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Method name="%OnNew">
<FormalSpec>initvalue:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..StringValue=$g(initvalue)
	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>StringRequestDefaultData</DefaultData>
<Data name="StringRequestDefaultData">
<Subscript>"StringRequest"</Subscript>
<Value name="1">
<Value>StringValue</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Ens.StringResponse">
<Description>
Deprecated; use Ens.StringContainer</Description>
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Response</Super>
<System>4</System>
<TimeChanged>63920,75705</TimeChanged>
<TimeCreated>59297,36845.971</TimeCreated>

<Property name="StringValue">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Method name="%OnNew">
<FormalSpec>initvalue:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..StringValue=$g(initvalue)
	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>StringResponseDefaultData</DefaultData>
<Data name="StringResponseDefaultData">
<Subscript>"StringResponse"</Subscript>
<Value name="1">
<Value>StringValue</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Ens.Util.FunctionSet">
<Description>
This class contains a set of utility methods that can be used
by Business Rules, DTL transforms and the like.</Description>
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>Ensemble</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<System>4</System>
<TimeChanged>63920,75705</TimeChanged>
<TimeCreated>59879,49433.802717</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
/* NOTE: the names of these function arguments are used by
	the expression editor. DO NOT MODIFY THEM!
*/
]]></Content>
</UDLText>

<Method name="ToUpper">
<Description><![CDATA[
Convert a string supplied in <var>value</var> to UPPER case.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$ZCVT(value,"U")
]]></Implementation>
</Method>

<Method name="ToLower">
<Description><![CDATA[
Convert a string supplied in <var>value</var> to lower case.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$ZCVT(value,"L")
]]></Implementation>
</Method>

<Method name="Length">
<Description><![CDATA[
Get the length of a string. If <var>delimiter</var> is specified, return the number of substrings in <var>value</var>
based on the supplied <var>delimiter</var>.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String="",delimiter:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$S(""=delimiter:$Length(value),1:$Length(value,delimiter))
]]></Implementation>
</Method>

<Method name="Lookup">
<Description><![CDATA[
Look up the key specified by <var>value</var> in the lookup table specified by <var>table</var> and return the
lookup value associated with the input key value.
If the input key value is not found in the specified table, return <var>default</var>. If the <var>table</var> or the <var>value</var> argument is empty, the flag <var>defaultOnEmptyInput</var> determines
whether to return <var>default</var> or an empty string.
If <var>defaultOnEmptyInput</var> is:<ol>
<li>0 - Return empty string if <var>table</var> or <var>value</var> is empty. </li>
<li>1 - Return <var>default</var> if <var>table</var> is empty and <var>value</var> is not. Return empty string if <var>value</var> is empty. </li>
<li>2 - Return <var>default</var> if <var>value</var> is empty and <var>table</var> is not. Return empty string if <var>table</var> is empty. </li>
<li>3 - Return <var>default</var> if either <var>table</var> or <var>value</var> is empty. </li>
</ol> ]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>table:%String="",value:%String="",default:%String="",defaultOnEmptyInput:%Integer=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$S($L(table)&&$L(value):$G(^Ens.LookupTable(table,value),default), (table=""&&'(defaultOnEmptyInput#2))||(value=""&&'(defaultOnEmptyInput\2#2)):"", 1:default)
]]></Implementation>
</Method>

<Method name="Exists">
<Description><![CDATA[
Test if the key specified by <var>value</var> is defined within the lookup table specified by <var>table</var>.<br/>
Return true (1) if it is defined, and false (0) otherwise.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>table:%String="",value:%String=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$S(((table="")||(value="")):0,1:''$D(^Ens.LookupTable(table,value)))
]]></Implementation>
</Method>

<Method name="If">
<Description><![CDATA[
If <var>value</var> is true, returns the value of <var>true</var>
otherwise returns the value of <var>false</var>.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String="",true:%String="",false:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$S(value:true,1:false)
]]></Implementation>
</Method>

<Method name="Not">
<Description><![CDATA[
Perform a logical inversion. If <var>value</var> is true, return false, otherwise returns true.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA['value
]]></Implementation>
</Method>

<Method name="Matches">
<Description><![CDATA[
Tests if the given <var>value</var> matches the <var>pattern</var> given in the ? operator pattern syntax]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String,pattern:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<SqlName>Matches</SqlName>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[$S(""=$g(pattern):""=$g(value), 1:$g(value)?@$g(pattern))
]]></Implementation>
</Method>

<Method name="DoesNotMatch">
<Description><![CDATA[
Tests if the given <var>value</var> matches the <var>pattern</var> given in the ? operator pattern syntax.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String,pattern:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<SqlName>DoesNotMatch</SqlName>
<SqlProc>1</SqlProc>
<Implementation><![CDATA['$S(""=$g(pattern):""=$g(value), 1:$g(value)?@$g(pattern))
]]></Implementation>
</Method>

<Method name="Piece">
<Description><![CDATA[
Takes string <var>value</var>, returns the piece delimited by <var>delimiter</var> from <var>from</var> to <var>to</var>.
The default value for <var>delimiter</var> is "," and the default values for <var>from</var> and <var>to</var> are both 1.
See $Piece for further documentation.
An asterisk ('*') in <var>from</var> or <var>to</var> represents the number of delimited pieces in <var>value</var>.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String="",delimiter:%String=",",from:%Integer=1,to:%Integer=from</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$Piece(value,delimiter,$S(from'["*":from,1:$L(value,delimiter)+$TR(from,"*")),$S(to'["*":to,1:$L(value,delimiter)+$TR(to,"*")))
]]></Implementation>
</Method>

<Method name="Translate">
<Description><![CDATA[
Takes string <var>value</var>, translates each occurrance of a character
in string <var>identifier</var> to the character at the corresponding position in string
<var>associator</var> and returns the result.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String="",identifier:%String="",associator:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$TR(value,identifier,associator)
]]></Implementation>
</Method>

<Method name="Strip">
<Description><![CDATA[
Takes string <var>value</var>, removes characters matching categories specified in the <var>action</var>
template and the <var>remchar</var> string, excepting characters found in the <var>keepchar</var> string,
and returns the result.  See $ZStrip for further documentation.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String="",action:%String="",remchar:%String="",keepchar:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$ZStrip(value,action,remchar,keepchar)
]]></Implementation>
</Method>

<Method name="Pad">
<Description><![CDATA[
Takes string <var>value</var>, adds enough instances of <var>padchar</var> to lengthen the string to <var>padpos</var> characters.
If <var>padpos</var> is a negative value, the padding is prepended to the <var>value</var> string.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%String="",padpos:%Integer=10,padchar:%String=" "</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set newval=""
	If padpos<0 { for i=$L(value)+padpos:1:-1 { Set newval=padchar_newval } Set newval=newval_value }
	Else { for i=$L(value)+1:1:padpos	{ Set newval=padchar_newval } Set newval=value_newval }
	quit newval
]]></Implementation>
</Method>

<Method name="ConvertDateTime">
<Description><![CDATA[
Takes string <var>value</var> representing a date/time value in format <var>informat</var> and converts it to
a date/time string in format <var>outformat</var>. Any %f elements in <var>outformat</var> will be replaced with
the <var>outf</var> string. If the input string does not match <var>informat</var>, it will be output unchanged.
The default for both input and output formats is ODBC format (%Q) in the server's local timezone.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%String="",informat:%String="%Q",outformat:%String="%Q",outf:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set newval=##class(Ens.Util.Time).ConvertDateTime(value,informat,outformat,outf,.pSC,1)
	Quit:$$$ISERR(pSC) value
	Quit newval
]]></Implementation>
</Method>

<Method name="CurrentDateTime">
<Description><![CDATA[
Returns a string representing a date/time value in format <var>format</var>. The default format is ODBC format (%Q) in the server's local timezone.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>format:%String="%Q"</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[##class(Ens.Util.Time).FormatDateTime(format)
]]></Implementation>
</Method>

<Method name="Schedule">
<Description><![CDATA[
Evaluate the state of the given <var>ScheduleSpec</var> string, named Schedule or Rule at the moment given by <var>ODBCDateTime</var>. <br/>
If <var>ScheduleSpec</var> begins with '@' it is a Schedule name or Rule name, otherwise a raw Schedule string. <br/>
If <var>ODBCDateTime</var> is blank, the evaluation is done for the current time.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>ScheduleSpec:%String="",ODBCDateTime:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<SqlName>Schedule</SqlName>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[##class(Ens.Util.Schedule).Evaluate(ScheduleSpec, ODBCDateTime)
]]></Implementation>
</Method>

<Method name="Rule">
<Description><![CDATA[
Evaluate the return value of the rule specified in <var>RuleName</var> with the given <var>Context</var> object and the given <var>Activity</var> label for the Rule Log.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>RuleName:%String,Context:%RegisteredObject,Activity:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<SqlName>Rule</SqlName>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	Set tSC=##class(Ens.Rule.RuleDefinition).EvaluateRulesEx(RuleName, $G($$$JobSessionId), Context, $G(Activity,$S('$IsObject(Context):Context,1:$classname(Context))), .value, .reason)
	Quit:$$$ISERR(tSC) ""
	Quit value
]]></Implementation>
</Method>

<Method name="ReplaceStr">
<Description><![CDATA[
Takes string <var>value</var>, replaces occurrences of 
string <var>find</var> with the string <var>replace</var>
and returns the result.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String="",find:%String="",replace:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$replace^EnsUtil(.value,.find,.replace)
]]></Implementation>
</Method>

<Method name="replace">
<Description>
deprecated; legacy from class Ens.DataTransform</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String="",find:%String="",replace:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$replace^EnsUtil(.value,.find,.replace)
]]></Implementation>
</Method>

<Method name="Max">
<Description>
Returns the largest of the given values.</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%String="",v2:%String="",v3:%String="",v4:%String="",v5:%String="",v6:%String="",v7:%String="",v8:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tVal = ""

	// copy inputs into an array
	Set:value'="" arr(1) = +value
	Set:v2'="" arr(2) = +v2
	Set:v3'="" arr(3) = +v3
	Set:v4'="" arr(4) = +v4
	Set:v5'="" arr(5) = +v5
	Set:v6'="" arr(6) = +v6
	Set:v7'="" arr(7) = +v7
	Set:v8'="" arr(8) = +v8
	
	For i=1:1:8 {
		Set:$D(arr(i)) tVal = $S(tVal="":arr(i),tVal>arr(i):tVal,1:arr(i))
	}
	
	Quit tVal
]]></Implementation>
</Method>

<Method name="Min">
<Description>
Returns the smallest of the given values.</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%String="",v2:%String="",v3:%String="",v4:%String="",v5:%String="",v6:%String="",v7:%String="",v8:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tVal = ""

	// copy inputs into an array
	Set:value'="" arr(1) = +value
	Set:v2'="" arr(2) = +v2
	Set:v3'="" arr(3) = +v3
	Set:v4'="" arr(4) = +v4
	Set:v5'="" arr(5) = +v5
	Set:v6'="" arr(6) = +v6
	Set:v7'="" arr(7) = +v7
	Set:v8'="" arr(8) = +v8
	
	For i=1:1:8 {
		Set:$D(arr(i)) tVal = $S(tVal="":arr(i),tVal<arr(i):tVal,1:arr(i))
	}

	Quit tVal
]]></Implementation>
</Method>

<Method name="Round">
<Description><![CDATA[
Rounds off the given <var>value</var> to specified number of <var>digits</var> after the decimal point.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%Float,digits:%Integer=0</FormalSpec>
<ReturnType>%Float</ReturnType>
<Implementation><![CDATA[$FNumber(value,"",digits)
]]></Implementation>
</Method>

<Method name="SubString">
<Description><![CDATA[
Returns a substring of a given <var>value</var>; starting with position <var>start</var> until position <var>end</var>.
Empty <var>start</var> will return <var>value</var> irrespective of <var>end</var>.
Specifying <var>start</var> position and omitting <var>end</var> position will return from <var>start</var> to the end of the string.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String="",start:%Integer="",end:%Integer=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$S(start="":value,end="":$E(value,start,*),1:$E(value,start,end))
]]></Implementation>
</Method>

<Method name="In">
<Description><![CDATA[
Tests if the given <var>value</var> is among the <var>items</var> in a comma-delimited string.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%String,items:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set value=$g(value),items=$g(items)
	If ",,"=$E(items,*-2,*-1) { Set (sep1,sep2)=$E(items,*), items=$E(items,1,*-3) }
	ElseIf ",,"=$E(items,*-3,*-2) { Set sep1=$E(items,*-1), sep2=$E(items,*), items=$E(items,1,*-4) }
	Else { Set (sep1,sep2)="," }
	Quit $S(items="":0, 1:(sep1_items_sep2) [ (sep1_value_sep2))
]]></Implementation>
</Method>

<Method name="NotIn">
<Description><![CDATA[
Tests if the given <var>value</var> is not among the <var>items</var> in a comma-delimited string.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String,items:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA['..In(.value,.items)
]]></Implementation>
</Method>

<Method name="StartsWith">
<Description><![CDATA[
Tests if the given <var>value</var> starts with the given <var>string</var>.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String,string:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[($E($g(value),1,$L($g(string)))=$g(string))
]]></Implementation>
</Method>

<Method name="DoesNotStartWith">
<Description><![CDATA[
Tests if the given <var>value</var> does not start with the string in <var>start</var>.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String,start:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA['..StartsWith(.value, .start)
]]></Implementation>
</Method>

<Method name="Contains">
<Description><![CDATA[
Tests if the given <var>value</var> contains the given <var>substring</var>.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String,substring:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$S($g(value)'="":''$Find($g(value),$g(substring)),1:0)
]]></Implementation>
</Method>

<Method name="DoesNotContain">
<Description><![CDATA[
Tests if the given <var>value</var> contains the given <var>substring</var>.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String,substring:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA['..Contains(.value, .substring)
]]></Implementation>
</Method>

<Method name="Like">
<Description><![CDATA[
Tests if the given <var>value</var> satisfies a SQL Like comparison with the given </var>pattern</var> string. In SQL Like patterns, % matches 0 or more characters, and _ matches any single character.
Note that an escape character can be specified by appending "%%<esc>" to the pattern, e.g. "#%SYSVAR_#_%%%#" to match any value string that starts with "%SYSVAR" followed by any single character, an underscore, and anything else.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%String,pattern:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set value=$g(value),pattern=$g(pattern)
	If "%%"=$E(pattern,*-2,*-1) {
		Set esc=$E(pattern,*), pattern=$E(pattern,1,*-3)
	} Else { Set esc="" }
	
	Set patlen=$L(pattern),cospat="",(quotc,inquot)=0  For i=1:1:patlen { Set c=$E(pattern,i)
		If c=esc && (i<patlen) && 'quotc { Set quotc=1 }
		Else {
			Set:'quotc c=$Case(c,"%":".E","_":"1E",:c)
			If 1=$L(c) {
				Set:'inquot c="1"""_c, inquot=1
			} Else {
				Set:inquot c=""""_c, inquot=0 ; close quote
			}
			Set cospat=cospat_c, quotc=0
		}
	}
	Set:inquot cospat=cospat_"""" ; close quote
	Quit value?@cospat
]]></Implementation>
</Method>

<Method name="NotLike">
<Description><![CDATA[
Tests if the given <var>value</var> does not satisfy a SQL Like comparison with the given <var>pattern</var> string. In SQL Like patterns, % matches 0 or more characters, and _ matches any single character.
Note that an escape character can be specified by appending "%%<esc>" to the pattern, e.g. "#%SYSVAR_#_%%%#" to match any value string that starts with "%SYSVAR" followed by any single character, an underscore, and anything else.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String,pattern:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA['..Like(.value, .pattern)
]]></Implementation>
</Method>

<Method name="InFile">
<Description><![CDATA[
Tests if the given <var>value</var> is in the specified column in a table-formatted text file. <br/>
The <var>filenameSpec</var> argument consists of the filename followed by a comma and then a comma-separated list of additional parameters: <ol>
	<li>columnPos (default = 1) - means character pos if positional, column ordinal if delimited. </li>
	<li>rowSeparator (default = linefeed); negative value means row length if positional. </li>
	<li>columnSeparator (default = tab) - zero value means positional columns. </li>
	<li>columnWidth (default =0 meaning delimited not fixed-width) - means char count if positional. </li>
	<li>lineComment (default = none)</li>
	<li>stripPadChars (default = space,tab)</li></ol>]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%String,filenameSpec:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<SqlName>InFile</SqlName>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	Set value=$g(value),filenameSpec=$g(filenameSpec)
	#; parse args - comma-delimited with '\' escape char for comma,\t,\n,\r.
	Set filename=$P(filenameSpec,",")
	Set i=1,(pos,lastpos)=$L(filename)+2  For { Set pos=$F(filenameSpec,",",pos)  Quit:'pos
		#; process escapes
		Set escpos=lastpos,esc=""  For { Set escpos=$F($E(filenameSpec,1,pos-1),"\",escpos)  Quit:'escpos
			Set $E(filenameSpec,escpos-1)="", esc=$E(filenameSpec,escpos-1), pos=pos-(esc'=",")
			Set $E(filenameSpec,escpos-1)=$Case(esc,"t":$C(9),"n":$C(10),"r":$C(13),:esc)
		}
		Continue:","=esc&&(escpos>lastpos)
		Set args(i)=$E(filenameSpec,lastpos,pos-2), i=i+1
		Set lastpos=pos
	} Set args(i)=$E(filenameSpec,lastpos,$L(filenameSpec))

	Set columnId=$G(args(1))  Set:""=columnId columnId=1
	Set rowSeparator=$G(args(2))  Set:""=rowSeparator rowSeparator=$C(10)
	Set columnSeparator=$G(args(3))  Set:""=columnSeparator columnSeparator=$C(9)
	Set columnWidth=$G(args(4))  Set:""=columnWidth columnWidth=0
	Set lineComment=$G(args(5))
	Set stripPadChars=$G(args(6))  Set:""=stripPadChars stripPadChars=" "_$C(9)

	#; Call the version that accepts regular args
	Quit ..InFileColumn(.value, filename, columnId, rowSeparator, columnSeparator, columnWidth, lineComment, stripPadChars)
]]></Implementation>
</Method>

<Method name="InFileColumn">
<Description><![CDATA[
Tests if the given <var>value</var> is in the column specified by <var>columnId</var> in a table-formatted text 
file specified by <var>filename</var>. <br/>
<var>rowSeparator</var> indicates what character sequence separates the rows in the file, but if the value is negative,
the value indicates the character length of each row. <br/>
<var>columnSeparator</var> indicates the character sequence used to separate columns. If the value of this argument is 0, 
then the value in the file is determined by extracting <var>columnWidth</var> characters starting at the character 
position <var>columnId</var>.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%String="",filename:%String="",columnId:%Integer=1,rowSeparator:%String=$C(10),columnSeparator:%String=$C(9),columnWidth:%Integer=0,lineComment:%String="",stripPadChars=" "_$C(9)</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Quit:value="" 0
	Set file = ##class(%IO.FileStream).%New(filename)
	If '$IsObject(file)||'file.IsOpen Quit 0

	Set:rowSeparator>=0 file.LineTerminator=rowSeparator
	Set tCol=""  While 'file.AtEnd {
		If rowSeparator<0 { set tLine=file.Read(-rowSeparator) }
		Else { set tLine=file.ReadLine() }
		Continue:""=tLine
		Set tStrip=$S(""=stripPadChars:tLine,1:$ZStrip(tLine,"<>",stripPadChars))
		Continue:(""'=lineComment)&&(lineComment=$E(tStrip,1,$L(lineComment)))
		If columnSeparator=+columnSeparator&&(columnSeparator<=0) { Set tCol=$E(tLine,columnId,$S(columnWidth:columnId+columnWidth-1,1:$L(tLine))) }
		Else { Set tCol=$P(tLine,columnSeparator,columnId) }
		Set:(""'=lineComment&&(columnSeparator>0)) f=$F(tCol,lineComment), tCol=$S(f:$E(tCol,1,f-$L(lineComment)-1),1:tCol)
		Set:rowSeparator=$C(10)&&($E(tCol,$L(tCol))=$C(13)) $E(tCol,$L(tCol))=""
		Set:""'=stripPadChars tCol=$ZStrip(tCol,"<>",stripPadChars)
		Quit:value=tCol
	}
	Quit (value=tCol)
]]></Implementation>
</Method>

<Method name="NotInFile">
<Description><![CDATA[
Tests if the given <var>value</var> is not in the specified column in a table-formatted text file.
See InFile() for a more detailed description of the options for <var>filenameSpec</var>.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%String,filenameSpec:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<SqlName>NotInFile</SqlName>
<SqlProc>1</SqlProc>
<Implementation><![CDATA['..InFile(.value, .filenameSpec)
]]></Implementation>
</Method>

<Method name="IntersectsList">
<Description><![CDATA[
Tests if any item from the given source list in <var>value</var> appears in the target list <var>items</var>. <br/>
A separator can be specified for the format of each list. By default the items in each list are assumed to be enclosed in angle brackets, e.g. "&lt;Item1&gt;&lt;Item2&gt;&lt;Item3&gt;". <br/>
Note: if the target list has only a single item this function is essentially the same as the Contains function. If the source list has only a single item this function is essentially the same as the In function.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[value:%String,items:%String,SourceListSeparator:%String="><",TargetListSeparator:%String="><"]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<SqlName>IntersectsList</SqlName>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	Set SourceList=$g(value), TargetList=$g(items)
	If $L(SourceListSeparator)>1 {
		Set sPreSep=$E(SourceListSeparator,*), sPostSep=$E(SourceListSeparator,1)
		Set:sPreSep=$E(SourceList) SourceList=$E(SourceList,2,*-(sPostSep=$E(SourceList,*)))
	} Else { Set (sPreSep,sPostSep)="" }
	If $L(TargetListSeparator)>1 {
		Set tPreSep=$E(TargetListSeparator,*), tPostSep=$E(TargetListSeparator,1)
		Set:tPreSep=$E(TargetList) TargetList=$E(TargetList,2,*-(tPostSep=$E(TargetList,*)))
	} Else { Set (tPreSep,tPostSep)="" }
	Set found=0,pos=""  For i=1:1 { Quit:pos=0  Set prev=pos, pos=$F(SourceList,SourceListSeparator,prev)
		Set item=$S(pos=0:$E(SourceList,prev,*), 1:$E(SourceList,prev,pos-1-$L(SourceListSeparator)))
		Set tpos=""  For j=1:1 { Quit:tpos=0  Set tprev=tpos, tpos=$F(TargetList,TargetListSeparator,tprev)
			Set titem=$S(tpos=0:$E(TargetList,tprev,*), 1:$E(TargetList,tprev,tpos-1-$L(TargetListSeparator)))
			If item=titem Set found=1  Quit
		}
		Quit:found
	}
	Quit found
]]></Implementation>
</Method>

<Method name="DoesNotIntersectList">
<Description><![CDATA[
Tests if the given source list, <var>value</var>, does not contain any item that is contained in the target list, <var>items</var>.
See IntersectsList() for description.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[value:%String,items:%String,SourceListSeparator:%String="><",TargetListSeparator:%String="><"]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<SqlName>DoesNotIntersectList</SqlName>
<SqlProc>1</SqlProc>
<Implementation><![CDATA['..IntersectsList(.value,.items,.SourceListSeparator,.TargetListSeparator)
]]></Implementation>
</Method>
</Class>


<Class name="Ens.Util.IOLog">
<Description>
A header class that records raw Adapter Inputs and Outputs</Description>
<ClassType>persistent</ClassType>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,Ens.Util.BitmapPurge</Super>
<System>4</System>
<TimeChanged>63920,75705</TimeChanged>
<TimeCreated>59732,55448.319673</TimeCreated>

<Index name="Extent">
<Type>bitmap</Type>
<Extent>1</Extent>
</Index>

<Property name="AdapterClass">
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="HostClass">
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="ConfigName">
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="SourceMethod">
<Type>%String</Type>
<Parameter name="MAXLEN" value="40"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="TimeReceived">
<Type>Ens.DataType.UTC</Type>
</Property>

<Property name="TimeResponded">
<Type>Ens.DataType.UTC</Type>
</Property>

<Property name="Job">
<Type>%String</Type>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="Status">
<Description>
this property contains the error status if any</Description>
<Type>%Status</Type>
<InitialExpression>$$$OK</InitialExpression>
</Property>

<Property name="CorrespondingRequestId">
<Description>
The %Id() of the corresponding request</Description>
<Type>%Integer</Type>
</Property>

<Property name="SessionId">
<Type>%Integer</Type>
</Property>

<Property name="IsInbound">
<Type>%Boolean</Type>
</Property>

<Property name="InObjectClass">
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="InObject">
<Type>%RegisteredObject</Type>
</Property>

<Property name="OutObjectClass">
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="OutObject">
<Type>%RegisteredObject</Type>
</Property>

<Property name="Annotation">
<Type>%String</Type>
<Parameter name="MAXLEN" value="1200"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Index name="TimeReceived">
<Properties>TimeReceived</Properties>
</Index>

<Index name="SessionId">
<Properties>SessionId</Properties>
</Index>

<Index name="ConfigName">
<Type>bitmap</Type>
<Properties>ConfigName</Properties>
</Index>

<Parameter name="DOMAIN">
<Default>Ensemble</Default>
</Parameter>

<Method name="IsEmpty">
<Abstract>1</Abstract>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit 1
]]></Implementation>
</Method>

<Method name="%ShowContentsHead">
<Description>
Output HTML header information for IOLog object</Description>
<FormalSpec>pZenOutput:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	&html<<style type="text/css">
.headerBox {
	font-weight: bold;
}
.streamContent {
	background: white;
	padding: 5px;
	margin: 0;
}
</style>
>
	
	If ('pZenOutput) {
		&html<<style type="text/css">
body {
	background-image: url('images/ensback.png');
	background-repeat: repeat-x;
	background-color: white;
}
</style>
<link rel="stylesheet" type="text/css" href="#(##class(%CSP.Page).Link("/csp/sys/csputils.css"))#" title="Standard Style" />>
	}
	Else {
		&html<<style type="text/css">
table.AutoFormTable {
	font-size: 0.8em;
	border: 1px solid black;
}
td.AutoFormTableCaption, td.AutoFormTableValue {
	padding: 3px;
	border-bottom: 1px solid gray;
	border-right: 1px solid gray;
}
td.AutoFormTableCaption {
	font-weight: bold;
}
</style>>
	}
]]></Implementation>
</Method>

<Method name="%ShowContents">
<Description>
Output contents of IOLog object in HTML</Description>
<FormalSpec>pZenOutput:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	; Zen MessageContents pane performs auditing
	If 'pZenOutput Do $$$AuditViewMessage($$$Text("Message Browser"),0,$classname(), ..%Id())

	&html<<table cols="2" width="100%"><tr>>
	If ..IsInbound {
		Do ..showObject(1,pZenOutput)
		Do ..showObject(0,pZenOutput)
	}
	Else {
		Do ..showObject(0,pZenOutput)
		Do ..showObject(1,pZenOutput)
	}
	&html<</tr></table>>
	Quit
]]></Implementation>
</Method>

<Method name="showObject">
<Internal>1</Internal>
<FormalSpec>pIn:%Boolean,pZenOutput:%Boolean=0</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Set tObject = $select(pIn: ..InObject, 1: ..OutObject)
	Set tObjectClass = $select(pIn: ..InObjectClass, 1: ..OutObjectClass)
	Set tTitle = $select(pIn: $$$TextHTML("Input Data"), 1: $$$TextHTML("Output Data"))
	Set tNoObject = $select(pIn: $$$TextHTML("No Input Data"), 1: $$$TextHTML("No Output Data"))
	Set tTime = ""
	Set tTimeTitle = ""
	Set tTimeProp = ""
	If ..IsInbound {
		Set tTimeProp = $select(pIn: "TimeReceived", 1: "TimeResponded")
	}
	Else {
		Set tTimeProp = $select(pIn: "TimeResponded", 1: "TimeReceived")
	}
	If tTimeProp '= "" {
		Set tTime = $classmethod($classname($this),tTimeProp_"LogicalToDisplay",$property($this,tTimeProp))
		Set tTimeTitle = $select(tTimeProp = "TimeReceived": $$$TextHTML("Time Received"), 1: $$$TextHTML("Time Responded"))
	}
	Set tTime = $select(tTime = "": "&nbsp;", 1: $zconvert(tTime,"O","HTML"))
	
	&html<<td width="50%" valign="top">
	
	<div class="Text1 headerBox" style="margin: 3px;">#(tTitle)#:</div><hr/>
		<table class="AutoFormTable" border="0" cellspacing="0" width="100%" style="margin-left: 0px;">>
	If tObjectClass="" {
		&html<<tr class="AutoFormTableRow">
			<td class="AutoFormTableValue">
				<div class="Text1" style="margin: 3px;">#(tNoObject)#</div>
			</td></tr>>
	}
	ElseIf $IsObject(tObject) {
		; Zen MessageContents pane performs auditing
		If 'pZenOutput Do $$$AuditViewMessage($$$Text("Message Browser"),0,$classname(tObject), tObject.%Id())
		Set tDetailLink = $select(pZenOutput: "", ..CorrespondingRequestId = "": "", 1: ##class(%CSP.Page).Link("UtilEnsMsgDetails.csp?$FRAME=Info&$ID1="_..CorrespondingRequestId,,1))
		Set tDetailLink = $select(tDetailLink = "": "&nbsp;", 1: "<a href="""_tDetailLink_""">"_..CorrespondingRequestId_"</a>")
		&html<
			<tr class="AutoFormTableRow"><td class="AutoFormTableCaption">#(tTimeTitle)#</td><td class="AutoFormTableValue">#(tTime)#</td></tr>
			<tr class="AutoFormTableRow"><td class="AutoFormTableCaption">#($$$TextHTML("Object Class"))#</td><td class="AutoFormTableValue">#($select(tObjectClass="":"&nbsp;",1:$ZCVT(tObjectClass,"O","HTML")))#</td></tr>
			<tr class="AutoFormTableRow"><td class="AutoFormTableCaption">#($$$TextHTML("Corresponding Request Id"))#</td><td class="AutoFormTableValue">#(tDetailLink)#</td></tr>
			
		<tr><td colspan="2">>
		If tObject.%Extends("%Stream.Object"){
			If (tObject.Size=0) {
				Set tNoDataMsg = $$$TextHTML("NO DATA")
				&html<<pre class="streamContent">&lt;#(tNoDataMsg)#&gt;</pre>>
			}
			Else {
				Write !,"<pre class=""streamContent"">"
				Set currTab = $zu(96,18,0)
				Try {
					Do ##class(%SYS.NLS.Device).SetIO("HTML")
					Do tObject.OutputToDevice()
				}
				Catch {}
				Do ##class(%SYS.NLS.Device).SetIO(currTab)
				Write "</pre>"
			}
		}
		Else {
			&html<<iframe src="#(##class(%CSP.Page).Link("EnsPortal.MessageContents.cls?HeaderClass="_$classname()_"&HeaderId="_##class(%CSP.Page).EscapeURL(..%Id())))#&IOBody=#(pIn)#" width="100%" height="300px"></iframe>>
		}
		&html<</td></tr>>
	}
	Else {
		Set tError = $select(pIn: $$$TextHTML("Unable to display IO Log Input Data."), 1: $$$TextHTML("Unable to display IO Log Output Data."))
		&html<<div class="Text1" style="margin: 3px;">#(tError)#</div>>
	}
	&html<</table></td>>
	Quit
]]></Implementation>
</Method>

<Method name="GetRequestIOLogs">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRequestHeader:Ens.MessageHeader,*pIOLogArray:Ens.Util.IOLog</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tId=pRequestHeader.%Id()
	$$$ASSERT($IsObject(pRequestHeader) && (""'=pRequestHeader.SessionId))
	&sql(DECLARE CReq CURSOR FOR
		Select ID,CorrespondingRequestId into :tIOLogId,:tRequestId from Ens_Util.IOLog
		 where SessionId=:pRequestHeader.SessionId
	)
	&sql(OPEN CReq) For { &sql(FETCH CReq) Quit:SQLCODE  Continue:tRequestId'=tId
	 	Set tIOLog = ..%OpenId(tIOLogId,0,.tSC)  If '$IsObject(tIOLog)||$$$ISERR(tSC) $$$ASSERT(0_"Can't open Id "_tIOLogId) Continue
		Set pIOLogArray=$G(pIOLogArray)+1, pIOLogArray(pIOLogArray)=tIOLog
	} &sql(CLOSE CReq)
 	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetSessionIOLogs">
<ClassMethod>1</ClassMethod>
<FormalSpec>pSessionId:%CacheString,*pIOLogArray:Ens.Util.IOLog</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	&sql(DECLARE CSes CURSOR FOR Select ID Into :tIOLogId From Ens_Util.IOLog Where SessionId=:pSessionId)
	&sql(OPEN CSes) For { &sql(FETCH CSes) Quit:SQLCODE
	 	Set tIOLog = ..%OpenId(tIOLogId,0,.tSC)  If '$IsObject(tIOLog)||$$$ISERR(tSC) $$$ASSERT(0_"Can't open Id "_tIOLogId) Continue
		Set pIOLogArray=$G(pIOLogArray)+1, pIOLogArray(pIOLogArray)=tIOLog
	} &sql(CLOSE CSes)
 	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Purge">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pDeletedCount:%Integer,pDaysToKeep:%Integer=7,pDummy:%Boolean,pBitmapChunkLimit:%Integer=500</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Purge headerless IOLogObj in & out objects along with the IOLog entry
	New %tDoNotDeleteDate,%tClass,%tID Set %tID="", %tDoNotDeleteDate = $$$timeUTCHtoUTC($s($ztimezone'<0:($H-pDaysToKeep+1)_","_($ztimezone*60),1:($H-pDaysToKeep)_","_($ztimezone*60+86400)))
	Set tSC=$$$OK, SQLCODE=0, pDeletedCount=0
	&sql(DECLARE C1 CURSOR FOR
		Select ID, $Piece(x__ClassName,'~',$Length(x__ClassName,'~')-1) As Class Into :%tID,:%tClass
			From Ens_Util.IOLog Where TimeReceived < :%tDoNotDeleteDate)
	&sql(OPEN C1) For { &sql(FETCH C1)  Quit:SQLCODE
		#; %tClass will be empty when the object type is Ens.Util.IOLog, so catch this case
		If %tClass = "" Set %tClass = "Ens.Util.IOLog"
		Set tExists=$G(aClass(%tClass))
		If 0'=tExists {
			Set $zt="deleteError"
			Set tSC1=$zobjclassmethod(%tClass,"%DeleteId",%tID)
			Set:""=tExists aClass(%tClass)=1, tExists=1
			GoTo deleteErrora
deleteError Set:""=tExists aClass(%tClass)=0  Set:'$G(aClass(%tClass,"doneErr")) tSC1=$$$SystemError
deleteErrora Set $zt=""
			If $$$ISERR(tSC1)&&'$G(aClass(%tClass,"doneErr")) {
				Set tOK=$$$StatusEquals(tSC1,$$$DeleteObjectNotFound,$$$FileCanNotDelete,$$$NotAnInstanceError)
				If 'tOK { Set aClass(%tClass,"doneErr")=1, tSC=$$$ADDSC(tSC,tSC1)  $$$LOGWARNING("Failed to purge ID "_%tID_", Class='"_%tClass_"':"_$$$StatusDisplayString(tSC1)) }
			}
			Set pDeletedCount=pDeletedCount+$$$ISOK(tSC1)
		}
	} Set tCode=SQLCODE &sql(CLOSE C1) Set:'SQLCODE SQLCODE=tCode
	Set:SQLCODE&&(SQLCODE'=100) tSC=$$$ADDSC(tSC,$$$ERROR($$$EnsErrGeneral,"Purge error at ID "_%tID_"; SQLCODE = "_SQLCODE))
	Set tBitmapSC = ..PurgeBitmaps(pBitmapChunkLimit,.tDeletedChunks)
	Merge pDeletedCount("bitmaps") = tDeletedChunks
	Quit $$$ADDSC(tSC,tBitmapSC)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Ens.Util.IOLogD</DataLocation>
<DefaultData>IOLogDefaultData</DefaultData>
<IdLocation>^Ens.Util.IOLogD</IdLocation>
<IndexLocation>^Ens.Util.IOLogI</IndexLocation>
<StreamLocation>^Ens.Util.IOLogS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="IOLogDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>AdapterClass</Value>
</Value>
<Value name="3">
<Value>Annotation</Value>
</Value>
<Value name="4">
<Value>ConfigName</Value>
</Value>
<Value name="5">
<Value>CorrespondingRequestId</Value>
</Value>
<Value name="6">
<Value>HostClass</Value>
</Value>
<Value name="7">
<Value>InObject</Value>
</Value>
<Value name="8">
<Value>InObjectClass</Value>
</Value>
<Value name="9">
<Value>IsInbound</Value>
</Value>
<Value name="10">
<Value>Job</Value>
</Value>
<Value name="11">
<Value>OutObject</Value>
</Value>
<Value name="12">
<Value>OutObjectClass</Value>
</Value>
<Value name="13">
<Value>SessionId</Value>
</Value>
<Value name="14">
<Value>SourceMethod</Value>
</Value>
<Value name="15">
<Value>Status</Value>
</Value>
<Value name="16">
<Value>TimeReceived</Value>
</Value>
<Value name="17">
<Value>TimeResponded</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Ens.Util.IOLogger">
<Description>
Helper base class for BusinessService and BusinessOperation for raw IO logging</Description>
<Abstract>1</Abstract>
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Settings</Super>
<System>4</System>
<TimeChanged>63920,75705</TimeChanged>
<TimeCreated>59732,55448.648156</TimeCreated>

<Property name="ArchiveIO">
<Description>
If set, the Adapter will log in the Ensemble I/O archive each input and output communication it has with its external system.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Parameter name="SETTINGS">
<Default>ArchiveIO:Dev</Default>
</Parameter>

<Property name="IOLogEntry">
<Description>
This is the current entry in the IO Log, if any.</Description>
<Type>Ens.Util.IOLog</Type>
</Property>

<Method name="NewIOLogEntry">
<FormalSpec>pIsIncoming:%Boolean,pSC:%Status,pAnnotation:%String,pSourceMethod:%String,pSessionId:%Integer,pObj:%RegisteredObject</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
#define MAXCLASSNAME	(189+60)
	If '$IsObject(..IOLogEntry) {
		Set tParam=$S('$IsObject(..Adapter):"",1:..Adapter.%GetParameter("IOLOGENTRYCLASSNAME"))
		Set tDecl = $$$comMemberKeyGet($classname(),$$$cCLASSproperty,"IOLogEntry",$$$cPROPtype)
		Set tObjClassname=$S($IsObject(pObj):$classname(pObj), $L(pObj)<$$$MAXCLASSNAME:pObj, 1:"")
		If ""=tObjClassname||('$IsObject(pObj)&&'##class(%Dictionary.CompiledClass).%ExistsId(pObj)) {
			Set tObjClassname="%GlobalBinaryStream", tObj1=##class(%GlobalBinaryStream).%New()
			If $IsObject(tObj1) { Do tObj1.Write(pObj) Set pObj=tObj1 } Else { Set pObj=$$$NULLOREF }
		}
		Set tEntryClassname=$S(""'=tParam&&("Ens.Util.IOLog"'=tParam):tParam
								,"Ens.Util.IOLog"'=tDecl:tDecl
								,""=tObjClassname:"Ens.Util.IOLogStream"
								,$classmethod(tObjClassname,"%Extends","%FileStreamAdaptor"):"Ens.Util.IOLogFile"
								,$classmethod(tObjClassname,"%Extends","%Stream.Object"):"Ens.Util.IOLogStream"
								,$classmethod(tObjClassname,"%Extends","%IO.I.Stream"):"Ens.Util.IOLogStream"
								,$classmethod(tObjClassname,"%Extends","EnsLib.EDI.Segmented"):"Ens.Util.IOLogSegmentedObj"
								,$classmethod(tObjClassname,"%IsA","%Persistent"):"Ens.Util.IOLogObj"
								,1:"Ens.Util.IOLogXMLObj")
		If tEntryClassname=tDecl { Do ..IOLogEntryNewObject() }
		Else { Set ..IOLogEntry = $classmethod(tEntryClassname,"%New") }
		$$$ASSERT($IsObject(..IOLogEntry))

		Set ..IOLogEntry.IsInbound = pIsIncoming
		Set ..IOLogEntry.SourceMethod = pSourceMethod
		Set ..IOLogEntry.AdapterClass = $S($IsObject(..Adapter):$classname(..Adapter),1:"")
		Set ..IOLogEntry.HostClass = $classname()
		Set ..IOLogEntry.ConfigName = ..%ConfigName
		Set ..IOLogEntry.Job = $Job
		Set ..IOLogEntry.TimeReceived=$$$timeUTC
		If $IsObject(pObj) {
			If pObj.%Extends("%IO.I.Stream")||(pObj.%Extends("%Stream.Object")&&'pObj.%Extends("%GlobalBinaryStream")) {
				If pIsIncoming { Do ..IOLogEntry.InObject.CopyFrom(pObj) }
				Else  { Do ..IOLogEntry.OutObject.CopyFrom(pObj) }
				Do pObj.Rewind()
			} Else {
				If pIsIncoming { Set ..IOLogEntry.InObject = pObj }
				Else  { Set ..IOLogEntry.OutObject = pObj }
			}
		}
		#; Record the separators used for the initial document
		If ..IOLogEntry.%Extends("Ens.Util.IOLogSegmentedObj") {
			Try {
				#; For received documents, we use the Separators as recorded in the document; note that the object may not exist yet
				If pIsIncoming { Set ..IOLogEntry.InObjectSeparators = $select($IsObject(..IOLogEntry.InObject): ..IOLogEntry.InObject.Separators, 1: "") }
				#; Use $property() to guard against possible compilation errors in subclasses
				Else { Set ..IOLogEntry.OutObjectSeparators = $property($this,"Separators") }
			}
			Catch {}
		}
		Set:'pIsIncoming ..IOLogEntry.SessionId=pSessionId
		Set tCreated=1
	} Else { Set tCreated=0 }
	Set:$$$ISERR(pSC) ..IOLogEntry.Status=$$$ADDSC(..IOLogEntry.Status,pSC)
	Set:""'=pAnnotation ..IOLogEntry.Annotation = $S(""=..IOLogEntry.Annotation:"",1:..IOLogEntry.Annotation_" | ")_pAnnotation
	// No %Save() yet
	Quit tCreated
]]></Implementation>
</Method>

<Method name="SaveIOLogEntry">
<FormalSpec>pSC:%Status,pAnnotation:%String,pObj:%RegisteredObject</FormalSpec>
<Implementation><![CDATA[
	Set:$$$ISERR(pSC) ..IOLogEntry.Status=$$$ADDSC(..IOLogEntry.Status,pSC)
	Set:""'=pAnnotation ..IOLogEntry.Annotation = $S(""=..IOLogEntry.Annotation:"",1:..IOLogEntry.Annotation_" | ")_pAnnotation
	Set:""=..IOLogEntry.SessionId ..IOLogEntry.SessionId=..%SessionId
	Set:""=..IOLogEntry.CorrespondingRequestId&&$IsObject(..%RequestHeader) ..IOLogEntry.CorrespondingRequestId = ..%RequestHeader.%Id()
	If $IsObject(pObj) {
		If pObj.%Extends("%IO.I.Stream")||(pObj.%Extends("%Stream.Object")&&'pObj.%Extends("%GlobalBinaryStream")) {
			If ..IOLogEntry.IsInbound { Do ..IOLogEntry.OutObject.CopyFrom(pObj) }
			Else { Do ..IOLogEntry.OutObject.CopyFrom(pObj) }
			Do pObj.Rewind()
		} Else {
			If ..IOLogEntry.IsInbound { Set:'$IsObject(..IOLogEntry.OutObject) ..IOLogEntry.OutObject = pObj }
			Else { Set:'$IsObject(..IOLogEntry.InObject) ..IOLogEntry.InObject = pObj }
		}
	}
	Set:$IsObject(..IOLogEntry.InObject) ..IOLogEntry.InObjectClass = $classname(..IOLogEntry.InObject)
	Set:$IsObject(..IOLogEntry.OutObject) ..IOLogEntry.OutObjectClass = $classname(..IOLogEntry.OutObject)
	If ..IOLogEntry.IsEmpty(){
		Set tEmptyNote="Empty Log Entry, "_
			$S(..IOLogEntry.IsInbound:"perhaps your Service called OnProcessInput() with a NULL input.",
							1:"perhaps the Outbound Adapter in use doesn't implement IO Logging.")
		Set ..IOLogEntry.Annotation = $S(""=..IOLogEntry.Annotation:"",1:..IOLogEntry.Annotation_" | ")_tEmptyNote
	}
	#; Record the separators used for the response document
	ElseIf ..IOLogEntry.%Extends("Ens.Util.IOLogSegmentedObj") {
		Try {
			#; For services, we don't have a Separators property, so use Separators on document; also check
			If ..IOLogEntry.IsInbound {
				If $IsObject(..IOLogEntry.OutObject) { Set ..IOLogEntry.OutObjectSeparators = ..IOLogEntry.OutObject.Separators }
				If $IsObject(..IOLogEntry.InObject) && ("" = ..IOLogEntry.InObjectSeparators) { Set ..IOLogEntry.InObjectSeparators = ..IOLogEntry.InObject.Separators }
			}
			#; For received documents, we use the Separators as recorded in the document
			Else {
				If $IsObject(..IOLogEntry.InObject) { Set ..IOLogEntry.InObjectSeparators = ..IOLogEntry.InObject.Separators }
				If $IsObject(..IOLogEntry.OutObject) && ("" = ..IOLogEntry.OutObjectSeparators) { Set ..IOLogEntry.OutObjectSeparators = $property($this,"Separators") }
			}
		}
		Catch {}
	}
	Set ..IOLogEntry.TimeResponded=$$$timeUTC
	Do ..IOLogEntry.%Save()
]]></Implementation>
</Method>

<Method name="CloseIOLogEntry">
<FormalSpec>pSC:%Status,pAnnotation:%String,pObj:%RegisteredObject</FormalSpec>
<Implementation><![CDATA[
	Do ..SaveIOLogEntry(pSC, pAnnotation, pObj)
	Set ..IOLogEntry=$$$NULLOREF
]]></Implementation>
</Method>
</Class>


<Class name="Ens.Util.MessageBodyMethods">
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>%occInclude,Ensemble</IncludeCode>
<System>4</System>
<TimeChanged>63920,75705</TimeChanged>
<TimeCreated>59262,38857.096</TimeCreated>

<Method name="%GetContentType">
<Description><![CDATA[
This method is called by the Management Portal to determine
the content type that will be returned by the <method>%ShowContents</method>
method.
The return value is a string containing an HTTP content type.]]></Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If (..%Extends("%XML.Adaptor")) {
		Quit "text/xml"
	}
	Quit "text/html"
]]></Implementation>
</Method>

<Method name="%ShowContents">
<Description><![CDATA[
This method is called by the Management Portal to 
display a message-specific content viewer.<br>
This method displays its content by writing out to the current device.
The content should match the type returned by the 
<method>%GetContentType</method> method.<br>]]></Description>
<FormalSpec>pZenOutput:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	If (..%Extends("%XML.Adaptor")) {
		// show contents as XML
		&html<<?xml version="1.0" ?>
		<?xml-stylesheet href="ensemble/Ensemble_XMLDisplay.xsl" type="text/xsl" ?>
		<!-- type: #($classname())#  id: #(..%Id())# -->
>
		Set tWriter = ##class(%XML.Writer).%New()
		Set tWriter.NoXMLDeclaration = 1
		Set tWriter.Indent = 1
		Do tWriter.AddInstanceNamespace()
		Do tWriter.AddSchemaNamespace()
		Do tWriter.RootObject($this)
	}
	Else {
		&html<<div>There is no content viewer defined for this message type.</div>>
	}
]]></Implementation>
</Method>

<Method name="%DrawHTMLTable">
<Description><![CDATA[
This method is called by the Management Portal to 
display a message-specific content viewer.<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pObj:%RegisteredObject,&pID:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ##class(%CSP.Util.AutoFormDynamic).DrawHTMLTable(pObj, .pID)
]]></Implementation>
</Method>

<Method name="%DrawHTMLForm">
<Description><![CDATA[
This method is called by the Management Portal to 
display a message-specific content editor.<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pObj:%RegisteredObject,&pID:%String,pActionURL:%String="",&pButtons:%CSP.Util.FormButton,pTarget:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ##class(%CSP.Util.AutoFormDynamic).DrawHTMLForm(pObj, .pID, pActionURL, .pButtons, pTarget)
]]></Implementation>
</Method>

<Method name="%ProcessSubmit">
<Description><![CDATA[
This method is called by the Management Portal to 
display a message-specific content editor.<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pRequest:%CSP.Request,&pID:%String="",*pErrorMsg:%String]]></FormalSpec>
<ReturnType>%RegisteredObject</ReturnType>
<Implementation><![CDATA[
	#; construct body clone and get an id for it
	Merge tID=pID Set tObjId=$G(tID(1))
	If ""'=tObjId {
		Set tOldBody=..%OpenId(tObjId,,.tSC)  If $$$ISERR(tSC) Set pErrorMsg=$$$StatusDisplayString(tSC)  Quit $$$NULLOREF
		Set tOldBody=tOldBody.%ConstructClone()
		If tOldBody.%IsA("%Library.Persistent")||tOldBody.%IsA("%Stream.Object") Set tSC=tOldBody.%Save()  If $$$ISERR(tSC) Set pErrorMsg=$$$StatusDisplayString(tSC)  Quit $$$NULLOREF
		Set tSC=tOldBody.%GetSwizzleObject(0,.tOID)  If $$$ISERR(tSC) Set pErrorMsg=$$$StatusDisplayString(tSC)  Quit $$$NULLOREF
		Set tID(1)=$$$oidPrimary(tOID)
	}
	Quit ##class(%CSP.Util.AutoFormDynamic).ProcessSubmit(pRequest, .tID, .pErrorMsg, 0)
]]></Implementation>
</Method>

<Method name="%CompareContents">
<ClassMethod>1</ClassMethod>
<FormalSpec>pMsg1:Ens.MessageBody,pMsg2:Ens.MessageBody</FormalSpec>
<Implementation><![CDATA[
	&html<<frameset id="frameset" cols="50%,50%" frameborder=yes frameborder=1 border=2" >>
	&html<<frame src="#(##class(%CSP.Page).Link("EnsPortal.MessageContents.cls?HeaderClass="_##class(%CSP.Page).escapeURL($classname())_"&HeaderId="_$S($IsObject(pMsg1):##class(%CSP.Page).escapeURL(pMsg1.%Id()),1:"")))#" name="Left" MARGINWIDTH="0" MARGINHEIGHT="0" FRAMESPACING="0" FRAMEBORDER="1" SCROLLING="yes" >>
	&html<<frame src="#(##class(%CSP.Page).Link("EnsPortal.MessageContents.cls?HeaderClass="_##class(%CSP.Page).escapeURL($classname())_"&HeaderId="_$S($IsObject(pMsg2):##class(%CSP.Page).escapeURL(pMsg2.%Id()),1:"")))#" name="Right" MARGINWIDTH="0" MARGINHEIGHT="0" FRAMESPACING="0" FRAMEBORDER="1" SCROLLING="yes" >>
	&html<</frameset>>
]]></Implementation>
</Method>

<Method name="%ShowContentsHead">
<Description><![CDATA[
This method is called by the Management Portal to 
display a portion of the HEAD section of a
message-specific content viewer.<br>]]></Description>
<FormalSpec>pZenOutput:%Boolean=0</FormalSpec>
</Method>

<Method name="%OnTimeout">
<Description>
This method is called when this message has timed out
The time out moment happens when the timer response arrives, 
and the request is being removed from pending request list.
The timeout moment is not when the response arrives and is being marked as "discarded"</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Ens.Util.RequestBodyMethods">
<Description><![CDATA[
Helper & identification base class for Request message types]]></Description>
<Abstract>1</Abstract>
<Super>Ens.Util.MessageBodyMethods</Super>
<System>4</System>
<TimeChanged>63120,52843.963687</TimeChanged>
<TimeCreated>59262,38857.096</TimeCreated>
</Class>


<Class name="Ens.VDoc.Interface">
<Description>
Common interface used as a base class for all Virtual Document types</Description>
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>Ensemble,%systemInclude</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<System>4</System>
<TimeChanged>63920,75705</TimeChanged>
<TimeCreated>59759,56996.101215</TimeCreated>

<Parameter name="DOMAIN">
<Description>
Use our own domain for localization</Description>
<Default>Ensemble</Default>
</Parameter>

<Parameter name="DOCCLASSNAME">
<Description>
Compact descriptive name for this subclass of document</Description>
</Parameter>

<Parameter name="DOCCLASSFULLNAME">
<Description>
Full descriptive name for this subclass of document</Description>
</Parameter>

<Property name="RawContent">
<Description>
The raw text content of the document. Note that this is a truncated version suitable for use in SQL results and visual inspection,
but not a complete or definitive representation of the document.</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<ReadOnly>1</ReadOnly>
<Parameter name="MAXLEN"/>
</Property>

<Property name="DocType">
<Description>
Reference to associated Schema Id</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="128"/>
</Property>

<Property name="DocTypeCategory">
<Description>
the category portion of the DocType</Description>
<Type>%String</Type>
<Transient>1</Transient>
</Property>

<Property name="DocTypeName">
<Description>
Stored raw document type name ; the secondary type name portion of the DocType</Description>
<Type>%String</Type>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
<Parameter name="MAXLEN" value="50"/>
</Property>

<Property name="Name">
<Description>
Raw type name of document as declared in document content</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {Name}="subclass responsibility" </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="TypeVersion">
<Description>
Raw type version of document if declared in document content</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {TypeVersion}="" </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Identifier">
<Description>
Unique document identification string found in document content</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {Identifier}="subclass responsibility" </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="TimeCreated">
<Description>
The timestamp of when this Document object was first instantiated</Description>
<Type>Ens.DataType.UTC</Type>
<InitialExpression>$$$timeUTC</InitialExpression>
</Property>

<Property name="Source">
<Description>
Source of document (e.g. filename)</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="250"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="IsMutable">
<Description>
We clear this property to prevent saving or modifying of already-saved document objects</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<UDLText name="T">
<Content><![CDATA[/* Note: if no Index OriginalDocId is declared on this property in your subclass, the Trace diagram will not display corresponding messages */
]]></Content>
</UDLText>

<Property name="OriginalDocId">
<Description>
If this document is a response to another document of the same type, this property contains the Id of the original document</Description>
<Type>%String</Type>
<Parameter name="COLLATION" value="EXACT"/>
<Parameter name="MAXLEN"/>
</Property>

<Property name="UserValues">
<Description>
An array of strings for storing user defined attribute values. Value key names beginning with % are reserved for Ensemble use.</Description>
<Type>%String</Type>
<Collection>array</Collection>
<Parameter name="MAXLEN"/>
</Property>

<Parameter name="DOCTYPES">
<Description><![CDATA[
If provided, this parameter defines a comma-delimited, default list of
document types for a document class.<br>
This provides an alternate mechanism to overriding the
EnumerateDocTypes query]]></Description>
<Type>String</Type>
</Parameter>

<Method name="TypeVersionGet">
<Description>
Subclasses should override this if the version can be gotten from the document content</Description>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[""
]]></Implementation>
</Method>

<Method name="IsMutableSet">
<FormalSpec>pMutable:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsMutable&&pMutable $$$ERROR($$$EnsErrGeneral,"Cannot make immutable Object mutable again")
	Set i%IsMutable=''pMutable
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="PokeDocType">
<FormalSpec>pDocType:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%DocType=pDocType
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetContentArray">
<Description><![CDATA[
Returns array of properties that make up the <i>contents</i>
of this object.<br>
This method in implemented within the document class.<br>
The content array is in the form:<br>
	pContents(n,"type")="%String"<br>
	pContents(n,"name")="Field"<br>
	pContents(n,"alias")=alias code<br>
If pContents(n) is non-zero then the property is a composite type with<br>
sub-properties.  The sub-properties are indexed with a similar structure under<br>
    pContents(n,m) where m is the index of the subtype property.<br>]]></Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pContents,pMode:%String,pDocType:%String,pLevel:%Integer,pIncludeBase:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$EnsErrGeneral,("Subclass Responsibility"))
]]></Implementation>
</Method>

<Query name="EnumerateDocTypes">
<Description><![CDATA[
Returns a list of available DocTypes for the document class. <br/>
The DocType is returned as the first column in the result set. <br/>
The <var>Category</var> parameter can be used to restrict the list. <br/>
If <var>Category</var> is: <br/>
 0 - return only DocTypes in standard categories <br/>
 + - return only DocTypes in user-defined categories <br/>
 empty - return DocTypes from all categories <br/>
 a category name - return only DocTypes in the named category <br/>
 a partial name suffixed with '%' - return only DocTypes in categories matching the partial category name <br/>
 other - return nothing <br/>
If <var>IncludeBase</var> is: <br/>
 0 - return only DocTypes defined in the current schema category itself <br/>
 1 - return all DocTypes in the current schema category's base category in addition to those defined in the current category itself <br/>
This query can be overridden in a subclass.<br/>
This default implementation returns the type list specified by the
DOCTYPES parameter (or a dummy result containing 1 empty row).]]></Description>
<Type>%Query</Type>
<FormalSpec>Category:%String="",IncludeBase:%Boolean=0</FormalSpec>
<Parameter name="CONTAINID" value="0"/>
<Parameter name="ROWSPEC" value="Type:%String"/>
</Query>

<Method name="EnumerateDocTypesExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,Category:%String,IncludeBase:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set qHandle=0
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="EnumerateDocTypesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>EnumerateDocTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i=$I(qHandle)
	If qHandle>$L(..#DOCTYPES,",") Set Row="",AtEnd=1 Quit $$$OK
	Set Row=$LB($P(..#DOCTYPES,",",i))
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="EnumerateDocTypesClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateDocTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill qHandle
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="EnumerateTypeCategories">
<Description><![CDATA[
Returns a list of document type schema categories for the document class.<br/>
The <var>Standard</var> parameter can be used to restrict the list.<br/>
If <var>Standard</var> is: <br/>
 0 - return only standard categories <br/>
 + - return only user-defined categories <br/>
 empty - return all categories <br/>
 a partial category name - return only categories starting with the given category name part<br/>
 other - return nothing <br/>
This query can be overridden in a subclass.<br/>
This default implementation returns no rows.]]></Description>
<Type>%Query</Type>
<FormalSpec>Standard:%String=""</FormalSpec>
<Parameter name="CONTAINID" value="0"/>
<Parameter name="ROWSPEC" value="Category:%String,Description:%String,IsStandard:%Boolean,Base:%String"/>
</Query>

<Method name="EnumerateTypeCategoriesExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,Standard:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set qHandle=0
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="EnumerateTypeCategoriesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>EnumerateTypeCategoriesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Set Row="",AtEnd=1 Quit $$$OK
]]></Implementation>
</Method>

<Method name="EnumerateTypeCategoriesClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateTypeCategoriesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill qHandle
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="EnumerateVDocs">
<Description><![CDATA[
Returns a list of VDoc classes that extend Ens.VDoc.Interface.<br/>
The <var>Persistent</var> and <var>Abstract</var> parameters can be used to restrict the list.<br/>
If <var>Persistent</var> is: <br/>
 0 - return persistent and non-persistent subclasses <br/>
 1 - return only persistent subclasses <br/>
If <var>Abstract</var> is: <br/>
 0 - return only non-abstract subclasses <br/>
 1 - return both abstract and non-abstract subclasses <br/>
Note that the default value for Persistent is 1.<br/>]]></Description>
<Type>%Query</Type>
<FormalSpec>Persistent:%Boolean=1,Abstract:%Boolean=0</FormalSpec>
<Parameter name="CONTAINID" value="0"/>
<Parameter name="ROWSPEC" value="Name:%String,Persistent:%Boolean,Abstract:%Boolean"/>
</Query>

<Method name="EnumerateVDocsExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,Persistent:%Boolean=1,Abstract:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill qHandle
	Set qHandle=""
	Set tRS=##class(%ResultSet).%New("%Dictionary.ClassDefinition:SubclassOf")
	Set tSC = tRS.Execute("Ens.VDoc.Interface")
	Quit:$$$ISERR(tSC) tSC
	While tRS.Next() {
		Set tName=tRS.Get("Name")
		Set tDef = ##class(%Dictionary.CompiledClass).%OpenId(tName)
		If tDef.Abstract Set tIsPersistent = 0, tAbstract = 1
		Else  Set tIsPersistent=$zobjclassmethod(tName,"%Extends","%Persistent"), tAbstract = 0
		; Comparisons to ensure we include non-persistent classes if Persistent=0, and Abstract classes if Abstract=1
		If (tIsPersistent >= Persistent) && (tAbstract <= Abstract) Set qHandle($i(qHandle))=$lb(tName,tIsPersistent,tAbstract)
	}
	Set qHandle=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="EnumerateVDocsFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>EnumerateVDocsExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set qHandle=$o(qHandle($g(qHandle)))
	If qHandle="" Set AtEnd=1 Quit $$$OK
	Set Row = $g(qHandle(qHandle))
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="EnumerateVDocsClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateVDocsExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill qHandle
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetValueAt">
<Description><![CDATA[
Return the value of the designated virtual property.<br>
<var>pPropertyPath</var> contains a text expression representing the address within the document of the value of interest.<br>
<var>pFormat</var> contains additional context that may be used to influence the form of the result value<br>
If no value can be found matching <var>pPropertyPath</var> in the current document an empty string is returned and output argument <var>pStatus</var> returns status information explaining the failure<br>
This is implemented by the document subclass.]]></Description>
<Abstract>1</Abstract>
<FormalSpec>pPropertyPath:%String,pFormat:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pStatus=$$$ERROR($$$EnsErrGeneral,("Subclass Responsibility"))
	Quit ""
]]></Implementation>
</Method>

<Method name="SetValueAt">
<Description><![CDATA[
Set the value of the designated virtual property.<br>
<var>pValue</var> contains the value to set.<br>
<var>pPropertyPath</var> contains a text expression representing the address within the document of the value of interest.<br>
<var>pKey</var> contains an optional key value or a set of comma-separated key values to be used as array indices where empty array index placeholders are present in <var>pPropertyPath</var>.<br>
<var>pAction</var> contains an action code: "set", "clear", "append", etc. <br>]]></Description>
<Abstract>1</Abstract>
<FormalSpec>pValue:%String,pPropertyPath:%String,pAction:%String="set",pKey:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$EnsErrGeneral,("Subclass Responsibility"))
]]></Implementation>
</Method>

<Method name="CopyValues">
<Description><![CDATA[
Copy a whole set of values from source to target when iteration is implied between 2 VDocs
<var>pSourcePath</var> contains the property path to the source set<br>
<var>pTargetPath</var> contains the property path to the target set<br>
<var>pAction</var> contains an action code: "set", etc..<br>
<var>pKey</var> contains an optional key value or a set of comma-separated key values to be used as array indices where empty array index placeholders are present in <var>pPropertyPath</var>.<br>]]></Description>
<FormalSpec>pSource:Ens.VDoc.Interface,pSourcePath:%String,pTargetPath:%String,pAction:%String,pKey:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$EnsErrGeneral,("Subclass Responsibility"))
]]></Implementation>
</Method>

<Method name="GetNextIndex">
<Description>
Return the next </Description>
<FormalSpec><![CDATA[pPath:%String,pIndex:%String="",&pStatus:%Status=$$$OK]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pStatus=$$$ERROR($$$EnsErrGeneral,("Subclass Responsibility"))
	Quit ""
]]></Implementation>
</Method>

<Method name="GetAlias">
<Description>
This method computes the Alias string for a property name, given the property's node in the Content Array.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pContentArrayName:%String,pArrayPos:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ""
]]></Implementation>
</Method>

<Method name="Validate">
<Abstract>1</Abstract>
<FormalSpec>pValidationSpec:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$EnsErrGeneral,("Subclass Responsibility"))
]]></Implementation>
</Method>

<Method name="DrawHTMLForm">
<Description><![CDATA[
Override standard DrawHTMLForm method
Draw an HTML form for this form object.<BR>
<var>pObj</var> is an instance of the form object that
provides the initial values for the form.<BR>
<var>pActionURL</var> is the URL to submit this form to.<BR>
<var>pButtons</var> is an array of submit buttons to display for the form. If 
not provided, the default <I>Save</I> and <I>Cancel</I> buttons are shown.
<var>pButtons</var> is an integer-subscripted array of <class>FormButton</class> objects.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pObj:%RegisteredObject,&pID:%String,pActionURL:%String="",&pButtons:%CSP.Util.FormButton,pTarget:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	
	// standard form header
	&html<<form action="#(pActionURL)#" method="POST" name="theForm" target="#(pTarget)#">
		<input type="hidden" name="$CLASS" value="#($classname())#">
		<input type="hidden" name="$FRAME" value="#(pTarget)#">>

	Set id = $O(pID(""))
	While (id '= "") {
		&html<<input type="hidden" name="$ID#(id)#" value="#(($ZCVT(pID(id),"O","HTML")))#">>
		Set id = $O(pID(id))
	}
	
	// loop over document contents
	Set tSC = ..DrawHTMLContentsForm(pObj,.pID)

	// standard form buttons
	&html<<br><table class="AutoForm">
		<tr><td class="AutoFormLabel">&nbsp;</td>
			<td class="AutoFormButton">>
	Do ..DrawFormButtons(.pButtons)
	&html<</td></tr></table>
		</form>>

	Quit tSC
]]></Implementation>
</Method>

<Method name="DrawHTMLContentsForm">
<Description>
Specialized HTML generation method to display the body of a form
to display/edit a document-style message.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pObj:%RegisteredObject,&pID:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// add code to display HTML here...
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="DrawFormButtons">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pButtons:%CSP.Util.FormButton]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetManagerLinks">
<Description>
Returns an array of links to manager pages for this type of VDoc; item 0 is the family description
The output array is subscripted first by item number, and below that by "name","page" and "desc"</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pColumns</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit 0 ; Subclass responsibility
]]></Implementation>
</Method>

<Method name="GetNewManagerLinks">
<Description>
Returns an array of links to manager pages for this type of VDoc; item 0 is the family description
The output array is subscripted first by item number, and below that by "name","page" and "desc"</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pColumns</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit 0 ; Subclass responsibility
]]></Implementation>
</Method>

<Method name="getTestNewArg">
<Description>
Return a suitable argument to pass to %New() to create a test object for the test described by the arguments.
Example: getTestNewArg("DTL","existing","Test.DTL.DTLExisting") as passed from the DTL test wizard.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestContext:%String,pTestOption:%String,pTestName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#; $List(3) is 'Source' for VDoc %OnNew() non-Object argument
	Quit $LB(,,"test "_pTestContext_$C(13,10)_pTestOption_$C(13,10)_pTestName)
]]></Implementation>
</Method>
</Class>


<Routine name="EnsConstants" type="INC" timestamp="63920,75708"><![CDATA[
#;
#; constants for Production state
#;
#define eProductionStateUnknown        0
#define eProductionStateRunning        1
#define eProductionStateStopped        2
#define eProductionStateSuspended      3
#define eProductionStateTroubled       4
#define eProductionStateNetworkStopped 5
#; constants for Production state on non-primary mirror members
#define eProductionStateBackupUnknown        (-10)
#define eProductionStateBackupRunning        (-$$$eProductionStateRunning)
#define eProductionStateBackupStopped        (-$$$eProductionStateStopped)
#define eProductionStateBackupSuspended      (-$$$eProductionStateSuspended)
#define eProductionStateBackupTroubled       (-$$$eProductionStateTroubled)
#define eProductionStateBackupNetworkStopped (-$$$eProductionStateNetworkStopped)
#;
#; constants for EnsJobStatus
#;
#define eJobStatusStarting    "starting"
#define eJobStatusRegistered  "registered"
#define eJobStatusVisiting    "visiting"
#define eJobStatusRunning     "running"
#define eJobStatusDeQueuing   "dequeuing"
#define eJobStatusQuiescent   "quiescent"
#define eJobStatusError       "error"
#define eJobStatusHalted      "halted"
#define eJobStatusTerminated  "terminated"
#;
#; constants for Job Request
#;
#define eJobRequestQuiescent "quiescent"
#define eJobRequestTerminate "terminate"
#define eJobRequestAbort     "abort"
#define eJobRequestSuspend   "suspend"
#;
#; constants for Business Host Type
#;
#define eHostTypeUnknown   0
#define eHostTypeService   1
#define eHostTypeProcess   2
#define eHostTypeOperation 3
#define eHostTypeActor     4
#;
#; constants for Ens.MessageHeader:Priority
#;
#define eMessagePriorityHighSync 1
#define eMessagePrioritySync     2
#define eMessagePrioritySimSync  4
#define eMessagePriorityAsync    6
#;
#; -- old Ens.MessageHeader:Priority values - since renamed for clarity and renumbered in a back-compatible way --
#;define eMessagePriorityRealTime 1
#;define eMessagePriorityHigh     2
#;define eMessagePriorityNormal   3
#;define eMessagePriorityLow      4
#;
#; constants for Ens.MessageHeader:Status
#; 
#define eMessageStatusCreated   1
#define eMessageStatusQueued    2
#define eMessageStatusDelivered 3
#define eMessageStatusDiscarded 4
#define eMessageStatusSuspended 5
#define eMessageStatusDeferred  6
#define eMessageStatusAborted   7
#define eMessageStatusError     8
#define eMessageStatusCompleted 9
#;
#; constants for Ens.MessageHeader:Type
#;
#define eMessageTypeRequest   1
#define eMessageTypeResponse  2
#define eMessageTypeTerminate 3
#;
#; constants for Ens.MessageHeader:Invocation
#;
#define eMessageInvocationQueue  1
#define eMessageInvocationInProc 2
#;
#; constants used for Ens.BusinessProcess:RepliedStatus
#;
#define eRepliedStatusNotCalled    1
#define eRepliedStatusConstructed  2
#define eRepliedStatusSent         3
#define eRepliedStatusDeferred     4
#;
#; constants for Ens.Util.Log:Type
#;
#define eLogTypeAssert  1
#define eLogTypeError   2
#define eLogTypeWarning 3
#define eLogTypeInfo    4
#define eLogTypeTrace   5
#define eLogTypeAlert   6
#;
#; constants for Ens.BusinessProcess:RunStatus
#;
#define eRunStatusRunning   1
#define eRunStatusCompleted 2
#define eRunStatusWaiting   3
#define eRunStatusErrored   4
#;
#; constants used for Ens.BP.CodeContext
#;
#define eCodeContextNone      1
#define eCodeContextProcess   2
#define eCodeContextRequest   3
#define eCodeContextResponse  4
#;
#; constants used for BPL/DTL language specification
#; 
#define objectscript "objectscript"
#define basic        "basic" 
#;
#; Monitor properties (subscripts for HostMonitor and JobMonitor globals)
#;
#define eMonitorLastActivity              "%LastActivity"
#define eMonitorStatus                    "%Status"
#define eMonitorMethod                    "%Method"
#define eMonitorRetry                     "%Retry"
#define eMonitorCount                     "%Count"
#define eMonitorConnected                 "%Connected"
#define eMonitorJob                       "%Job"
#;
#; JobStatus properties (subscripts for EnsJobStatus global)
#;
#; Note: $$$EnsJobStatus values reflect the "identity" of the job, i.e. what the job was launched for.
#; $$$EnsJobMonitor values reflect the transient "use" of a job, i.e. what config item is running or
#;  has run in the job.
#; ConfigItems running "InProc" will use the calling job's context, but their $$$JobMonitor values
#;  will be logged under their ConfigName in the Monitor global and the hosting Job Id. For this reason
#;  it is possible to have several ConfigItems under the Monitor global containing JobStatus entries for
#;  the same Job Id.
#; Also, BP's log their instances to JobMonitor as if the instance ID were a Job Id. This will not
#;  collide with real Job Ids because of the $$$SystemName: prefix on the real ones.
#;
#define eJobStatus                    "%Status"
#define eJobDetail                    "%Detail"
#define eJobSessionId                 "%SessionId"
#define eJobStartConfigName           "%StartConfigName"
#define eJobGuestConfigName           "%GuestConfigName"
#define eJobIsTempJob                 "%IsTempJob"
#define eJobForeground                "%Foreground"
#define eJobIsDead                    "%IsDead"
#define eJobRegTime                   "%RegTime"
#;
#; Generic default SOAP fault code for Ensemble SOAP service WebMethod errors
#;
#define EnsFAULTMethod                "SOAP-ENV:Method"
#;
#define eConfigSettingValueTypeReadOnly    0
#define eConfigSettingValueTypeProduction  1
#define eConfigSettingValueTypeSystem      2
#define eConfigSettingValueTypeProperty    3
#define eConfigSettingValueTypeRegistry    4
#;
#; constants for Archive Manager
#;
#define archiveArchiveData   1
#define archivePurgeHeader   2
#define archivePurgeBody     4
#;
#; constants for Ensemble Auditing Events
#;
#define auditModifyProductionConfig  ##class(%EnsembleMgr).defineAuditModifyProductionConfiguration()
#define auditModifySchema            ##class(%EnsembleMgr).defineAuditModifySchema()
#define auditStartStopProduction     ##class(%EnsembleMgr).defineAuditStartStopProduction()
#define auditViewMessageContents     ##class(%EnsembleMgr).defineAuditViewMessageContents()
#;
#; constants for Ens.MessageHeader:Banked flags
#;
#define eMsgBankHeader			1
#define eMsgBankBody			2
#define eMsgBankSearchTable		4
#define eMsgBankFlagged			8
#;
#; constants for Managed Alert Actions (Ens.DataType.ManagedAlertAction)
#;
#define eAlertActionAssign				1
#define eAlertActionOpenChange			2
#define eAlertActionEscalationChange	4
#define eAlertActionNextActionChange	8
#define eAlertActionSendUpdate			16
#define eAlertActionReoccurrence		32
#;
#; constants for Managed Alert Notification types (Ens.DataType.AlertNotification)
#;
#define eAlertNotificationRequest			0
#define eAlertNotificationReminder			1
#define eAlertNotificationEscalationChange	2
#;
#; constants for Rule Log Type (Ens.DataType.RuleLogType)
#;
#define eRuleLogTypeError			"e"
#define eRuleLogTypeReturn			"r"
#define eRuleLogTypeUserDebug		"d"
#define eRuleLogTypeConditionDebug	"c"
#;
]]></Routine>


<Routine name="EnsErrors" type="INC" timestamp="63920,78661"><![CDATA[
#define EnsErrAdapterAlreadyConnected              "<Ens>ErrAdapterAlreadyConnected"
#define EnsErrBPCanNotOpen                         "<Ens>ErrBPCanNotOpen"
#define EnsErrBPCancelled                          "<Ens>ErrBPCancelled"
#define EnsErrBPLASyncTimeoutMustBeOnSync          "<Ens>ErrBPLASyncTimeoutMustBeOnSync"
#define EnsErrBPLBadExpressionValue                "<Ens>ErrBPLBadExpressionValue"
#define EnsErrBPLEnumeration                       "<Ens>ErrBPLEnumeration"
#define EnsErrBPLInvalidContextSuperclass          "<Ens>ErrBPLInvalidContextSuperclass"
#define EnsErrBPLInvalidLoopContext                "<Ens>ErrBPLInvalidLoopContext"
#define EnsErrBPLLabelNameNotUnique                "<Ens>ErrBPLLabelNameNotUnique"
#define EnsErrBPLLabelNotInScope                   "<Ens>ErrBPLLabelNotInScope"
#define EnsErrBPLNodeMissing                       "<Ens>ErrBPLNodeMissing"
#define EnsErrBPLNodeValidation                    "<Ens>ErrBPLNodeValidation"
#define EnsErrBPLThrownFault                       "<Ens>ErrBPLThrownFault"
#define EnsErrBPTerminated                         "<Ens>ErrBPTerminated"
#define EnsErrBusinessDispatchNameNotRegistered    "<Ens>ErrBusinessDispatchNameNotRegistered"
#define EnsErrCanNotAcquireJobLock                 "<Ens>ErrCanNotAcquireJobLock"
#define EnsErrCanNotAcquireJobRootLock             "<Ens>ErrCanNotAcquireJobRootLock"
#define EnsErrCanNotAcquireLaunchLock              "<Ens>ErrCanNotAcquireLaunchLock"
#define EnsErrCanNotAcquireRuntimeLock             "<Ens>ErrCanNotAcquireRuntimeLock"
#define EnsErrClassNotConcrete                     "<Ens>ErrClassNotConcrete"
#define EnsErrClassNotDefined                      "<Ens>ErrClassNotDefined"
#define EnsErrClassNotDerived                      "<Ens>ErrClassNotDerived"
#define EnsErrConfigDisabled                       "<Ens>ErrConfigDisabled"
#define EnsErrConfigItemNotFound                   "<Ens>ErrConfigItemNotFound"
#define EnsErrDTLCannotBeCompiled                  "<Ens>ErrDTLCannotBeCompiled"
#define EnsErrDTLEnumeration                       "<Ens>ErrDTLEnumeration"
#define EnsErrDTLNodeValidation                    "<Ens>ErrDTLNodeValidation"
#define EnsErrDTSMultiSignature                    "<Ens>ErrDTSMultiSignature"
#define EnsErrDTSSignature                         "<Ens>ErrDTSSignature"
#define EnsErrDocImport                            "<Ens>ErrDocImport"
#define EnsErrException                            "<Ens>ErrException"
#define EnsErrFTPConnectFailed                     "<Ens>ErrFTPConnectFailed"
#define EnsErrFTPDeleteFailed                      "<Ens>ErrFTPDeleteFailed"
#define EnsErrFTPDirectoryChangeFailed             "<Ens>ErrFTPDirectoryChangeFailed"
#define EnsErrFTPGetDirectoryFailed                "<Ens>ErrFTPGetDirectoryFailed"
#define EnsErrFTPGetFailed                         "<Ens>ErrFTPGetFailed"
#define EnsErrFTPListFailed                        "<Ens>ErrFTPListFailed"
#define EnsErrFTPLogoutFailed                      "<Ens>ErrFTPLogoutFailed"
#define EnsErrFTPModeChangeFailed                  "<Ens>ErrFTPModeChangeFailed"
#define EnsErrFTPNameListFailed                    "<Ens>ErrFTPNameListFailed"
#define EnsErrFTPPutFailed                         "<Ens>ErrFTPPutFailed"
#define EnsErrFTPRenameFailed                      "<Ens>ErrFTPRenameFailed"
#define EnsErrFailureTimeout                       "<Ens>ErrFailureTimeout"
#define EnsErrGeneral                              "<Ens>ErrGeneral"
#define EnsErrHTTPConfigClass                      "<Ens>ErrHTTPConfigClass"
#define EnsErrHTTPConfigName                       "<Ens>ErrHTTPConfigName"
#define EnsErrHTTPNotEnabled                       "<Ens>ErrHTTPNotEnabled"
#define EnsErrHTTPStatus                           "<Ens>ErrHTTPStatus"
#define EnsErrIWay                                 "<Ens>ErrIWay"
#define EnsErrIWayNoStatus                         "<Ens>ErrIWayNoStatus"
#define EnsErrInConnectionLost                     "<Ens>ErrInConnectionLost"
#define EnsErrInvalidAssign                        "<Ens>ErrInvalidAssign"
#define EnsErrInvalidBPL                           "<Ens>ErrInvalidBPL"
#define EnsErrInvalidBPLDiagram                    "<Ens>ErrInvalidBPLDiagram"
#define EnsErrInvalidBinaryOperator                "<Ens>ErrInvalidBinaryOperator"
#define EnsErrInvalidDTL                           "<Ens>ErrInvalidDTL"
#define EnsErrInvalidDateTimeFormat                "<Ens>ErrInvalidDateTimeFormat"
#define EnsErrInvalidDurationFormat                "<Ens>ErrInvalidDurationFormat"
#define EnsErrInvalidName                          "<Ens>ErrInvalidName"
#define EnsErrInvalidOperator                      "<Ens>ErrInvalidOperator"
#define EnsErrInvalidProduction                    "<Ens>ErrInvalidProduction"
#define EnsErrInvalidScheduleEventSpec             "<Ens>ErrInvalidScheduleEventSpec"
#define EnsErrInvalidToken                         "<Ens>ErrInvalidToken"
#define EnsErrJobFailed                            "<Ens>ErrJobFailed"
#define EnsErrJobNotStopped                        "<Ens>ErrJobNotStopped"
#define EnsErrJobRegistryNotClean                  "<Ens>ErrJobRegistryNotClean"
#define EnsErrJobStatusLocked                      "<Ens>ErrJobStatusLocked"
#define EnsErrJobsNotStopped                       "<Ens>ErrJobsNotStopped"
#define EnsErrKeyWithAppend                        "<Ens>ErrKeyWithAppend"
#define EnsErrKeyWithClear                         "<Ens>ErrKeyWithClear"
#define EnsErrKeyWithInsert                        "<Ens>ErrKeyWithInsert"
#define EnsErrKeyWithRemove                        "<Ens>ErrKeyWithRemove"
#define EnsErrMissingBPL                           "<Ens>ErrMissingBPL"
#define EnsErrMissingBinaryOperator                "<Ens>ErrMissingBinaryOperator"
#define EnsErrMissingCloseCurlyBrace               "<Ens>ErrMissingCloseCurlyBrace"
#define EnsErrMissingCloseParen                    "<Ens>ErrMissingCloseParen"
#define EnsErrMissingCloseQuote                    "<Ens>ErrMissingCloseQuote"
#define EnsErrNoCallerCredentials                  "<Ens>ErrNoCallerCredentials"
#define EnsErrNoClassname                          "<Ens>ErrNoClassname"
#define EnsErrNoCredentials                        "<Ens>ErrNoCredentials"
#define EnsErrNoCredentialsSystemName              "<Ens>ErrNoCredentialsSystemName"
#define EnsErrNoEffectiveRuleSetFound              "<Ens>ErrNoEffectiveRuleSetFound"
#define EnsErrNoElementContent                     "<Ens>ErrNoElementContent"
#define EnsErrNoEnsembleLicense                    "<Ens>ErrNoEnsembleLicense"
#define EnsErrNoEnsembleManager                    "<Ens>ErrNoEnsembleManager"
#define EnsErrNoFileFound                          "<Ens>ErrNoFileFound"
#define EnsErrNoMsgBody                            "<Ens>ErrNoMsgBody"
#define EnsErrNoObjFromStream                      "<Ens>ErrNoObjFromStream"
#define EnsErrNoObjFromString                      "<Ens>ErrNoObjFromString"
#define EnsErrNoRawInputObj                        "<Ens>ErrNoRawInputObj"
#define EnsErrNoResponseClass                      "<Ens>ErrNoResponseClass"
#define EnsErrNoSQLColumns                         "<Ens>ErrNoSQLColumns"
#define EnsErrNoSQLCursor                          "<Ens>ErrNoSQLCursor"
#define EnsErrNoSQLStatement                       "<Ens>ErrNoSQLStatement"
#define EnsErrNoWebProtocol                        "<Ens>ErrNoWebProtocol"
#define EnsErrNotImplemented                       "<Ens>ErrNotImplemented"
#define EnsErrNotRetryable                         "<Ens>ErrNotRetryable"
#define EnsErrObjectAlreadyExists                  "<Ens>ErrObjectAlreadyExists"
#define EnsErrOutConnectException                  "<Ens>ErrOutConnectException"
#define EnsErrOutConnectExpired                    "<Ens>ErrOutConnectExpired"
#define EnsErrOutConnectFailed                     "<Ens>ErrOutConnectFailed"
#define EnsErrOutConnectionLost                    "<Ens>ErrOutConnectionLost"
#define EnsErrOutNotConnected                      "<Ens>ErrOutNotConnected"
#define EnsErrParameterInvocationInvalid           "<Ens>ErrParameterInvocationInvalid"
#define EnsErrParsingExpression                    "<Ens>ErrParsingExpression"
#define EnsErrPreviouslyCrashedMessage             "<Ens>ErrPreviouslyCrashedMessage"
#define EnsErrProductionAlreadyRunning             "<Ens>ErrProductionAlreadyRunning"
#define EnsErrProductionMismatchInDeferredResponse "<Ens>ErrProductionMismatchInDeferredResponse"
#define EnsErrProductionNetworkedMismatch          "<Ens>ErrProductionNetworkedMismatch"
#define EnsErrProductionNotQuiescent               "<Ens>ErrProductionNotQuiescent"
#define EnsErrProductionNotRegistered              "<Ens>ErrProductionNotRegistered"
#define EnsErrProductionNotRunning                 "<Ens>ErrProductionNotRunning"
#define EnsErrProductionNotShutdownCleanly         "<Ens>ErrProductionNotShutdownCleanly"
#define EnsErrProductionQuiescent                  "<Ens>ErrProductionQuiescent"
#define EnsErrProductionSettingInvalid             "<Ens>ErrProductionSettingInvalid"
#define EnsErrProductionSuspendedMismatch          "<Ens>ErrProductionSuspendedMismatch"
#define EnsErrRequestNotHandled                    "<Ens>ErrRequestNotHandled"
#define EnsErrRetryable                            "<Ens>ErrRetryable"
#define EnsErrRuleAliasAsClassname                 "<Ens>ErrRuleAliasAsClassname"
#define EnsErrRuleAliasConflict                    "<Ens>ErrRuleAliasConflict"
#define EnsErrRuleAliasNotFound                    "<Ens>ErrRuleAliasNotFound"
#define EnsErrRuleClassNotFound                    "<Ens>ErrRuleClassNotFound"
#define EnsErrRuleClassnameAsAlias                 "<Ens>ErrRuleClassnameAsAlias"
#define EnsErrRulesetLoadFailed                    "<Ens>ErrRulesetLoadFailed"
#define EnsErrRulesetNotFound                      "<Ens>ErrRulesetNotFound"
#define EnsErrSOAPConfigClass                      "<Ens>ErrSOAPConfigClass"
#define EnsErrSOAPConfigName                       "<Ens>ErrSOAPConfigName"
#define EnsErrSOAPConfigType                       "<Ens>ErrSOAPConfigType"
#define EnsErrSOAPNotEnabled                       "<Ens>ErrSOAPNotEnabled"
#define EnsErrSQLParmCount                         "<Ens>ErrSQLParmCount"
#define EnsErrSuspending                           "<Ens>ErrSuspending"
#define EnsErrTCPListen                            "<Ens>ErrTCPListen"
#define EnsErrTCPReadBlockSize                     "<Ens>ErrTCPReadBlockSize"
#define EnsErrTCPReadBlockSizeTimeoutExpired       "<Ens>ErrTCPReadBlockSizeTimeoutExpired"
#define EnsErrTCPReadTimeoutExpired                "<Ens>ErrTCPReadTimeoutExpired"
#define EnsErrTCPTerminatedReadTimeoutExpired      "<Ens>ErrTCPTerminatedReadTimeoutExpired"
#define EnsErrTargetNotSpecified                   "<Ens>ErrTargetNotSpecified"
#define EnsErrTelnetConnectFailed                  "<Ens>ErrTelnetConnectFailed"
#define EnsErrTelnetFindFailed                     "<Ens>ErrTelnetFindFailed"
#define EnsErrTelnetLoginFailed                    "<Ens>ErrTelnetLoginFailed"
#define EnsErrTempVariableNotDeclared              "<Ens>ErrTempVariableNotDeclared"
#define EnsErrTerminate                            "<Ens>ErrTerminate"
#define EnsErrUnknownFunction                      "<Ens>ErrUnknownFunction"
#define EnsErrUnsupportedRequestType               "<Ens>ErrUnsupportedRequestType"
#define EnsErrValueWithClear                       "<Ens>ErrValueWithClear"
#define EnsErrValueWithRemove                      "<Ens>ErrValueWithRemove"
#define EnsErrXDataBlockNotDefined                 "<Ens>ErrXDataBlockNotDefined"
#define EnsErrXMLValidation                        "<Ens>ErrXMLValidation"
]]></Routine>


<Class name="EnsLib.EDI.BatchDocument">
<Description>
Common base class for VDoc documents that can contain other VDoc documents of the same type</Description>
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>EnsEDI</IncludeCode>
<IncludeGenerator>Ensemble,%occInclude</IncludeGenerator>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.EDI.Document</Super>
<System>4</System>
<TimeChanged>63920,75705</TimeChanged>
<TimeCreated>59269,41535.544</TimeCreated>

<Property name="Parent">
<Description>
An object representing the original immediate parent document of this nested document, if nested</Description>
<Type>EnsLib.EDI.Document</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="ParentId">
<Description>
The ID:SegIndex of the immediate parent document of this nested document, if nested</Description>
<Type>%String</Type>
<Parameter name="COLLATION" value="EXACT"/>
<Parameter name="MAXLEN"/>
</Property>

<Property name="TopParentId">
<Description>
The ID:SegIndex of the outermost parent document of this nested document, if nested</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {TopParentId}=$LG({ParentIds},$LL({ParentIds}))</SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="ParentIds">
<Description>
A $List of the ID:SegIndex's of all the enclosing parent documents of this nested
 document, if nested,in order from from immediate to outermost.
E.g. for Id of enclosing batch document if we are a document within a batch document</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {ParentIds}=##class({%%CLASSNAME}).getParentIds({ParentId},1) </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="ChildCount">
<Description>
Number of Children</Description>
<Type>%Integer</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {ChildCount}="subclass responsibility" </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="ParentIdsGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$S(""=..ParentId:"",1:$LB(..ParentId)_..Parent.ParentIds)
]]></Implementation>
</Method>

<Method name="getParentIds">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pParentRef,pSkipOne=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSuperTable=##class(Ens.VDoc.SearchTableGenerator).GetExtentSupertable(%compiledclass.Name)
 	If tSuperTable="" {
		Do %code.WriteLine(" Quit $$$OK // not %Persistent")
		Quit $$$OK
	}
	Do %code.WriteLine(" Quit:""""=pParentRef """"")
	Do %code.WriteLine(" Set tParentId=$P(pParentRef,"":"")")
	Do %code.WriteLine(" &sql(Select ParentId Into :tGrandparentRef From "_tSuperTable_" Where ID=:tParentId)")
	Do %code.WriteLine(" Quit:SQLCODE $S(pSkipOne:"""",1:$LB(pParentRef))")
	Do %code.WriteLine(" Quit $S(pSkipOne:"""",1:$LB(pParentRef))_..getParentIds(tGrandparentRef,0)")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="TopParentIdGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$LG(..ParentIds,$LL(..ParentIds))
]]></Implementation>
</Method>

<Method name="ParentGetObjectId">
<Description>
Required for AutoForm</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>force:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$P(..ParentId,":")
]]></Implementation>
</Method>

<Method name="ParentGet">
<CodeMode>objectgenerator</CodeMode>
<ReturnType>EnsLib.EDI.Document</ReturnType>
<Implementation><![CDATA[
	Set tSuperclass=##class(Ens.VDoc.SearchTableGenerator).GetExtentSuperclass(%compiledclass.Name)
 	If tSuperclass="" {
		Do %code.WriteLine(" Quit $$$OK // not %Persistent")
		Quit $$$OK
	}
	Do %code.WriteLine(" Quit:""""'=..ParentId ##class("_tSuperclass_").%OpenId($P(..ParentId,"":""))")
	Do %code.WriteLine(" Quit $$$NULLOREF")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="resolveChildDocType">
<Description>
Implemented in subclasses</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tDocType = ..DocType
	Set tParent = ..Parent
	If (""=tDocType)&&($IsObject(tParent))&&(""'=tParent.DocTypeCategory) {
		Set tNameFound = ..Name
		Set:(""'=tNameFound) tDocType=tParent.DocTypeCategory_":"_tNameFound
	}
	Quit tDocType
]]></Implementation>
</Method>

<Method name="ChildCountGet">
<CodeMode>expression</CodeMode>
<FormalSpec>pParentRef:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..getChildCount(..%Id(),pParentRef)
]]></Implementation>
</Method>

<Method name="getChildCount">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pId:%String,pRefSegIndex:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSuperTable=##class(Ens.VDoc.SearchTableGenerator).GetExtentSupertable(%compiledclass.Name)
 	If tSuperTable="" {
		Do %code.WriteLine(" Quit $$$OK // not %Persistent")
		Quit $$$OK
	}
	Do %code.WriteLine(" Quit:""""=pId 0")
	Do %code.WriteLine(" If """"=pRefSegIndex {")
	Do %code.WriteLine("  &sql(Select Count(*) Into :tCount From "_tSuperTable_" Where ParentId=:pId Or ParentId %StartsWith :pId||':')")
	Do %code.WriteLine(" } Else {")
	Do %code.WriteLine("  Set tIdVal=pId_"":""_pRefSegIndex")
	Do %code.WriteLine("  &sql(Select Count(*) Into :tCount From "_tSuperTable_" Where ParentId=:tIdVal)")
	Do %code.WriteLine(" }")
	Do %code.WriteLine(" Quit:SQLCODE 0")
	Do %code.WriteLine(" Quit tCount")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="NextChild">
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pChild:EnsLib.EDI.Document=$$$NULLOREF,pRefSegIndex:%String</FormalSpec>
<ReturnType>EnsLib.EDI.Document</ReturnType>
<Implementation><![CDATA[
	Set tSuper=##class(Ens.VDoc.SearchTableGenerator).GetExtentSuperclass(%compiledclass.Name)
 	If tSuper="" {
		Do %code.WriteLine(" Quit $$$OK ; not %Persistent")
		Quit $$$OK
	}
	Do %code.WriteLine(" Set tId=..NextChildId($S($IsObject(pChild):pChild.%Id(),1:""""),.pRefSegIndex)")
	Do %code.WriteLine(" Quit $S(""""=tId:$$$NULLOREF,1:##class("_tSuper_").%OpenId(tId))")
]]></Implementation>
</Method>

<Method name="NextChildId">
<CodeMode>expression</CodeMode>
<FormalSpec>pId:%String,pRefSegIndex:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..getNextChildId(..%Id(),.pId,.pRefSegIndex)
]]></Implementation>
</Method>

<Method name="getNextChildId">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pParentId:%String,pId:%String="",pRefSegIndex:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSuperTable=##class(Ens.VDoc.SearchTableGenerator).GetExtentSupertable(%compiledclass.Name)
 	If tSuperTable="" {
		Do %code.WriteLine(" Quit $$$OK ; not %Persistent")
		Quit $$$OK
	}
	Do %code.WriteLine(" Set tDocId=$$$NULLOREF")
	Do %code.WriteLine(" If """"=pId {")
	Do %code.WriteLine("  If """"=pRefSegIndex {")
	Do %code.WriteLine("   &sql(Select ID Into :tDocId From "_tSuperTable_" Where ParentId=:pParentId Or ParentId %StartsWith :pParentId||':' Order By ID)")
	Do %code.WriteLine("  } Else {")
	Do %code.WriteLine("   Set tIdVal=pParentId_"":""_pRefSegIndex")
	Do %code.WriteLine("   &sql(Select ID Into :tDocId From "_tSuperTable_" Where ParentId=:tIdVal Order By ID)")
	Do %code.WriteLine("  }")
	Do %code.WriteLine(" } Else {")
	Do %code.WriteLine("  If """"=pRefSegIndex {")
	Do %code.WriteLine("   &sql(Select ID Into :tDocId From "_tSuperTable_" Where (ParentId=:pParentId Or ParentId %StartsWith :pParentId||':') And ID>:pId Order By ID)")
	Do %code.WriteLine("  } Else {")
	Do %code.WriteLine("   Set tIdVal=pParentId_"":""_pRefSegIndex")
	Do %code.WriteLine("   &sql(Select ID Into :tDocId From "_tSuperTable_" Where ParentId=:tIdVal And ID>:pId Order By ID)")
	Do %code.WriteLine("  }")
	Do %code.WriteLine(" }")
	Do %code.WriteLine(" Quit tDocId")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetChildIdsArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pArray,pParentId:%String,pLeavesOnly:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK, tNextId="" For { Set tNextId=..getNextChildId(pParentId,tNextId)  Quit:""=tNextId
		If ..getChildCount(tNextId) {
			Set:'pLeavesOnly pArray=$G(pArray)+1, pArray(pArray)=tNextId
			Set tSC=..GetChildIdsArray(.pArray,tNextId,pLeavesOnly)  Quit:$$$ISERR(tSC)
		} Else {
			Set pArray=$G(pArray)+1, pArray(pArray)=tNextId
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="AddChild">
<Description><![CDATA[
To the current batch parent object, add one or more child objects as children of the DocsRef placeholder segment referenced by its index position in <var>pRefSegIndex</var>.
(This is 2 for a simple batch parent with 3 segments: Header, DocsRef, and Trailer segments.)]]></Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pRefSegIndex:%Integer,pChild...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..AddChildArray(.pRefSegIndex,.pChild)
]]></Implementation>
</Method>

<Method name="AddChildArray">
<Description><![CDATA[
To the current batch parent object, add one or more child objects as children of the DocsRef placeholder segment referenced by its index position in <var>pRefSegIndex</var>.
(This is 2 for a simple batch parent with 3 segments: Header, DocsRef, and Trailer segments.)
The children are objects passed as numbered subscript values in array <var>pChildren</var> whose top value is the count of child object values.]]></Description>
<FormalSpec><![CDATA[pRefSegIndex:%Integer,&pChildren]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsMutable $$$ERROR($$$EnsErrGeneral,"Object is immutable")
	Set tParentRef=..getId()_":"_pRefSegIndex
	For i=1:1:pChildren { Set tChild=pChildren(i)
		Set tChild.ParentId=tParentRef
		Set tSC=tChild.%Save()  Quit:$$$ISERR(tSC)
	}
	Quit ..SetValueAt(pChildren+..GetValueAt(pRefSegIndex_":"_$$$REFSEGFLDCOUNT),pRefSegIndex_":"_$$$REFSEGFLDCOUNT)
]]></Implementation>
</Method>
</Class>


<Class name="EnsLib.EDI.Document">
<Description>
Common base class for VDoc document classes that represent documents used for Electronic Data Interchange (EDI)</Description>
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>EnsEDI</IncludeCode>
<IncludeGenerator>Ensemble,%occInclude</IncludeGenerator>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.VDoc.Interface</Super>
<System>4</System>
<TimeChanged>63920,75705</TimeChanged>
<TimeCreated>59269,41535.544</TimeCreated>
</Class>


<Class name="EnsLib.EDI.Segment">
<Description>
Common base class for VDoc classes that have Separators and are non-persistent, being objects representing Segments that compose an instance of a "Segmented" VDoc class</Description>
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>EnsEDI</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.EDI.Document</Super>
<System>4</System>
<TimeChanged>63920,75705</TimeChanged>
<TimeCreated>59803,48988.361492</TimeCreated>

<Property name="ID">
<Description>
Index into Segment Storage</Description>
<Type>%String</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Separators">
<Description>
All Separators as a single String</Description>
<Type>%String</Type>
</Property>

<Property name="Count">
<Description>
Number of Fields</Description>
<Type>%Integer</Type>
<Calculated>1</Calculated>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="IsMutable">
<Description>
We clear this property to prevent saving or modifying of already-saved document objects</Description>
<Type>%Boolean</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="%OnNew">
<Description>
creates an object based on id=initvalue but editable if specified</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>initvalue:%CacheString=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..init($LG(initvalue,1),+$LG(initvalue,2),$LG(initvalue,3),$LG(initvalue,4))
]]></Implementation>
</Method>

<Method name="init">
<Description>
Initialize a segment. The segid is typically an index into the Segment storage global. Mutable indicates
whether the initialized segment may be modified or not and SegType is used to determine the
segment schema to be used for interpretation of segment contents</Description>
<Internal>1</Internal>
<Abstract>1</Abstract>
<FormalSpec>pSegID:%String="",pMutable:%Boolean=0,pSegType:%String="",pSegData:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if pSegID="" set i%IsMutable=1 quit $$$OK
	set i%ID=pSegID,i%IsMutable=+pMutable
	quit $$$OK
]]></Implementation>
</Method>

<Method name="NameGet">
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..GetValueAt(0)
]]></Implementation>
</Method>

<Method name="CountGet">
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..GetValueAt("*")
]]></Implementation>
</Method>

<Method name="IsMutableSet">
<Internal>1</Internal>
<Abstract>1</Abstract>
<CodeMode>expression</CodeMode>
<FormalSpec>value:%Library.Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[$$$OK
]]></Implementation>
</Method>

<Method name="GetValueAt">
<Description>
Returns the value at the specified property path. The seperaters argument is used to specify the
separators to be used when a non-atomic value is returned. Status is returned via the Status output variable.
Finally implementation specific type information may be returned as the TypeInfo output parameter</Description>
<Abstract>1</Abstract>
<CodeMode>expression</CodeMode>
<FormalSpec>pPropertyPath:%String="",pSeparators:%String="",*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[""
]]></Implementation>
</Method>

<Method name="SetValueAt">
<Description><![CDATA[
Sets a value at the specified property path. Typically the key is used to specify arguments which may
be matched at run-time with place-holders in the property path. The action corresponds to the actions in the
DTL <assign> statement]]></Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pValue:%String,pPropertyPath:%String="",pKey:%String="",pAction:%String="set"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[$S(..IsMutable:$$$OK, 1:$$$ERROR($$$EnsErrGeneral,"Object is immutable"))
]]></Implementation>
</Method>

<Method name="SaveData">
<Abstract>1</Abstract>
<CodeMode>expression</CodeMode>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[$$$OK
]]></Implementation>
</Method>

<Method name="Validate">
<Description>
Validate a segment item</Description>
<Abstract>1</Abstract>
<FormalSpec>pPath:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$ASSERT("0:subclass responsibility")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetNextIndex">
<Description>
Gets the next index in an array by path</Description>
<Abstract>1</Abstract>
<FormalSpec><![CDATA[pPath:%String,pIndex:%String,&pStatus:%Status]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	$$$ASSERT("0:subclass responsibility")
]]></Implementation>
</Method>

<Method name="IsChildHolder">
<FormalSpec>*pRefSegIndex:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tName=..Name
	If "DocsRef"=$E(tName,*-$L("DocsRef")+1,*) {
		Set pRefSegIndex=..GetValueAt($$$REFSEGFLDINDEX)
		Quit 1
	} Else {
		Set pRefSegIndex=""
		Quit 0
	}
]]></Implementation>
</Method>

<Method name="FindValuesArray">
<FormalSpec><![CDATA[pPropertyPath:%String="",pSeparators:%String,&pArray:%String,pSchemaCategory:%String,*pStatus:%Status=$$$OK,&pLongArray:%String]]></FormalSpec>
<Implementation><![CDATA[
	Set $ZT="Trap"
	Set f=$F(pPropertyPath,"()")  If 'f {
		Set:""=..DocType&&(""'=pSchemaCategory) tCat=1, ..DocType=pSchemaCategory_":"_..Name
		Set tVal=..GetValueAt(pPropertyPath,.pSeparators,.pStatus) 
		If tVal '= "" {
			Set tInSub=1
			If $l(tVal) >= $$$MAXEDIARRAYSUBSCRIPT {
				Set pLongArray($i(pLongArray)) = tVal
				Set tInSub =0
			}
			Set pArray($E(tVal,1,$$$MAXEDIARRAYSUBSCRIPT))=""
			
		}
		Set:$G(tCat) ..DocType=""
		Quit
	}
	Set tHead=$E(pPropertyPath,1,f-3)
	Set tTail=$E(pPropertyPath,f,*)
	Set i="" For { Set i=..GetNextIndex(tHead_"()",i,.pStatus)  Quit:i=""
		Set tNewPath=tHead_"("_(i)_")"_tTail
		Do ..FindValuesArray(tNewPath,.pSeparators,.pArray,.pSchemaCategory,.tSC,.pLongArray)
		Set:$$$ISERR(tSC) pStatus=$$$ADDSC(pStatus,tSC)
	}
	Quit
Trap
	Set $ZT="", pStatus=$$$SystemError
	Quit
]]></Implementation>
</Method>

<Method name="FindValues">
<FormalSpec><![CDATA[pPropertyPath:%String="",pSeparators:%String,pValSepString:%String="<>",pSchemaCategory:%String,*pStatus:%Status=$$$OK]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set f=$F(pPropertyPath,"()")  If 'f {
		Set:""=..DocType&&(""'=pSchemaCategory) tCat=1, ..DocType=pSchemaCategory_":"_..Name
		Set tVals=..GetValueAt(pPropertyPath,.pSeparators,.pStatus)
		Set:$G(tCat) ..DocType=""
		Quit tVals
	}
	Set tHead=$E(pPropertyPath,1,f-3)
	Set tTail=$E(pPropertyPath,f,*)
	Set tVals=""
	Set i="" For { Set i=..GetNextIndex(tHead_"()",i,.pStatus)  Quit:i=""
		Set tNewPath=tHead_"("_(i)_")"_tTail
		Set tVal=..FindValues(tNewPath,.pSeparators,pValSepString,.pSchemaCategory,.tSC)
		Set:""'=tVal tVals=$S(""=tVals:"",1:tVals_pValSepString)_tVal
		Set:$$$ISERR(tSC) pStatus=$$$ADDSC(pStatus,tSC)
	}
	Quit tVals
]]></Implementation>
</Method>
</Class>


<Class name="EnsLib.EDI.Segmented">
<Description>
Common (secondary) base class for VDoc classes that have segments, BuildMap(), and Separators</Description>
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>EnsEDI</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%RegisteredObject</Super>
<System>4</System>
<TimeChanged>63920,75705</TimeChanged>
<TimeCreated>59269,41535.544</TimeCreated>

<Property name="SegCount">
<Description>
Number of Segments composing this Document</Description>
<Type>%Integer</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {SegCount}="subclass responsibility" </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="BuildMapStatus">
<Description>
The status of the last BuildMap() action, or empty if the map gets updated or discarded later.
Note that the BuildMap() is not called automatically when a saved document gets opened.</Description>
<Type>%Status</Type>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="AutoBuildMap">
<Description>
Determines if maps should be built automatically on segment insertion/deletion</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Transient>1</Transient>
</Property>

<Property name="CacheSegsGotten">
<Description>
Flag to control whether segments retrieved from a document should be cached in the map of the document object.
Segments not cached will be marked immutable because the document will have no record of them and therefore couldn't save any changes to them when it is saved</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
<Transient>1</Transient>
</Property>

<Method name="BuildMap">
<Abstract>1</Abstract>
<FormalSpec>pKeepParsingAfterError:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$ASSERT("0:Subclass Responsibility")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetSegmentAt">
<Description>
Gets a immutable segment object by path or index</Description>
<FormalSpec>pIndexOrPath:%String,*pStatus:%Status</FormalSpec>
<ReturnType>EnsLib.EDI.Segment</ReturnType>
<Implementation><![CDATA[
	If $G(pIndexOrPath)=""  Set pStatus=$$$ERROR($$$EnsErrGeneral,"Segment '' does not exist")  Quit $$$NULLOREF
	If $$$vaIsIndex(pIndexOrPath) Quit ..getSegmentByIndex($$$vaIndex(pIndexOrPath),.pStatus)
	Quit ..getSegmentByPath(pIndexOrPath,.pStatus)
]]></Implementation>
</Method>

<Method name="GetSegmentIdAt">
<Description>
Gets a immutable segment ID by path or index</Description>
<FormalSpec>pIndexOrPath:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If $G(pIndexOrPath)="" Set pStatus=$$$ERROR($$$EnsErrGeneral,"Segment '' does not exist")  Quit ""
	If $$$vaIsIndex(pIndexOrPath) Quit ..getSegmentIdByIndex($$$vaIndex(pIndexOrPath),.pStatus)
	Quit ..getSegmentIdByPath(pIndexOrPath,.pStatus)
]]></Implementation>
</Method>

<Method name="GetMutableSegmentAt">
<Description>
Gets a mutable segment object by path or index</Description>
<FormalSpec>pIndexOrPath:%String,*pStatus:%Status</FormalSpec>
<ReturnType>EnsLib.EDI.Segment</ReturnType>
<Implementation><![CDATA[
	If '..IsMutable Set pStatus=$$$ERROR($$$EnsErrGeneral,"Object is immutable")  Quit $$$NULLOREF
	If $G(pIndexOrPath)="" Set pStatus=$$$ERROR($$$EnsErrGeneral,"Segment '' does not exist")  Quit $$$NULLOREF
	If $$$vaIsIndex(pIndexOrPath) Quit ..getMutableSegmentByIndex($$$vaIndex(pIndexOrPath),.pStatus)
	Quit ..getMutableSegmentByPath(pIndexOrPath,.pStatus)
]]></Implementation>
</Method>

<Method name="SetSegmentAt">
<Description>
Set a segment object by path or index</Description>
<FormalSpec>pSegment:EnsLib.EDI.Segment,pIndexOrPath:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:""=pIndexOrPath $$$ERROR($$$EnsErrGeneral,"Segment '' does not exist")
	If $$$vaIsIndex(pIndexOrPath) Quit ..setSegmentByIndex(pSegment,$$$vaIndex(pIndexOrPath),0)
	Quit ..setSegmentByPath(pSegment,pIndexOrPath)
]]></Implementation>
</Method>

<Method name="SetSegmentIdAt">
<Description>
Set a segment ID by path or index</Description>
<FormalSpec>pSegmentId:%String,pIndexOrPath:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:""=pIndexOrPath $$$ERROR($$$EnsErrGeneral,"Segment '' does not exist")
	If $$$vaIsIndex(pIndexOrPath) Quit ..setSegmentIdByIndex(pSegmentId,$$$vaIndex(pIndexOrPath),0)
	Quit ..setSegmentIdByPath(pSegmentId,pIndexOrPath)
]]></Implementation>
</Method>

<Method name="InsertSegmentAt">
<Description>
Insert a segment object by index</Description>
<FormalSpec>pSegment:EnsLib.EDI.Segment,pIndex:%Integer=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'$$$vaIsIndex(pIndex) $$$ERROR($$$EnsErrGeneral,"Segment index '"_pIndex_"' is not a valid number")
	Quit ..setSegmentByIndex(pSegment,$$$vaIndex(pIndex),1)
]]></Implementation>
</Method>

<Method name="InsertSegmentIdAt">
<Description>
Insert a segment ID by index</Description>
<FormalSpec>pSegmentId:%String,pIndex:%Integer=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'$$$vaIsIndex(pIndex) $$$ERROR($$$EnsErrGeneral,"Segment index '"_pIndex_"' is not a valid number")
	Quit ..setSegmentIdByIndex(pSegmentId,$$$vaIndex(pIndex),1)
]]></Implementation>
</Method>

<Method name="AppendSegment">
<Description>
Insert a segment at the end by index</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pSegment:EnsLib.EDI.Segment</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..InsertSegmentAt(pSegment,..SegCount+1)
]]></Implementation>
</Method>

<Method name="AppendSegmentId">
<Description>
Insert a segment ID at the end by index</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pSegmentId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..InsertSegmentIdAt(pSegmentId,..SegCount+1)
]]></Implementation>
</Method>

<Method name="RemoveSegmentAt">
<Description>
Removes a segment by path or index</Description>
<FormalSpec>pIndexOrPath:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:""=pIndexOrPath $$$ERROR($$$EnsErrGeneral,"Segment '' does not exist")
	If $$$vaIsIndex(pIndexOrPath) Quit ..removeSegmentByIndex($$$vaIndex(pIndexOrPath))
	Quit ..removeSegmentByPath(pIndexOrPath)
]]></Implementation>
</Method>

<Method name="NewSegment">
<Description>
Returns a new segment of type suitable for inserting in the current transaction type at the position given by pSegPath</Description>
<Abstract>1</Abstract>
<FormalSpec>pSegPath:%String,pSeparators:%String,*pStatus:%Status</FormalSpec>
<ReturnType>EnsLib.EDI.Segment</ReturnType>
<Implementation><![CDATA[	$$$ASSERT("0:Subclass Responsibility")
]]></Implementation>
</Method>

<Method name="GetSegmentTypeAt">
<Abstract>1</Abstract>
<FormalSpec>pSegPath:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	$$$ASSERT("0:Subclass Responsibility")
]]></Implementation>
</Method>

<Method name="GetValuesArray">
<Description>
Finds all values matching a SegPath:PropertyPath string that contains zero or more () implicit iterators</Description>
<FormalSpec><![CDATA[pSegmentPropertyPath:%String,pSeparators:%String,&pArray:%String,*pStatus:%Status,&pLongArray:%String]]></FormalSpec>
<Implementation><![CDATA[
	Set pStatus=$$$OK  Kill pArray,pLongArray
	Do ..getValsArray(pSegmentPropertyPath,.pSeparators,.pArray,.pStatus,.pLongArray)
]]></Implementation>
</Method>

<Method name="getValsArray">
<Description>
Finds all values matching a SegPath:PropertyPath string that contains zero or more () implicit iterators</Description>
<FormalSpec><![CDATA[pSegmentPropertyPath:%String,pSeparators:%String,&pArray:%String,*pStatus:%Status,&pLongArray:%String]]></FormalSpec>
<Implementation><![CDATA[
	Set $ZT="Trap"
	Set f=$F(pSegmentPropertyPath,"()")
	If 'f {
		Set tVal=..GetValueAt(pSegmentPropertyPath,.pSeparators,.pStatus)
		If tVal '= "" {
			If $l(tVal) >= $$$MAXEDIARRAYSUBSCRIPT {
				Set pLongArray($i(pLongArray)) = tVal
			}
			Set pArray($E(tVal,1,$$$MAXEDIARRAYSUBSCRIPT))=""
		}
		Quit
	}
	Set tHead=$E(pSegmentPropertyPath,1,f-3)
	Set tTail=$E(pSegmentPropertyPath,f,*)

	Set i="" For { Set i=..GetNextIndex(tHead_"()",i,.pStatus)  Quit:i=""
		Set tNewPath=tHead_"("_(i)_")"_tTail
		Do ..getValsArray(tNewPath,.pSeparators,.pArray,.tSC,.pLongArray)
		Set:$$$ISERR(tSC) pStatus=$$$ADDSC(pStatus,tSC)
	}
	Quit
Trap
	Set $ZT="", pStatus=$$$SystemError
	Quit
]]></Implementation>
</Method>

<Method name="GetValues">
<Description>
Finds all values matching a SegPath:PropertyPath string that contains zero or more () implicit iterators
Supports SegPath values with (), (n) to choose a specific one of the given type, or just plain (same as seg() or seg(*)).</Description>
<FormalSpec><![CDATA[pSegmentPropertyPath:%String,pSeparators:%String,pValSepString:%String="<>",*pStatus:%Status]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pStatus=$$$OK
	Set f=$F(pSegmentPropertyPath,"()")  Quit:'f ..GetValueAt(pSegmentPropertyPath,.pSeparators,.pStatus)
	Set tHead=$E(pSegmentPropertyPath,1,f-3)
	Set tTail=$E(pSegmentPropertyPath,f,*)
	Set tVals=""
	Set i="" For { Set i=..GetNextIndex(tHead_"()",i,.pStatus)  Quit:i=""
		Set tNewPath=tHead_"("_(i)_")"_tTail
		Set tVal=..GetValues(tNewPath,.pSeparators,pValSepString,.tSC)
		Set:""'=tVal tVals=$S(""=tVals:"",1:tVals_pValSepString)_tVal
		Set:$$$ISERR(tSC) pStatus=$$$ADDSC(pStatus,tSC)
	}
	Quit tVals
]]></Implementation>
</Method>

<Method name="FindSegmentValuesArray">
<Description>
Finds all values matching a SegName:PropertyPath string, where the SegName is a simple segment type name
 (not a full schema-based seg path); PropertyPath describes a field or subfield within the segment.
Supports SegName = '*' to match any segment, and SegName(n) to match only the n'th segment of the given type.</Description>
<FormalSpec><![CDATA[pSegmentPropertyPath:%String,pSeparators:%String,&pArray:%String,*pStatus:%Status,pSchemaCategory:%String="",&pLongArray:%String]]></FormalSpec>
<Implementation><![CDATA[
	#; implementation for non-HL7 EDI documents
	Set pStatus=$$$OK  Kill pArray
	Set tSegName=$P(pSegmentPropertyPath,":"), tPropPath=$P(pSegmentPropertyPath,":",2)
	Set tSegIndex=$P(tSegName,"(",2), tSegName=$P($P($P(tSegName,"("),"-"),"!"), tSegIndex=$ZStrip($P(tSegIndex,")"),"<>W","*")
	Do:$ZStrip(tPropPath,"*A")'=tPropPath&&(""'=..DocType)&&(""=..BuildMapStatus) ..BuildMap(0) ; get seg types if available
	Set tIndex="" For i=1:1 { Set tSegObj=..FindSegment(tSegName,.tIndex,.pStatus)  Quit:""=tIndex
		Continue:(""'=tSegIndex)&&(i'=tSegIndex) ; if they asked for a specific number, forsake all others
		Do tSegObj.FindValuesArray(tPropPath,.pSeparators,.pArray,.pSchemaCategory,.pStatus,.pLongArray)  Quit:$$$ISERR(pStatus)
		Quit:i=tSegIndex ;all done
	}
]]></Implementation>
</Method>

<Method name="FindSegmentValues">
<Description><![CDATA[
Finds all values matching a SegName:PropertyPath string, where the SegName is a simple segment type name
 (not a full schema-based seg path); PropertyPath describes a field or subfield within the segment. <br>
Supports SegName = '*' to match any segment, and SegName(n) to match only the n'th segment of the given type. <br>
Final parameter is an output of the list of segment indexes (separated by pValSepString) for the values found.]]></Description>
<FormalSpec><![CDATA[pSegmentPropertyPath:%String,pSeparators:%String,pValSepString:%String="<>",*pStatus:%Status,pSchemaCategory:%String="",*pIndices:%String]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#; implementation for non-HL7 EDI documents
	Set pStatus=$$$OK, pIndices = ""
	Set tSegName=$P(pSegmentPropertyPath,":"), tPropPath=$P(pSegmentPropertyPath,":",2)
	Set tSegIndex=$P(tSegName,"(",2), tSegName=$P($P($P(tSegName,"("),"-"),"!"), tSegIndex=$ZStrip($P(tSegIndex,")"),"<>W","*")
	Do:$ZStrip(tPropPath,"*A")'=tPropPath&&(""'=..DocType)&&(""=..BuildMapStatus) ..BuildMap(0) ; get seg types if available
	Set (tVals,tIndex)="" For i=1:1 { Set tSegObj=..FindSegment(tSegName,.tIndex,.pStatus)  Quit:""=tIndex
		Continue:(""'=tSegIndex)&&(i'=tSegIndex) ; if they asked for a specific number, forsake all others
		Set tVal=tSegObj.FindValues(tPropPath,.pSeparators,pValSepString,.pSchemaCategory,.pStatus)  Quit:$$$ISERR(pStatus)
		If (""'=tVal) {
			Set tVals=$S(""=tVals:"",1:tVals_pValSepString)_tVal
			For tR=1:1:$L(tVal,pValSepString) Set pIndices = $S(""=pIndices:"",1:pIndices_pValSepString)_tIndex
		}
		Quit:i=tSegIndex ;all done
	}
	Quit tVals
]]></Implementation>
</Method>

<Method name="FindSegment">
<Description><![CDATA[
Gets the next segment after index <var>pIndex</var> with name <var>pSegName</var>.
Supports <var>pSegName</var> = '*' to match any segment.]]></Description>
<Abstract>1</Abstract>
<FormalSpec><![CDATA[pSegName:%String,&pIndex:%String="",*pStatus:%Status]]></FormalSpec>
<ReturnType>EnsLib.EDI.Segment</ReturnType>
</Method>

<Query name="EnumerateSegTypes">
<Description><![CDATA[
Returns a list of schema categories and segment types and segment fields for the document class. <br/>
The <var>Category</var> and <var>Level</var> parameters can be used to restrict the list. <br/>
If <var>Category</var> is: <br/>
 0 - return only standard categories <br/>
 + - return only user-defined categories <br/>
 empty - return all categories <br/>
 a category name - return only SegTypes in the named category <br/>
 a category name:segment type name - return only information about the named SegType <br/>
 a partial name suffixed with '%' - return only SegTypes in categories matching the partial category name <br/>
 other - return nothing <br/>
If <var>Level</var> is: <br/>
 0 - return all segment names <br/>
 n - return the given number of levels of nested field names within each segment <br/>
 empty - return all levels of nested field names within each segment <br/>
If <var>IncludeBase</var> is: <br/>
 0 - return only segment names defined in the current schema category itself <br/>
 1 - return all segment names in the current schema category's base category in addition to those defined in the current category itself <br/>]]></Description>
<Type>%Query</Type>
<FormalSpec>Category:%String="",Level:%String="",IncludeBase:%Boolean=0</FormalSpec>
<Parameter name="CONTAINID" value="0"/>
<Parameter name="ROWSPEC" value="SegType:%String,Field:%String,Description:%String,IsStandard:%Boolean"/>
</Query>

<Method name="EnumerateSegTypesExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,Category:%String,Level:%String,IncludeBase:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set qHandle=0
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="EnumerateSegTypesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>EnumerateSegTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Set Row="",AtEnd=1 Quit $$$OK
]]></Implementation>
</Method>

<Method name="EnumerateSegTypesClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateSegTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill qHandle
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="EnsLib.HL7.Message">
<Description>
A class representing all HL7 v2 message documents using the Virtual Document (VDoc) architecture</Description>
<ClassType>persistent</ClassType>
<IncludeCode>EnsHL7</IncludeCode>
<IncludeGenerator>EnsHL7</IncludeGenerator>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,EnsLib.EDI.BatchDocument,EnsLib.EDI.Segmented,EnsLib.HL7.Util.MsgBodyMethods</Super>
<System>4</System>
<TimeChanged>63920,75710</TimeChanged>
<TimeCreated>59269,41535.544</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="DOMAIN">
<Description>
Use our own domain for localization</Description>
<Default>Ensemble</Default>
</Parameter>

<Parameter name="DOCCLASSNAME">
<Default>HL7 Message</Default>
</Parameter>

<Parameter name="DOCCLASSFULLNAME">
<Default>Health Level 7 (HL7) v2. Message</Default>
</Parameter>

<Parameter name="DOCSHORTNAME">
<Default>HL7</Default>
</Parameter>

<Parameter name="DEFSEARCHCLASS">
<Description>
Name of the default SearchTable indexing class used in UI choices and MessageBank submissions </Description>
<Default>EnsLib.HL7.SearchTable</Default>
</Parameter>

<Parameter name="SCHEMACLASS">
<Description>
Name of the associated schema class and, after a colon, the schema class code that represents a DocType</Description>
<Default>EnsLib.HL7.Schema:MS</Default>
</Parameter>

<Parameter name="EXTENTSIZE">
<Default>2000000</Default>
</Parameter>

<Index name="Extent">
<Type>bitmap</Type>
<Extent>1</Extent>
</Index>

<Index name="ParentId">
<Properties>ParentId</Properties>
</Index>

<Index name="OriginalDocId">
<Properties>OriginalDocId</Properties>
</Index>

<Property name="Envelope">
<Description><![CDATA[
XML or other 'envelope' For the HL7 message. The HL7 message will be inserted in place of the "&lt;!--HL72MSG--&gt;"
string If present, otherwise after the end of the Envelope.]]></Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Separators">
<Description>
All 5 Separators as a String
Additional characters will be output as the Segment Terminator; may have up to 3 additional chars for output with newlines</Description>
<Type>%String</Type>
<Transient>1</Transient>
<Parameter name="MAXLEN" value="8"/>
<Parameter name="MINLEN" value="5"/>
</Property>

<Property name="FS">
<Description>
Field Separator</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
</Property>

<Property name="CS">
<Description>
Component Separator</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
</Property>

<Property name="RS">
<Description>
Repetition Separator</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
</Property>

<Property name="ESC">
<Description>
Escape Character</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
</Property>

<Property name="SS">
<Description>
Subcomponent Separator</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
</Property>

<Property name="SegmentTerminator">
<Description>
Segment Terminator character(s)</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
</Property>

<Property name="MessageTypeCategory">
<Description>
Hint value: Schema Category that was combined with the MSH-declared MessageType to identify
a schema Message Type that specifies a Message Structure used as the DocType for this Message.</Description>
<Type>%String</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Name">
<Description>
Raw type name of message found at MSH:9</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set segid=$G($$$vaExtentGbl({ID},"segs",1),"0,0"), data=$S(segid[",":$G($$$vaSegment(segid)),1:$G($$$vaSegmentGbl(segid))), {Name}=$Case($$$vaDataSegName(data),"FHS":"FHS","BHS":"BHS",:##class(EnsLib.HL7.Message).getDataName(data)) </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="TypeVersion">
<Description>
Raw type version name of message found at MSH:12 in message content</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set segid=$G($$$vaExtentGbl({ID},"segs",1),"0,0"), data=$S(segid[",":$G($$$vaSegment(segid)),1:$G($$$vaSegmentGbl(segid))), {TypeVersion}=$Case($$$vaDataSegName(data),"FHS":"Batch","BHS":"Batch",:$$$vaDataTypeVersion(data)) </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Identifier">
<Description>
Unique document identification string found at MSH:10 / MessageControlId in document content</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set segid=$G($$$vaExtentGbl({ID},"segs",1),"0,0"), data=$S(segid[",":$G($$$vaSegment(segid)),1:$G($$$vaSegmentGbl(segid))), {Identifier}=$Case($$$vaDataSegName(data),"FHS":$$$vaDataBatchIdentifier(data),"BHS":$$$vaDataBatchIdentifier(data),:$$$vaDataDocIdentifier(data)) </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="SegCount">
<Description>
Count of segments composing this message</Description>
<Type>%Integer</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {SegCount}=$G($$$vaExtentGbl({ID},"segs"),0) </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="ChildCount">
<Description>
Number of Children</Description>
<Type>%Integer</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {ChildCount}=##class({%%CLASSNAME}).getChildCount({ID}) </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="ParentIds">
<Description>
A $List of the Ids of all the enclosing parent documents of this nested document, if nested,
in order from from immediate to outermost
E.g. for Id of enclosing EncounterBatch if we are an Encounter</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {ParentIds}=##class({%%CLASSNAME}).getParentIds({ParentId},1) </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="RawContent">
<Description>
The raw text content of the document. Note that this is a truncated version suitable for use in SQL results and visual inspection,
but not a complete or definitive representation of the document.</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {RawContent}=##class({%%CLASSNAME}).getSegsAsString({ID}) </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
<Parameter name="MAXLEN" value="10000"/>
</Property>

<Property name="DocTypeCategory">
<Description>
the category portion of the DocType</Description>
<Type>%String</Type>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="DocTypeSecondary">
<Type>%String</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="DocTypeName">
<Description>
Stored raw document type name ; the secondary type name portion of the DocType</Description>
<Type>%String</Type>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="FullSize">
<Description>
Size in bytes of the message content.
The calculation assumes 1-byte segment terminators and includes any segments that use more than one storage node.</Description>
<Type>%Integer</Type>
<Calculated>1</Calculated>
<SqlComputeCode> Set {FullSize}=##class({%%CLASSNAME}).GetFullSize({ID}) </SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="%maps">
<Description>
A local array of orefs
"orefs" - a local map of integer ids to segment objects
And either a subscript into ^CacheTemp for this object's LVD maps (for notes on LVD implementation see EnsEDI.inc)
or local storage for these additional maps:
"runtimeIndex" - array for runtime index to segment; will always be defined unless mapRuntimePath is defined
"runtimePath" - array for runtime path to segment
"bidirectionalLink" - array for runtime path and index linkage</Description>
<MultiDimensional>1</MultiDimensional>
<Transient>1</Transient>
</Property>

<Property name="%ClonedId">
<Description><![CDATA[
Id of original object if we are a mutable clone (also used as a legal subscript that will result in $G(xxx(..%ClonedId))="" instead of a <SUBSCRIPT> error)]]></Description>
<Type>%CacheString</Type>
<Internal>1</Internal>
<InitialExpression>0</InitialExpression>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="FSGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$E(..Separators,1)
]]></Implementation>
</Method>

<Method name="CSGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$E(..Separators,2)
]]></Implementation>
</Method>

<Method name="RSGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$E(..Separators,3)
]]></Implementation>
</Method>

<Method name="ESCGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$E(..Separators,4)
]]></Implementation>
</Method>

<Method name="SSGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$E(..Separators,5)
]]></Implementation>
</Method>

<Method name="SegmentTerminatorGet">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSegTerminator=$$$SEGTERM(..Separators)
	Set:""=tSegTerminator tSegTerminator=$C($$$HL7DefSegTerminatorAscii)
	Quit tSegTerminator
]]></Implementation>
</Method>

<Method name="NameGet">
<Internal>1</Internal>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#; Do as much as possible inline to be speedy
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath()
	Set tId=..%Id()  Set:'tId tId=..%ClonedId
	Set seg=$$$vaSegLookthru(1,tId)
	Quit:""=seg ""
	If $$$vaIsOref(seg) {
		Set tSegObj=..%maps("orefs",1)
		If (tSegObj.ID="")||$D(tSegObj.DataArray) {
			Set tSeps=tSegObj.Separators
			Set tSegName=tSegObj.getAtFromArray(0), tMSH9=tSegObj.getAtFromArray(9)
		} Else {
			Set data=$$$vaSegment(tSegObj.ID), tSeps=$E(data,1,5)
			Set tSegName=$$$vaDataSegName(data), tMSH9=$$$vaDataDocNameRaw(data)
		}
	} Else {
		Set data=$G($$$vaSegment($P(seg,"|"))), tSeps=$E(data,1,5)
		Set tSegName=$$$vaDataSegName(data), tMSH9=$$$vaDataDocNameRaw(data)
	}
	Quit:""=tSegName ""
	Quit:"FHS"=tSegName "FHS"
	Quit:"BHS"=tSegName "BHS"
	If $S($D($$$EnsConfig("HL7NamePropOld"),tNPS)#2:tNPS,1:$G(^Ens.Config("HL7NamePropOld"))) {
		Quit:"_~\&"_$E(tSeps,3,5)=$TR("_~\&"_$E(tSeps,3,5),tMSH9) $TR(tMSH9,tSeps,":_~\&")
		Quit $E(##class(EnsLib.HL7.Segment).replaceSeparators(tSeps_tMSH9,":_~\&"),6,*)
	}
	Quit ..GetMsgType($TR(tMSH9,tSeps,":_~\&"))
]]></Implementation>
</Method>

<Method name="getDataName">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pData:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSeps=$E(pData,1,5)
	Set tSegName=$$$vaDataSegName(pData), tMSH9=$$$vaDataDocNameRaw(pData)
	Quit:""=tSegName ""
	If $S($D($$$EnsConfig("HL7NamePropOld"),tNPS)#2:tNPS,1:$G(^Ens.Config("HL7NamePropOld"))) {
		Quit:"_~\&"_$E(tSeps,3,5)=$TR("_~\&"_$E(tSeps,3,5),tMSH9) $TR(tMSH9,tSeps,":_~\&")
		Quit $E(##class(EnsLib.HL7.Segment).replaceSeparators(tSeps_tMSH9,":_~\&"),6,*)
	}
	Quit ..GetMsgType($TR(tMSH9,tSeps,":_~\&"))
]]></Implementation>
</Method>

<Method name="GetMsgType">
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tPiece3=$P(pName,"_",3,99)
	Quit $S(""'=tPiece3&&((tPiece3["_")||(tPiece3["&")||(tPiece3["\S\")||(tPiece3["\T\")):$P(pName,"_",1,2),1:pName)
]]></Implementation>
</Method>

<Method name="TypeVersionGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$Case(..GetValueAt("1:0"),"FHS":"Batch", "BHS":"Batch", :$TR(..GetValueAt("1:12"),..Separators,":_~\&"))
]]></Implementation>
</Method>

<Method name="IdentifierGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$TR($Case(..GetValueAt("1:0"),"FHS":..GetValueAt("1:11"), "BHS":..GetValueAt("1:11"), :..GetValueAt("1:10")),..Separators,":_~\&")
]]></Implementation>
</Method>

<Method name="SegCountGet">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	If $D($$$vaM("runtimeIndex")) Quit $$$vaM("runtimeIndex")
	Set count=0,path="" For  Set path=$O($$$vaM("runtimePath",path)) Quit:path=""  Set count=count+1
	Quit count
]]></Implementation>
</Method>

<Method name="RawContentGet">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..OutputToString()
]]></Implementation>
</Method>

<Method name="DocTypeSecondaryGet">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..DocTypeName
]]></Implementation>
</Method>

<Method name="FullSizeGet">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Do:'$D($$$vaM("runtimeIndex"))&&$D($$$vaM("runtimePath")) ..buildRuntimeIndexFromPath()
	Set tLen=0 For i=1:1:$G($$$vaM("runtimeIndex")) { Set tSeg=..getSegmentByIndex(i)
		If 'tSeg.IsChildHolder(.tRef) { Set tLen=tLen+tSeg.FullSize+1 }
		Do ..commitSegmentByIndex(i)
	}
	Quit tLen
]]></Implementation>
</Method>

<Method name="GetFullSize">
<ClassMethod>1</ClassMethod>
<FormalSpec>pMsgId</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set tLen=0 For i=1:1:$$$vaExtentGbl(pMsgId,"segs") {
		#; Add segment size: - 5 separators + 1 terminator
		Set segid=$$$vaExtentGbl(pMsgId,"segs",i), tLen = tLen + $S(segid[",":$L($$$vaSegment(segid)),1:$L($$$vaSegmentGbl(segid))) - 4
		#; Get extra from any segs > max seg length
		For j=1:1 { Set segid=$$$vaExtentGbl(pMsgId,"segs",i)  If segid["," { Quit:'$D($$$vaSegmentExt(segid,j),extra) } Else { Quit:'$D($$$vaSegmentGbl(segid,j),extra) }
			Set tLen = tLen + $L(extra)
		}
	}
	Quit tLen
]]></Implementation>
</Method>

<Method name="GetLengthCRC">
<FormalSpec><![CDATA[pLen:%String=0,&pCRC:%String=0,pSeparators:%String,pSequenceNumber:%String,pMSHEncoding:%String,pLenLen:%Integer=5,pCRCLen:%Integer=3]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tLen=pLen
	Set tSeparators=$E($G(pSeparators,..Separators),1,5)
	Do:'$D($$$vaM("runtimeIndex"))&&$D($$$vaM("runtimePath")) ..buildRuntimeIndexFromPath()
	For i=1:1:$G($$$vaM("runtimeIndex")) { Set tSeg=..getSegmentByIndex(i)
		If 'tSeg.IsChildHolder(.tRef) { Set tString=tSeg.OutputToString(tSeparators,.pSequenceNumber,,.pMSHEncoding) Set pCRC=$ZCRC(tString,1,pCRC), tLen=tLen+$L(tString) }
		Else {
			Set tChild=$$$NULLOREF For { Set tChild=..NextChild(tChild,tRef)  Quit:tChild=$$$NULLOREF
				Set tLen=tChild.GetLengthCRC(tLen,.pCRC, tSeparators,.pSequenceNumber,.pMSHEncoding)
			}
		}
	}
	Set pCRC=$$$NUM(pCRC,pCRCLen), tLen=$$$NUM(tLen,pLenLen)
	Quit tLen
]]></Implementation>
</Method>

<Method name="GetNextIndex">
<Description>
Gets the next index in an array</Description>
<FormalSpec><![CDATA[pPath:%String,pIndex:%String,&pStatus:%Status=$$$OK]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set f=$F(pPath,"()")  If 'f Set pStatus=$$$ERROR($$$EnsErrGeneral,"Can't iterate on SegmentPath '"_pPath_"'") Quit ""
	Set tSegmentPath=$P(pPath,":",1)
	If f-1>$L(tSegmentPath) { ; '()' was found in PropertyPath not SegmentPath
		Set tPropertyPath=$P(pPath,":",2)
		Set tSegObj=..GetSegmentAt(tSegmentPath,.pStatus) Quit:$$$ISERR(pStatus) ""
		Quit tSegObj.GetNextIndex(tPropertyPath,pIndex,.pStatus)
	} Else {
		Set tHead=$E(pPath,1,f-2), tLen=$L(tHead)
		Quit:"("=tHead $S(+pIndex<..SegCount:pIndex+1,1:"") ; iterate by index if path is just "()"
		Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)
		If '$D($$$vaM("loopIndex",tHead)) {
			#; Build LoopIndex node
			Set path=tHead For { Set path=$O($$$vaM("runtimePath",path))  Quit:path=""
				Quit:$E(path,1,tLen)'=tHead
				Set $$$vaM("loopIndex",tHead,$E(path,tLen+1,$F(path,")",tLen)-2))=""
			}
			If '$D($$$vaM("loopIndex",tHead)) Set $$$vaM("loopIndex",tHead)=0
		}
		Quit $O($$$vaM("loopIndex",tHead,pIndex))
	}
]]></Implementation>
</Method>

<Method name="GetNextGroupPath">
<Description>
Gets the next path in a group</Description>
<FormalSpec><![CDATA[pGroup:%String,pPath:%String,&pStatus:%Status=$$$OK]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Quit:$$$vaIsIndex(pGroup) ""
	If pGroup[":"||($L(pPath)<$L(pGroup)) Set pStatus=$$$ERROR($$$EnsErrGeneral,"Can't iterate in Group '"_pGroup_"' on Path '"_pPath_"'") Quit ""
	Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)
	Set nextpath=$O($$$vaM("runtimePath",pPath))
	Quit:$E(nextpath,1,$L(pGroup))'=pGroup||$Case($E(nextpath,$L(pGroup)+1),"(":0,".":0,:1) ""
	Quit nextpath
]]></Implementation>
</Method>

<Method name="SetValueAt">
<FormalSpec>pValue:%String,pSegmentPropertyPath:%String,pAction:%String="set",pKey:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If pSegmentPropertyPath["()" {
		Set tSC=$$$OK
		Set tFind=$F(pSegmentPropertyPath,"()")
		Set tHead=$E(pSegmentPropertyPath,1,tFind-3), tTail=$E(pSegmentPropertyPath,tFind,*)
		Set k=$P(pKey,","), pKey=$P(pKey,",",2,$L(pKey,","))
		If k { Set tSC=..SetValueAt(.pValue,tHead_"("_(k)_")"_tTail,pAction,pKey) Quit:$$$ISERR(tSC) }
		Else {
			Set i="" For { Set i=..GetNextIndex(tHead_"()",i) Quit:i=""
				Set tNewPath=tHead_"("_(i)_")"_tTail
				Set tSC=..SetValueAt(.pValue,tNewPath,pAction,pKey) Quit:$$$ISERR(tSC)
			}
		}
		Quit tSC
	}
	Set tGrpPath=$P(pSegmentPropertyPath,":"), tPropPath=$P(pSegmentPropertyPath,":",2)
	Set tSegPath=..GetNextGroupPath(tGrpPath,tGrpPath)
	If ""'=tSegPath { ; if there are group sub-elements
		For {
			Set tNewPath=tSegPath_$S(""=tPropPath:"",1:":"_tPropPath)
			Set tSC=..SetValueAt(.pValue,tNewPath,pAction,pKey) Quit:$$$ISERR(tSC)
			Set tSegPath=..GetNextGroupPath(tGrpPath,tSegPath,.tSC) Quit:$$$ISERR(tSC)
			Quit:""=tSegPath
		}
		Quit tSC
	} Else {
		Quit:(pAction="remove")&&(""=tPropPath) ..RemoveSegmentAt(tGrpPath)
		Set tSegObj=..GetMutableSegmentAt(tGrpPath,.tSC)  Quit:$$$ISERR(tSC) tSC  $$$ASSERT($IsObject(tSegObj))
		Quit tSegObj.SetValueAt(.pValue,tPropPath,pAction,pKey)
	}
]]></Implementation>
</Method>

<Method name="GetValueAt">
<FormalSpec>pSegmentPropertyPath:%String,pSeparators:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pStatus=$$$OK, tSeparators=$G(pSeparators,..Separators)
	Set tSegmentPath=$P(pSegmentPropertyPath,":"), tPropertyPath=$P(pSegmentPropertyPath,":",2)
	If ""=tPropertyPath&&(tSegmentPath["*") {
		Quit:$Case(tSegmentPath,"*":1,"(*)":1,:0) ..SegCount
		Set tLen=$L(tSegmentPath)
		If $E(tSegmentPath,tLen-2,tLen)="(*)" {
			Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)
			Set count=0, (path,path0)=$E(tSegmentPath,1,tLen-2), tLen0=$L(path0), i=0
			For { Set path=$O($$$vaM("runtimePath",path))  Quit:path=""||(path0'=$E(path,1,tLen0))
				Set ti=+$E(path,tLen0+1,*)  Set:ti'=i&&ti count=count+1,i=ti
			}
			Quit count
		}
		If $E(tSegmentPath,tLen-1,tLen)=".*" {
			Set count=0,(path,path0)=$E(tSegmentPath,1,tLen-2),tLen0=$L(path0)
			Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)
			For { Set path=$O($$$vaM("runtimePath",path))  Quit:path=""||(path0'=$E(path,1,tLen0))  Set count=count+1 }
			Quit count
		}
		Quit $$$ERROR($$$EnsErrGeneral,"Invalid segment count value path '"_tSegmentPath_"'")
	}
	Set tSegObj=..GetSegmentAt(tSegmentPath,.pStatus)  Quit:'$IsObject(tSegObj) ""  $$$ASSERT($$$ISOK(pStatus))
	Quit tSegObj.GetValueAt(tPropertyPath,tSeparators,.pStatus)
]]></Implementation>
</Method>

<Method name="GetSegmentPath">
<Description>
Given a segment index, find the corresponding segment path</Description>
<FormalSpec>pIndex:%Integer,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If '$D($$$vaM("bidirectionalLink")) {
		If '$D($$$vaM("runtimePath")) { Set pStatus=$$$ERROR($$$EnsErrGeneral,"Document is in index-only mode")  Quit "" }
		Else { Set pStatus=$$$ERROR($$$EnsErrGeneral,"Document is in path-only mode")  Quit "" }
	}
	Set pStatus=$$$OK
	Set tVal=$G($$$vaM("bidirectionalLink",+pIndex))
	Set:""=tVal pStatus=$$$ERROR($$$EnsErrGeneral,"Index "_pIndex_" is out of bounds")
	Quit tVal
]]></Implementation>
</Method>

<Method name="GetSegmentIndex">
<Description>
Given a segment path, find the corresponding segment index</Description>
<FormalSpec>pPath:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	If '$D($$$vaM("bidirectionalLink")) {
		If '$D($$$vaM("runtimePath")) { Set pStatus=$$$ERROR($$$EnsErrGeneral,"Document is in index-only mode")  Quit "" }
		Else { Set pStatus=$$$ERROR($$$EnsErrGeneral,"Document is in path-only mode")  Quit "" }
	}
	Set pStatus=$$$OK
	Set tVal=$G($$$vaM("bidirectionalLink",pPath))
	Set:""=tVal||(tVal'=+tVal) pStatus=$$$ERROR($$$EnsErrGeneral,"Path "_pPath_" not found")
	Quit tVal
]]></Implementation>
</Method>

<Method name="FindSegmentValuesArray">
<Description>
Finds all values matching a SegName:PropertyPath string, where the SegName is a simple segment type name
 (not a full schema-based seg path); PropertyPath describes a field or subfield within the segment.
Supports SegName = '*' to match any segment, and SegName(n) to match only the n'th segment of the given type.</Description>
<FormalSpec><![CDATA[pSegmentPropertyPath:%String,pSeparators:%String,&pArray:%String,*pStatus:%Status,pSchemaCategory:%String="",&pLongArray:%String]]></FormalSpec>
<Implementation><![CDATA[
	Set pStatus=$$$OK  Kill pArray
	Set tSegName=$P(pSegmentPropertyPath,":"), tPropPath=$P(pSegmentPropertyPath,":",2)
	Set tSegIndex=$P(tSegName,"(",2), tSegName=$P(tSegName,"("), tSegIndex=$ZStrip($P(tSegIndex,")"),"<>W","*")
	Do:$ZStrip(tPropPath,"*A")'=tPropPath&&(""'=..DocType)&&(""=..BuildMapStatus) ..BuildMap(0) ; get seg types if available
	Set tIndex="" For i=1:1 { Set tSegObj=..FindSegment(tSegName,.tIndex,.pStatus)  Quit:""=tIndex
		Continue:(""'=tSegIndex)&&(i'=tSegIndex) ; if they asked for a specific number, forsake all others
		Do tSegObj.FindValuesArray(tPropPath,.pSeparators,.pArray,.pSchemaCategory,.pStatus,.pLongArray)  Quit:$$$ISERR(pStatus)
		Quit:i=tSegIndex ;all done
	}
]]></Implementation>
</Method>

<Method name="FindSegmentValues">
<Description><![CDATA[
Finds all values matching a SegName:PropertyPath string, where the SegName is a simple segment type name
 (not a full schema-based seg path); PropertyPath describes a field or subfield within the segment. <br>
Supports SegName = '*' to match any segment, and SegName(n) to match only the n'th segment of the given type. <br>
Final parameter is an output of the list of segment indexes (separated by pValSepString) for the values found.]]></Description>
<FormalSpec><![CDATA[pSegmentPropertyPath:%String,pSeparators:%String,pValSepString:%String="<>",*pStatus:%Status,pSchemaCategory:%String="",*pIndices:%String]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pStatus=$$$OK, pIndices = ""
	Set tSegName=$P(pSegmentPropertyPath,":"), tPropPath=$P(pSegmentPropertyPath,":",2)
	Set tSegIndex=$P(tSegName,"(",2), tSegName=$P(tSegName,"("), tSegIndex=$ZStrip($P(tSegIndex,")"),"<>W","*")
	Do:$ZStrip(tPropPath,"*A")'=tPropPath&&(""'=..DocType)&&(""=..BuildMapStatus) ..BuildMap(0) ; get seg types if available
	Set (tVals,tIndex)="" For i=1:1 { Set tSegObj=..FindSegment(tSegName,.tIndex,.pStatus)  Quit:""=tIndex
		Continue:(""'=tSegIndex)&&(i'=tSegIndex) ; if they asked for a specific number, forsake all others
		Set tVal=tSegObj.FindValues(tPropPath,.pSeparators,pValSepString,.pSchemaCategory,.pStatus)  Quit:$$$ISERR(pStatus)
		If (""'=tVal) {
			Set tVals=$S(""=tVals:"",1:tVals_pValSepString)_tVal
			For tR=1:1:$L(tVal,pValSepString) Set pIndices = $S(""=pIndices:"",1:pIndices_pValSepString)_tIndex
		}
		Quit:i=tSegIndex ;all done
	}
	Quit tVals
]]></Implementation>
</Method>

<Method name="FindSegment">
<Description><![CDATA[
Gets the next segment after index <var>pIndex</var> with name <var>pSegName</var>.
Supports <var>pSegName</var> = '*' to match any segment.]]></Description>
<FormalSpec><![CDATA[pSegName:%String,&pIndex:%String="",*pStatus:%Status]]></FormalSpec>
<ReturnType>EnsLib.HL7.Segment</ReturnType>
<Implementation><![CDATA[
	Set pStatus=$$$OK, tId=..%Id()  Set:'tId tId=..%ClonedId
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath()
	Set seg=""  For index=+pIndex+1:1:$$$vaM("runtimeIndex") { Set seg=$$$vaSegLookthru(index,tId)  Continue:""=seg
		If $$$vaIsOref(seg) {
			Set tSegObj=..%maps("orefs",index)
			If (pSegName="*")||(tSegObj.Name=pSegName) Set pIndex=index  Quit
		} Else {
			Set segid=$P(seg,"|"), data=$G($$$vaSegment(segid))
			If (pSegName="*")||(pSegName=$$$vaDataSegName(data)) {
				#; Same code as in getSegmentByIndex
				Set pIndex=index
				Set tSegObj=##class(EnsLib.HL7.Segment).%New($LB(segid,(..IsMutable&&(tId=..%ClonedId)),$P(seg,"|",2)))
				Set ..%maps("orefs",pIndex)=tSegObj
				Set $$$vaM("runtimeIndex",pIndex)="@"
				Set path=$G($$$vaM("bidirectionalLink",pIndex)) Set:""'=path $$$vaM("runtimePath",path)="@"_pIndex
				Quit
			}
		}
	}
	If +pIndex<index Set pIndex=""  Quit $$$NULLOREF
	Quit tSegObj
]]></Implementation>
</Method>

<Method name="getSegmentByIndex">
<Internal>1</Internal>
<FormalSpec>pIndex:%Integer,*pStatus:%Status</FormalSpec>
<ReturnType>EnsLib.HL7.Segment</ReturnType>
<Implementation><![CDATA[
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath()
	Set pStatus=$$$OK, tId=..%Id()  Set:'tId tId=..%ClonedId
	Set seg=$$$vaSegLookthru(pIndex,tId)
	If seg="" Set pStatus=$$$ERROR($$$EnsErrGeneral,"Segment Index "_pIndex_" is out of bounds") Quit $$$NULLOREF
	Quit:$$$vaIsOref(seg) ..%maps("orefs",pIndex)
	Set tSegObj=##class(EnsLib.HL7.Segment).%New($LB($P(seg,"|"),(..IsMutable&&..CacheSegsGotten&&(tId=..%ClonedId)),$P(seg,"|",2)))
	If ..CacheSegsGotten {
		Set ..%maps("orefs",pIndex)=tSegObj
		Set $$$vaM("runtimeIndex",pIndex)="@"
		Set path=$G($$$vaM("bidirectionalLink",pIndex)) Set:""'=path $$$vaM("runtimePath",path)="@"_pIndex
	}
	Quit tSegObj
]]></Implementation>
</Method>

<Method name="getSegmentByPath">
<Internal>1</Internal>
<FormalSpec>pPath:%String,*pStatus:%Status</FormalSpec>
<ReturnType>EnsLib.HL7.Segment</ReturnType>
<Implementation><![CDATA[
	Set pStatus=$$$OK
	Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)
	Set seg=$G($$$vaM("runtimePath",pPath))
	If seg="" Set pStatus=$$$ERROR($$$EnsErrGeneral,"No segment found at path '"_pPath_"'") Quit $$$NULLOREF
	Quit:$$$vaIsOref(seg) ..%maps("orefs",$E(seg,2,*))
	Set tSegObj=##class(EnsLib.HL7.Segment).%New($LB($P(seg,"|"),(..IsMutable&&..CacheSegsGotten&&'..%Id()&&..%ClonedId),$P(seg,"|",2)))
	If ..CacheSegsGotten {
		Set index=$G($$$vaM("bidirectionalLink",pPath))
		If index { Set seg="@"_index, $$$vaM("runtimeIndex",index)="@" }
		Else { Set index=$O(..%maps("orefs",""))-1, seg="@"_index}
		Set ..%maps("orefs",index)=tSegObj
		Set $$$vaM("runtimePath",pPath)=seg
	}
	Quit tSegObj
]]></Implementation>
</Method>

<Method name="getSegmentIdByIndex">
<FormalSpec>pIndex:%Integer,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pStatus=$$$OK, tId=..%Id()  Set:'tId tId=..%ClonedId
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath()
	Set seg=$$$vaSegLookthru(pIndex,tId)
	If seg="" Set pStatus=$$$ERROR($$$EnsErrGeneral,"Index "_pIndex_" is out of bounds") Quit ""
	Quit:'$$$vaIsOref(seg) $P(seg,"|")
	Quit ..%maps("orefs",pIndex).ID
]]></Implementation>
</Method>

<Method name="getSegmentIdByPath">
<FormalSpec>pPath:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pStatus=$$$OK
	Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)
	Set seg=$G($$$vaM("runtimePath",pPath))
	Quit:'$$$vaIsOref(seg) $P(seg,"|")
	Quit ..%maps("orefs",$E(seg,2,*)).ID
]]></Implementation>
</Method>

<Method name="getMutableSegmentByIndex">
<Internal>1</Internal>
<FormalSpec>pIndex:%Integer,*pStatus:%Status</FormalSpec>
<ReturnType>EnsLib.HL7.Segment</ReturnType>
<Implementation><![CDATA[
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath()
	Set pStatus=$$$OK, i%BuildMapStatus="", tId=..%Id()  Set:'tId tId=..%ClonedId
	Set seg=$$$vaSegLookthru(pIndex,tId)
	If seg="" Set pStatus=$$$ERROR($$$EnsErrGeneral,"Index "_pIndex_" is out of bounds")  Quit $$$NULLOREF
	If $$$vaIsOref(seg) {
		Set tSegObj=..%maps("orefs",pIndex)
		If tSegObj.IsMutable Set tSegObj.Separators=..Separators  Quit tSegObj
		Kill ..%maps("orefs",pIndex)
		Set seg=tSegObj.ID_"|"_tSegObj.DocType
	}
	;Set tSegObj=..NewSegment(pPath)
	Set tSegObj=##class(EnsLib.HL7.Segment).%New($LB($P(seg,"|"),1,$P(seg,"|",2)))
	If '$IsObject(tSegObj)  Set pStatus=%objlasterror  Quit $$$NULLOREF
	Set tSegObj.Separators=..Separators
	Set ..%maps("orefs",pIndex)=tSegObj
	Set $$$vaM("runtimeIndex",pIndex)="@"
	Set path=$G($$$vaM("bidirectionalLink",pIndex)) Set:""'=path $$$vaM("runtimePath",path)="@"_pIndex
	Quit tSegObj
]]></Implementation>
</Method>

<Method name="getMutableSegmentByPath">
<Internal>1</Internal>
<FormalSpec>pPath:%String,*pStatus:%Status</FormalSpec>
<ReturnType>EnsLib.HL7.Segment</ReturnType>
<Implementation><![CDATA[
	If (..DocTypeCategory="")||(..DocTypeName="") Set pStatus=$$$ERROR($$$EnsErrGeneral,"Cannot recognize path before DocType is set")  Quit $$$NULLOREF
	Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)
	Set pStatus=$$$OK, i%BuildMapStatus=""
	Set seg=$G($$$vaM("runtimePath",pPath))
	If $$$vaIsOref(seg) {
		Set index=$E(seg,2,*)
		Set tSegObj=..%maps("orefs",index)
		If tSegObj.IsMutable Set tSegObj.Separators=..Separators  Quit tSegObj
		Kill ..%maps("orefs",index)
		Set seg=$S(""=tSegObj.ID:"", 1:tSegObj.ID_$S(""=tSegObj.DocType:"", 1:"|"_tSegObj.DocType))
	}
	If ""=seg {
		;Set tSegObj=..NewSegment(pPath)
		Set schema=$G($$$vaSchemaGbl(..DocTypeCategory,"MS",..DocTypeName,"map",..convertRuntimePathToSchemaPath(pPath)))
		If schema="" Set pStatus=$$$ERROR($$$EnsErrGeneral,"Path '"_pPath_"' is not mapped in schema for DocType '"_..DocType_"'")  Quit $$$NULLOREF
		Set tSegType=$P(schema,"|",2), tSegName=$P(tSegType,":",2)
		If $ZCVT(tSegName,"U")'=tSegName Set pStatus=$$$ERROR($$$EnsErrGeneral,"Cannot instantiate abstract segment type "_tSegType)  Quit $$$NULLOREF
		Set tSegObj=##class(EnsLib.HL7.Segment).%New($LB("",1,tSegType,$E(..Separators,1,5)_tSegName))
		If '$IsObject(tSegObj) Set pStatus=%objlasterror  Quit $$$NULLOREF
		#;Do tSegObj.SetValueAt(tSegName,0)
		Kill $$$vaM("runtimeIndex"), $$$vaM("bidirectionalLink") ; we are operating only by PathMap now.
		Set index=$O(..%maps("orefs",""))-1, seg="@"_index
	} Else {
		Set tSegObj=##class(EnsLib.HL7.Segment).%New($LB($P(seg,"|"),1,$P(seg,"|",2)))
		If '$IsObject(tSegObj) Set pStatus=%objlasterror  Quit $$$NULLOREF
		Set index=$G($$$vaM("bidirectionalLink",pPath))
		If index { Set seg="@"_index, $$$vaM("runtimeIndex",index)="@" }
		Else { Set index=$O(..%maps("orefs",""))-1, seg="@"_index }
	}
	Set tSegObj.Separators=..Separators
	Set ..%maps("orefs",index)=tSegObj
	Set $$$vaM("runtimePath",pPath)=seg
	If ..AutoBuildMap { Do ..BuildMap(0) }
	Else {
		Set i%BuildMapStatus=""
		#; Add relevant loopIndex node(s) if any
		Set pcs=$L(pPath,"(")-1, tHead=$P(pPath,"(",1,pcs)_"("
		For { Set tHead=$O($$$vaM("loopIndex",tHead_")"),-1), tLen=$L(tHead)  Quit:""=tHead
			If tHead=$E(pPath,1,tLen) { Set $$$vaM("loopIndex",tHead,$E(pPath,tLen+1,$F(pPath,")",tLen)-2))="", pcs=pcs-1, tHead=$P(pPath,"(",1,pcs)_"(" }
			Else {
				Set tPart="" For pcs=1:1 { Set tPrevPart=tPart, tPart=$P(pPath,"(",1,pcs)_"(", tLen=$L(tPart)
					If tPart'=$E(tHead,1,tLen) { Set tHead=tPrevPart  Quit }
				}
			}
			Quit:""=tHead||'pcs
		}
	}
	Quit tSegObj
]]></Implementation>
</Method>

<Method name="setSegmentByIndex">
<Internal>1</Internal>
<FormalSpec>pSegObj:EnsLib.HL7.Segment,pIndex:%Integer,pInsert:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsMutable $$$ERROR($$$EnsErrGeneral,"Object is immutable")
	Quit:'$$$IsdefObject(pSegObj) $$$ERROR($$$EnsErrGeneral,"Cannot set null segment object at index "_pIndex)
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath()
	Quit:(pIndex\1'=pIndex)||(pIndex<1)||(pIndex>($$$vaM("runtimeIndex")+1)) $$$ERROR($$$EnsErrGeneral,"Index "_pIndex_" is out of bounds")

	If pInsert {
		Set tId=..%Id()  Set:'tId tId=..%ClonedId  For i=$$$vaM("runtimeIndex"):-1:pIndex { ; slide up all segments to make room for inserted one
			Set $$$vaM("runtimeIndex",i+1)=$$$vaSegLookthru(i,tId)
			If $D(..%maps("orefs",i)) Set ..%maps("orefs",i+1)=..%maps("orefs",i)  Kill ..%maps("orefs",i)
		}
		Set path=""
	} Else {
		Set path=$G($$$vaM("bidirectionalLink",pIndex))  Set:""'=path $$$vaM("runtimePath",path)="@"_pIndex
	}
	If pInsert||(pIndex=($$$vaM("runtimeIndex")+1)) Set $$$vaM("runtimeIndex")=$$$vaM("runtimeIndex")+1

	Set $$$vaM("runtimeIndex",pIndex)="@"
	Set pSegObj.DocType="" ; setting by index, the SegType might not match its new position
	Set ..%maps("orefs",pIndex)=pSegObj

	Kill:""=path $$$vaM("runtimePath"), $$$vaM("bidirectionalLink"), $$$vaM("loopIndex") ; we are operating only by IndexMap now.
	If ..AutoBuildMap { Do ..BuildMap(0) } Else { Set i%BuildMapStatus="" }
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="setSegmentByPath">
<Internal>1</Internal>
<FormalSpec>pSegObj:EnsLib.HL7.Segment,pPath:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsMutable $$$ERROR($$$EnsErrGeneral,"Object is immutable")
	Quit:(..DocTypeCategory="")||(""=..DocTypeName) $$$ERROR($$$EnsErrGeneral,"Cannot recognize path before DocType is set")
	Quit:'$$$IsdefObject(pSegObj) $$$ERROR($$$EnsErrGeneral,"Cannot set null segment object at position "_pPath)
	Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)

	Set schema=$G($$$vaSchemaGbl(..DocTypeCategory,"MS",..DocTypeName,"map",..convertRuntimePathToSchemaPath(pPath)))
	Quit:""=schema $$$ERROR($$$EnsErrGeneral,"Path '"_pPath_"' is not mapped in schema for DocType '"_..DocType_"'")
	Set tSegType=$P(schema,"|",2), tSegName=$P(tSegType,":",2)
	Quit:'$Case(tSegName, pSegObj.Name:1, "Zxx":("Z"=$E(pSegObj.Name)), "Hxx":("H"=$E(pSegObj.Name)), "Any":1, :0) $$$ERROR($$$EnsErrGeneral,"Cannot set segment named '"_pSegObj.Name_"' for type '"_tSegName_"' at position "_pPath)
	Set pSegObj.DocType=tSegType ; setting by path, Set the SegType to match its new position

	Set index=$G($$$vaM("bidirectionalLink",pPath))
	If index { Set seg="@"_index, $$$vaM("runtimeIndex",index)="@" }
	Else {
		Set seg=$G($$$vaM("runtimePath",pPath))
		If $$$vaIsOref(seg) { Set index=$E(seg,2,*) }
		Else {
			Set index=$O(..%maps("orefs",""))-1, seg="@"_index
			Kill $$$vaM("runtimeIndex"), $$$vaM("bidirectionalLink") ; we are operating only by PathMap now.
		}
	}
	Set ..%maps("orefs",index)=pSegObj
	Set $$$vaM("runtimePath",pPath)=seg
	If ..AutoBuildMap { Do ..BuildMap(0) }
	Else {
		Set i%BuildMapStatus=""
		#; Add relevant loopIndex node(s) if any
		Set pcs=$L(pPath,"(")-1, tHead=$P(pPath,"(",1,pcs)_"("
		For { Set tHead=$O($$$vaM("loopIndex",tHead_")"),-1), tLen=$L(tHead)  Quit:""=tHead
			If tHead=$E(pPath,1,tLen) { Set $$$vaM("loopIndex",tHead,$E(pPath,tLen+1,$F(pPath,")",tLen)-2))="", pcs=pcs-1, tHead=$P(pPath,"(",1,pcs)_"(" }
			Else {
				Set tPart="" For pcs=1:1 { Set tPrevPart=tPart, tPart=$P(pPath,"(",1,pcs)_"(", tLen=$L(tPart)
					If tPart'=$E(tHead,1,tLen) { Set tHead=tPrevPart  Quit }
				}
			}
			Quit:""=tHead||'pcs
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="setSegmentIdByIndex">
<Internal>1</Internal>
<FormalSpec>pSegId:%String,pIndex:%Integer,pInsert:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsMutable $$$ERROR($$$EnsErrGeneral,"Object is immutable")
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath()
	Quit:(pIndex\1'=pIndex)||(pIndex<1)||(pIndex>($$$vaM("runtimeIndex")+1)) $$$ERROR($$$EnsErrGeneral,"Index "_pIndex_" is out of bounds")

	If pInsert {
		Set tId=..%Id()  Set:'tId tId=..%ClonedId  For i=$$$vaM("runtimeIndex"):-1:pIndex { ; slide up all segments to make room for inserted one
			Set $$$vaM("runtimeIndex",i+1)=$$$vaSegLookthru(i,tId)
			If $D(..%maps("orefs",i)) Set ..%maps("orefs",i+1)=..%maps("orefs",i)  Kill ..%maps("orefs",i)
		}
		Set path=""
	} Else {
		Set path=$G($$$vaM("bidirectionalLink",pIndex))  Set:""'=path $$$vaM("runtimePath",path)="@"_pIndex
	}
	If pInsert||(pIndex=($$$vaM("runtimeIndex")+1)) Set $$$vaM("runtimeIndex")=$$$vaM("runtimeIndex")+1

	Set $$$vaM("runtimeIndex",pIndex)=pSegId

	Kill:""=path $$$vaM("runtimePath"), $$$vaM("bidirectionalLink"), $$$vaM("loopIndex") ; we are operating only by IndexMap now.
	If ..AutoBuildMap { Do ..BuildMap(0) } Else { Set i%BuildMapStatus="" }
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="setSegmentIdByPath">
<Internal>1</Internal>
<FormalSpec>pSegId:%String,pPath:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsMutable $$$ERROR($$$EnsErrGeneral,"Object is immutable")
	Quit:(..DocTypeCategory="")||(..DocTypeName="") $$$ERROR($$$EnsErrGeneral,"Cannot recognize path unless DocType is set")
	Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)

	Set schema=$G($$$vaSchemaGbl(..DocTypeCategory,"MS",..DocTypeName,"map",..convertRuntimePathToSchemaPath(pPath)))
	Quit:""=schema $$$ERROR($$$EnsErrGeneral,"Path '"_pPath_"' is not mapped in schema for DocType '"_..DocType_"'")
	Set newseg=pSegId_"|"_$P(schema,"|",2)

	Set index=$G($$$vaM("bidirectionalLink",pPath))
	If index { Kill ..%maps("orefs",index)  Set $$$vaM("runtimeIndex",index)=newseg }
	Else {
		Set seg=$G($$$vaM("runtimePath",pPath))
		If $$$vaIsOref(seg) { Kill ..%maps("orefs",$E(seg,2,*)) }
		Else {
			Kill $$$vaM("runtimeIndex"), $$$vaM("bidirectionalLink") ; we are operating only by PathMap now.
		}
	}
	Set $$$vaM("runtimePath",pPath)=newseg
	If ..AutoBuildMap { Do ..BuildMap(0) } Else { Set i%BuildMapStatus="" }
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="removeSegmentByIndex">
<Internal>1</Internal>
<FormalSpec>pIndex:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsMutable $$$ERROR($$$EnsErrGeneral,"Object is immutable")
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath()
	Set tId=..%Id()  Set:'tId tId=..%ClonedId
	Set seg=$$$vaSegLookthru(pIndex,tId)
	Quit:""=seg $$$ERROR($$$EnsErrGeneral,"Index "_pIndex_" is out of bounds")

	For i=pIndex:1:$$$vaM("runtimeIndex")-1 { ; slide all segments down over removed one
		Set $$$vaM("runtimeIndex",i)=$$$vaSegLookthru(i+1,tId)
		If $D(..%maps("orefs",i+1)) Set ..%maps("orefs",i)=..%maps("orefs",i+1)  Kill ..%maps("orefs",i+1)
	}
	Kill $$$vaM("runtimeIndex",$$$vaM("runtimeIndex")), ..%maps("orefs",$$$vaM("runtimeIndex"))
	Set $$$vaM("runtimeIndex")=$$$vaM("runtimeIndex")-1

	Kill $$$vaM("runtimePath"), $$$vaM("bidirectionalLink"), $$$vaM("loopIndex") ; we are operating only by IndexMap now.
	If ..AutoBuildMap { Do ..BuildMap(0) } Else { Set i%BuildMapStatus="" }
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="removeSegmentByPath">
<Internal>1</Internal>
<FormalSpec>pPath:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsMutable $$$ERROR($$$EnsErrGeneral,"Object is immutable")
	Quit:(..DocTypeCategory="")||(..DocTypeName="") $$$ERROR($$$EnsErrGeneral,"Cannot recognize path before DocType is set")
	Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)

	Set seg=$G($$$vaM("runtimePath",pPath))  If seg="" Quit $$$ERROR($$$EnsErrGeneral,"No segment found at path '"_pPath_"'")
	If $$$vaIsOref(seg) { Kill ..%maps("orefs",$E(seg,2,*)) }
	Kill $$$vaM("runtimePath",pPath)

	Kill $$$vaM("runtimeIndex"), $$$vaM("bidirectionalLink") ; we are operating only by PathMap now.
	If ..AutoBuildMap { Do ..BuildMap(0) }
	Else {
		Set i%BuildMapStatus=""
		If pPath["(" {
			#; Invalidate relevant loopIndex sub-arrays if any
			Set tPathHead=$P(pPath,"(",$L(pPath,"(")-1)
			Set tHead=tPathHead For { Set tHead=$O($$$vaM("loopIndex",tHead))  Quit:tPathHead_"("'=$E(tHead,1,$L(tPathHead)+1)
				Kill $$$vaM("loopIndex",tHead)
			}
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="commitSegmentByIndex">
<Description>
collapse segment object into just ID; Save if necessary</Description>
<FormalSpec>pIndex:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath()
	Quit:(pIndex<1)||(pIndex>$$$vaM("runtimeIndex")) $$$ERROR($$$EnsErrGeneral,"Index "_pIndex_" is out of bounds")
	Set seg=$G($$$vaM("runtimeIndex",pIndex))
	Quit:'$$$vaIsOref(seg) $$$OK
	Set tSegObj=..%maps("orefs",pIndex)
	If tSegObj.IsMutable Set tSC=tSegObj.SaveData(..Separators) Quit:$$$ISERR(tSC) tSC
	Set newseg=tSegObj.ID_$S(""=tSegObj.DocType:"", 1:"|"_tSegObj.DocType)
	Set $$$vaM("runtimeIndex",pIndex)=newseg
	Set path=$G($$$vaM("bidirectionalLink",pIndex)) Set:""'=path $$$vaM("runtimePath",path)=newseg
	Kill ..%maps("orefs",pIndex)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="commitSegmentByPath">
<Description>
collapse segment object into just Id; Save if necessary</Description>
<FormalSpec>pPath:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do:'$D($$$vaM("runtimePath")) ..BuildMap(0)
	Set seg=$G($$$vaM("runtimePath",pPath))
	If seg="" Quit $$$ERROR($$$EnsErrGeneral,"No segment found at path '"_pPath_"'")
	If '$$$vaIsOref(seg) Quit $$$OK
	Set index=$E(seg,2,*)
	Set tSegObj=..%maps("orefs",index)
	If tSegObj.IsMutable Set tSC=tSegObj.SaveData(..Separators) Quit:$$$ISERR(tSC) tSC
	Set newseg=tSegObj.ID_$S(""=tSegObj.DocType:"", 1:"|"_tSegObj.DocType)
	Set $$$vaM("runtimePath",pPath)=newseg
	Kill ..%maps("orefs",index)
	Set index=$G($$$vaM("bidirectionalLink",pPath)) Set:""'=index $$$vaM("runtimeIndex",index)=newseg
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="convertRuntimePathToSchemaPath">
<FormalSpec>pPath:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tOutput=pPath
	Set f=0 For {
		Set f=$F(tOutput,"(",f) Quit:f=0
		Set g=$F(tOutput,")",f) If g=0 Set tOutput="" quit
		Set tOutput=$E(tOutput,1,f-1)_$E(tOutput,g-1,*)
		Set f=g
	}
	Quit tOutput
]]></Implementation>
</Method>

<Method name="getOrderKeyFromRuntimePath">
<Description>
Given a runtime path, this method generates the key used for collation</Description>
<Internal>1</Internal>
<FormalSpec>pRuntimePath:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSchemaPath=pRuntimePath, tRuntimeIndex=0
	Set f=0 For {
		Set f=$F(tSchemaPath,"(",f) Quit:f=0
		Set g=$F(tSchemaPath,")",f) If g=0 Set tSchemaPath="" Quit
		Set tRuntimeIndex($I(tRuntimeIndex))=$E(tSchemaPath,f,g-2)
		Set tSchemaPath=$E(tSchemaPath,1,f-1)_$E(tSchemaPath,g-1,*)
		Set f=g
	}
	Quit:""=tSchemaPath ""
	Set tMapValue=$G($$$vaSchemaGbl(..DocTypeCategory,"MS",..DocTypeName,"map",tSchemaPath))  Quit:""=tMapValue ""
	Set tKey=$P(tMapValue,"|")
	Set f=1 For i=1:1:tRuntimeIndex {
		Set f=$F(tKey,"*",f)  Quit:'f
		Set $E(tKey,f-1)=$$$NUM(tRuntimeIndex(i),8)
	}
	#; If couldn't find a replacement position or there are remaining unfilled replacement positions then key is invalid
	Quit:tKey["*"||'f ""
	Quit tKey
]]></Implementation>
</Method>

<Method name="buildRuntimeIndexFromPath">
<Internal>1</Internal>
<FormalSpec>pClearSegTypes:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$ASSERT('$D($$$vaM("runtimeIndex"))&&'$D($$$vaM("bidirectionalLink")))
	Set tPath="" For { Set tPath=$O($$$vaM("runtimePath",tPath))  Quit:""=tPath
		Set tOrderKey=..getOrderKeyFromRuntimePath(tPath)  Continue:""=tOrderKey
		Set $$$vaM("OrderKeyToRuntimePath",tOrderKey)=tPath
	}
	#; Re-Order mapOrefs according to new index sequence.
	Set key="",index=0 For { Set key=$O($$$vaM("OrderKeyToRuntimePath",key),1,tPath)  Quit:key=""
		Set seg=$$$vaM("runtimePath",tPath)
		Set index=index+1
		If $$$vaIsOref(seg) {
			Set oldindex=$E(seg,2,*)
			Set tSegObj=..%maps("orefs",oldindex)
			Set:pClearSegTypes tSegObj.DocType=""
			If oldindex'=index {
				Set $$$vaM("runtimePath",tPath)="@"_index  Kill ..%maps("orefs",oldindex)
				#; Migrate ..mapOrefs if needed rather than doing it in place, because re-ordering in Path mode may have occurred after runtimeIndex map was killed
				If $D(..%maps("orefs",index)) { Set tMapOrefs(index)=tSegObj } Else { Set ..%maps("orefs",index)=tSegObj }
			}
			Set $$$vaM("runtimeIndex",index)="@"
		} Else {
			Set:pClearSegTypes seg=$P(seg,"|")
			Set $$$vaM("runtimeIndex",index)=seg
		}
		Set $$$vaM("bidirectionalLink",index)=tPath, $$$vaM("bidirectionalLink",tPath)=index
	}
	Kill $$$vaM("OrderKeyToRuntimePath")
	Merge ..%maps("orefs")=tMapOrefs
	Set $$$vaM("runtimeIndex")=index, $$$vaM("runtimeIndex",0)="" ; set a marker for negative path indices
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnConstructClone">
<FormalSpec><![CDATA[object:%RegisteredObject,deep:%Boolean=0,&cloned:%String]]></FormalSpec>
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$vaMgetIndex

#ifndef LOCALMAPS
	#; copy runtime maps from old instance
	Merge $$$vaM("runtimePath")=$$$vaMobj(object,"runtimePath")
	Merge $$$vaM("bidirectionalLink")=$$$vaMobj(object,"bidirectionalLink")
	Set tId=object.%Id()  Merge:tId $$$vaM("runtimeIndex")=$$$vaExtentGbl(tId,"segs") ; no lookthru to other guy's Id
	Merge $$$vaM("runtimeIndex")=$$$vaMobj(object,"runtimeIndex")
#endif	
	#; Clone segment objects so the clone can continue to use them without changing the original's data or properties
	Set index="" For { Set index=$O(object.%maps("orefs",index),1,tSegObj)  Quit:""=index
		Set ..%maps("orefs",index)=tSegObj.%ConstructClone()
	}
	Set i%IsMutable=1, ..ParentId="" ; mark it mutable, don't keep parent relationships
	Set i%%ClonedId=object.%ClonedId  Set:'..%ClonedId i%%ClonedId=object.%Id()  Set:'..%ClonedId i%%ClonedId=0
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnNew">
<Description>
create an object based on id=initvalue but editable</Description>
<FormalSpec>initvalue:%CacheString=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSegmentIds=$LG(initvalue,1), ..Separators=$LG(initvalue,2), i%Source=$LG(initvalue,3), i%ParentId=$LG(initvalue,4)
	Set:""=..Separators ..Separators=$$$HL7DefSeparators
	$$$vaMgetIndex
	If tSegmentIds'="" {
		Set $$$vaM("runtimeIndex")=$LL(tSegmentIds), $$$vaM("runtimeIndex",0)="" ; set a marker for negative path indices
		For i=1:1:$$$vaM("runtimeIndex") { Set $$$vaM("runtimeIndex",i)=$LI(tSegmentIds,i) }
	} Else { ; Automatically construct an MSH because every message should have one
		Set msh=##class(EnsLib.HL7.Segment).%New()
		Set msh.Separators=..Separators
		Do msh.SetValueAt("MSH",0)
		Set $$$vaM("runtimeIndex")=1, $$$vaM("runtimeIndex",1)="@"
		Set ..%maps("orefs",1)=msh
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnOpen">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tId=..%Id()
	$$$vaMgetIndex
	Set oldSegIdList=..IsMutable
	If $E(oldSegIdList)'=oldSegIdList {
		#; open object from old 3.0 storage format
		Set ..IsMutable=0, ..ParentId="", ..Envelope=..Source, ..Source="old storage"
		Set cnt=$LL(oldSegIdList), $$$vaM("runtimeIndex")=cnt, $$$vaM("runtimeIndex",0)=""
		For i=1:1:cnt Set $$$vaM("runtimeIndex",i)=$LG(oldSegIdList,i,0)
		If cnt { Set tSegid=$$$vaM("runtimeIndex",1), ..Separators=$E($$$vaSegment(tSegid),1,5) } Else { Set ..Separators=$$$HL7DefSeparators }
	} Else {
		Set:+..ParentId'=$P(..ParentId,":") ..ParentId=$LG(..ParentId) ; change from 4.0 %parentIds format
		Set cnt=$G($$$vaExtentGbl(tId,"segs")), $$$vaM("runtimeIndex")=cnt, $$$vaM("runtimeIndex",0)="" ; set a marker for negative path indices
		If 'cnt { Set ..Separators=$$$HL7DefSeparators }
		Else {
			If $S($D($$$EnsConfig("HL7Segs-Compat")):$$$EnsConfig("HL7Segs-Compat"),1:$G(^Ens.Config("HL7Segs-Compat"),1)) {
				#; convert segments from old 2008.1 storage if needed
				Lock +$$$vaExtentGbl(tId):2
				If $Test {
					Set tJK=$$$JobKey
					Set:'$D(%topSegIndex) %topSegIndex=$G($$$vaSegmentGbl(tJK)), tNoTop=1
					For iSeg=1:1:cnt {	Set oldsegid=$G($$$vaExtentGbl(tId,"segs",iSeg))
						If oldsegid&&(oldsegid'[",") {
							#; found a segment to convert
							Lock +$$$vaSegment(oldsegid):2
							If $Test {
								TStart
								TRY {
									If $D(convertedSegs(oldsegid), convsegid) {
										#; segments processed on this run
										Set $$$vaExtentGbl(tId,"segs",iSeg)=convsegid
									}
									ElseIf $D($$$vaSegmentGbl(oldsegid),data) && (+data'=data) {
										#; seg has data, still in old form
										If $D($$$vaSegmentGbl(tJK),jkdata) && (+jkdata'=jkdata) {
											#; destination key already has old data - got to move it
											Merge dtree=$$$vaSegmentGbl(tJK)  Kill $$$vaSegmentGbl(tJK)  Set $$$vaSegmentGbl(tJK)=1
											Set segid=tJK_",1"  Merge $$$vaSegment(segid)=dtree  Kill dtree
											#; Update references from any other messages to this segment
											Set id="",did=0  For { Set id=$O($$$vaSegmentRef(segid,id)) Quit:""=id  Continue:id=tId
												Set xsegid="" For s=$G($$$vaExtentGbl(id,"segs"),0):-1:1 {
													Set xsegid=$G($$$vaExtentGbl(id,"segs",s))
													Set:xsegid=tJK $$$vaExtentGbl(id,"segs",s)=segid, did=1
												}
												Kill:'did $$$vaSegmentRef(segid,id) ; if obj has no 
											}
										}
										Set segid=tJK_","_$I(%topSegIndex)
										Merge dtree=$$$vaSegmentGbl(oldsegid)  Kill $$$vaSegmentGbl(oldsegid)  Merge $$$vaSegment(segid)=dtree  Kill dtree
										Set $$$vaExtentGbl(tId,"segs",iSeg)=segid
										#; Update references from any other messages to this segment
										Set id="",did=0  For { Set id=$O($$$vaSegmentRef(segid,id)) Quit:""=id  Continue:id=tId
											Set xsegid="" For s=$G($$$vaExtentGbl(id,"segs"),0):-1:1 {
												Set xsegid=$G($$$vaExtentGbl(id,"segs",s))
												Set:xsegid=oldsegid $$$vaExtentGbl(id,"segs",s)=segid, did=1
											}
											Kill:'did $$$vaSegmentRef(segid,id)
										}
										Set convertedSegs(oldsegid) = segid
									}
									Set $$$vaSegmentGbl(tJK)=%topSegIndex
									TCommit
								} CATCH err {
									TRollback
								}
								Lock -$$$vaSegment(oldsegid)
							}
						}
					}
					Kill:$G(tNoTop) %topSegIndex
					Lock -$$$vaExtentGbl(tId)
				}
			}
			Set ..Separators=$E($$$vaSegment($$$vaExtentGbl(tId,"segs",1)),1,5)
		}
	}
	Set i%DocTypeCategory=$P(..DocType,":",1)
	Set i%DocTypeName=$P(..DocType,":",2)
	#; No automatic BuildMap here - allow cheap instantiation for routing etc; do BuildMap() only when called for
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnAfterSave">
<FormalSpec>insert:%Boolean</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK, tId=..%Id()
	Do:'$D($$$vaM("runtimeIndex"))&&$D($$$vaM("runtimePath")) ..buildRuntimeIndexFromPath()
	Set count=+$G($$$vaM("runtimeIndex"))  For index=1:1:count { Set seg=$$$vaSegLookthru(index,..%ClonedId)
		If $$$vaIsOref(seg) {
			Set tSegObj=..%maps("orefs",index)
			Set tSC=tSegObj.SaveData(..Separators)  Quit:$$$ISERR(tSC)
			Set segid=tSegObj.ID
		} Else {
			Set segid=$P(seg,"|")
		}
		Set:segid $$$vaExtentGbl(tId,"segs",index)=segid, $$$vaSegmentRef(segid,tId)=""
	}
	For index=count+1:1:+$G($$$vaExtentGbl(tId,"segs")) { Kill $$$vaExtentGbl(tId,"segs",index) } ; Kill leftovers if we shrank
	Set $$$vaExtentGbl(tId,"segs")=count
	Set i%%ClonedId=0
	Quit tSC
]]></Implementation>
</Method>

<Method name="PokeDocType">
<CodeMode>expression</CodeMode>
<FormalSpec>pDocType:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..DocTypeSet(pDocType,0)
]]></Implementation>
</Method>

<Method name="PokeTypeCategory">
<FormalSpec>pMessageTypeCategory:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[ Set i%MessageTypeCategory=pMessageTypeCategory  Quit $$$OK
]]></Implementation>
</Method>

<Method name="DocTypeSet">
<FormalSpec>pDocType:%String,pBuildMap:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:pDocType=..DocType&&$D($$$vaM("runtimePath")) $$$OK ; nothing is changed

	#; convert runtimePath to runtimeIndex and then Kill runtimePath
	Do:'$D($$$vaM("runtimeIndex"))&&$D($$$vaM("runtimePath")) ..buildRuntimeIndexFromPath(1) ; 1 = clear types
	Kill $$$vaM("runtimePath"), $$$vaM("bidirectionalLink"), $$$vaM("loopIndex")
	Set i%DocType=pDocType
	Set i%DocTypeCategory=$P(pDocType,":",1)
	Set i%DocTypeName=$P(pDocType,":",2)
	Do:pBuildMap ..BuildMap()
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="BuildMap">
<Description>
pKeepParsingAfterError means keep trying to parse after errors are encountered; returned Status will contain all errors encountered</Description>
<FormalSpec>pKeepParsingAfterError:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If ((""=..DocTypeCategory)||(""=..DocTypeName)) {
		Set i%BuildMapStatus=$S(""=..DocType:"", 1:$$$ERROR($$$EnsEDIErrMapDocType,"HL7",..DocType))
	} Else {
		Quit:$D($$$vaM("runtimePath"))&&(""'=..BuildMapStatus) ..BuildMapStatus ; already done
		Set i%BuildMapStatus=""
	}
	Do:'$D($$$vaM("runtimeIndex")) ..buildRuntimeIndexFromPath(1) ; 1 = clear types
	Kill $$$vaM("runtimePath"), $$$vaM("bidirectionalLink"), $$$vaM("loopIndex")

	Quit:""=..DocType $$$OK
	Quit:""'=..BuildMapStatus ..BuildMapStatus

	Set tSchema=$G($$$vaSchemaGbl(..DocTypeCategory,"MS",..DocTypeName))
	If tSchema="" {
		Set i%BuildMapStatus=$$$ERROR($$$EnsEDIErrMapDocType,"HL7",..DocType)
		Quit ..BuildMapStatus
	}
	Set tId=..%Id()  Set:'tId tId=..%ClonedId
	Set tCurrSeg=1, %seglastmatch=0, %pathlastmatch=""
	Set tSC=..buildRuntimePathFromIndex(tId,"",$Name($$$vaSchemaGbl)_"("""_..DocTypeCategory_""",""MS"","""_..DocTypeName_""",""array"")","top",.tCurrSeg,0,$$$OK,pKeepParsingAfterError)
	$$$ASSERT(%seglastmatch=(tCurrSeg-1))
	#; Map leftover segments
	Set tSegments=$$$vaM("runtimeIndex")
	If tCurrSeg<=tSegments {
		Set tNotZ=0,tNotZName=""
		For i=tCurrSeg:1:tSegments {
			#; Find current Segment's Type Name
			Set seg=$$$vaSegLookthru(i,tId)
			If $$$vaIsOref(seg) {
				Set tSegObj=..%maps("orefs",i)
				Set currsegname=tSegObj.Name
				Set $$$vaM("runtimePath","leftoversegs("_(i+1-tCurrSeg)_")")="@"_i
			} Else {
				Set segid=$P(seg,"|"), data=$G($$$vaSegment(segid))
				Set currsegname=$$$vaDataSegName(data)
				Set $$$vaM("runtimePath","leftoversegs("_(i+1-tCurrSeg)_")")=segid
			}
			If 'tNotZ&&$Case($E(currsegname),"Z":0, "H":0, :1) { Set tNotZ=i, tNotZName=currsegname }
			ElseIf ""=tNotZName { Set tNotZName=currsegname }
		}
		If pKeepParsingAfterError||$$$ISOK(tSC) {
			Set tcurr=$S(tNotZ:tNotZ,1:tCurrSeg) ; use the first non-Z leftover seg to complain about; if all leftovers are Z's then use the first leftover
			Set currname=tcurr_":'"_tNotZName_"'"
			If tCurrSeg=1 { Set lastname="" }
			Else {
				#; Find previous Segment's Type Name
				Set seg=$$$vaSegLookthru(tCurrSeg-1,tId)
				If $$$vaIsOref(seg) {
					Set tSegObj=..%maps("orefs",tCurrSeg-1)
					Set lastname=tSegObj.Name
				} Else {
					Set segid=$P(seg,"|"), data=$G($$$vaSegment(segid))
					Set lastname=$$$vaDataSegName(data)
				}
			}
			Set lastmatch=$S(""'=lastname&&%seglastmatch:%seglastmatch_" ("_%pathlastmatch_")", 1:"0")
			Set tNewSC=$S(tNotZ: $$$ERROR($$$EnsEDIErrMapSegUnrecog,currname,lastmatch)
				,"Z"'=$E(lastname):  $$$ERROR($$$EnsEDIErrMapWildSegUnrecog,currname,lastmatch,"Z")
				,1:                  $$$ERROR($$$EnsEDIErrMapWildSegUnrecogAfterWild,currname,lastmatch,"Z"))
			Set tSC=$$$ADDSC(tSC,tNewSC)
		}
	}
	Kill %seglastmatch, %pathlastmatch
	Set i%BuildMapStatus=tSC
	Quit tSC
]]></Implementation>
</Method>

<Method name="buildRuntimePathFromIndex">
<Description><![CDATA[
Build a segment map for the current segment index array based on the document schema<br>
If <var>pKeepParsingAfterError</var> is false then stop parsing when first error is encountered<br>]]></Description>
<FormalSpec><![CDATA[pId:%String,pPath:%String,pContentArray:%String,pType:%String,&pCurrSeg:%Integer,pParentGrpOpt:%Boolean,pSC:%Status,pKeepParsingAfterError:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSegments=$$$vaM("runtimeIndex"), currsegname=""
	Set type=$P(pType,"(",1,$L(pType,"(")), len=$L(type), tIsUnion="union"=$E(type,len+1-$L("union"),len)
	Set tGrpOpt=(pParentGrpOpt||$G(@pContentArray@("opt"),0)), tFirstReq="", tGrpSeg=pCurrSeg
	For i=1:1:$G(@pContentArray) { ; loop over sub-elements of the root element at this level
		Set pIContents=$Name(@pContentArray@(i))
		Set opt=$G(@pIContents@("opt"),0), tFirstReq=$S(""=tFirstReq&&'opt:1, ""=tFirstReq:"", 1:0)
		Set type=@pIContents@("type")
		Set segtype=$S(type[":":$P(type,":",3),1:"-"_type)
		Set isrep=$P(segtype,"(",2), tMaxReps=$Case(isrep, ")":0, "":1, :+isrep), isrep=(""'=isrep), tRequiredReps='opt
		Set segtype=$P(segtype,"(")
		Set segname=$P(@pIContents@("name"),"(")
		Set subs=$G(@pIContents,0)
		Set tISeg=pCurrSeg
		For rep=1:1 { Quit:rep>tMaxReps&&tMaxReps ; loop for repetitions of the current sub-element
			Set tBaseSeg=pCurrSeg
			Set tIPath=$S(""=pPath:"",1:pPath_".")_segname_$S(isrep:"("_rep_")",1:"")
			#;If isrep&&(rep=1)&&(i=1)&&opt Set pSC=$$$ADDSC(pSC,$$$ERROR($$$EnsEDIErrMapGeneral,"Schema error at "_tIPath_" - the first element in a repeating group must not be optional"))  Quit

			If subs {
				Set pSC=..buildRuntimePathFromIndex(pId,tIPath,pIContents,type,.pCurrSeg,tGrpOpt||(rep>tRequiredReps),pSC,pKeepParsingAfterError)
			} Else {
				#; Find current Segment's Type Name
				If pCurrSeg>tSegments {
					Set currsegname=""
				} Else {
					Set seg=$$$vaSegLookthru(pCurrSeg,pId)
					If $$$vaIsOref(seg) {
						Set tSegObj=..%maps("orefs",pCurrSeg)
						Set currsegname=tSegObj.Name
					} Else {
						Set segid=$P(seg,"|"), data=$G($$$vaSegment(segid))
						Set currsegname=$$$vaDataSegName(data)
					}
				}
				#; Check for segment type match
				If $Case(segtype, currsegname:1, "Zxx":("Z"=$E(currsegname)), "Hxx":("H"=$E(currsegname)), "Any":(""'=currsegname), :0)  {	
					#; Set seg address/schema at path into runtimePath
					Set schema=$P($P(type,":",2,3),"(")
					Set seg=$$$vaSegLookthru(pCurrSeg,pId)
					If $$$vaIsOref(seg) {
						Set $$$vaM("runtimePath",tIPath)="@"_pCurrSeg
						Set ..%maps("orefs",pCurrSeg).DocType=schema
					} Else {
						Set seg=$P(seg,"|")_"|"_schema
						Set $$$vaM("runtimeIndex",pCurrSeg)=seg
						Set $$$vaM("runtimePath",tIPath)=seg
					}
					Set $$$vaM("bidirectionalLink",pCurrSeg)=tIPath, $$$vaM("bidirectionalLink",tIPath)=pCurrSeg

					Set %seglastmatch=pCurrSeg, %pathlastmatch=tIPath
					Set:pCurrSeg<=tSegments pCurrSeg=pCurrSeg+1, currsegname=""
				}
			}
			If tBaseSeg=pCurrSeg { ; found no match in repeat loop
				Set:rep<tRequiredReps&&'tIsUnion&&'tGrpOpt pSC=$$$ADDSC(pSC,$$$ERROR($$$EnsEDIErrMapSegCount,tRequiredReps,tIPath,pCurrSeg_$S(""=$G(currsegname):"",1:" ("_currsegname_")")))
				Quit
			} Else {
				Set tGrpOpt=0
				Quit:pCurrSeg>tSegments
			}
		}
		Quit:$$$ISERR(pSC)&&'pKeepParsingAfterError
		If tISeg=pCurrSeg { ; found no match at element i
			If 'opt&&'tIsUnion {
				Quit:i=1
				Set:'tGrpOpt pSC=$$$ADDSC(pSC,$$$ERROR($$$EnsEDIErrMapRequired,tIPath,pCurrSeg_$S(""=$G(currsegname):"",1:" ("_currsegname_")")))
				Quit:tFirstReq||'pKeepParsingAfterError
			}
		} Else {
			Set tGrpOpt=0
			Quit:tIsUnion
		}
	}
	If tIsUnion {
		If tGrpSeg=pCurrSeg { ; found no match in any union element
			Set:'tGrpOpt pSC=$$$ADDSC(pSC,$$$ERROR($$$EnsEDIErrMapRequiredUnion,pPath,pCurrSeg_$S(""=$G(currsegname):"",1:" ("_currsegname_")")))
		}
	}
	Quit pSC
]]></Implementation>
</Method>

<Method name="DumpMaps">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set DocType=..DocType w ! zw DocType
	w !,"DocTypeCategory,DocTypeName="_..DocTypeCategory_","_..DocTypeName
	Set BuildMapStatus=..BuildMapStatus w ! zw BuildMapStatus
	If ""'=..DocTypeCategory&&(""'=..DocTypeName) {
		Merge mapSchemaPath=$$$vaSchemaGbl(..DocTypeCategory,"MS",..DocTypeName,"map") w ! zw mapSchemaPath
		Merge mapContentArray=$$$vaSchemaGbl(..DocTypeCategory,"MS",..DocTypeName,"array") w ! zw mapContentArray
	}
	Merge mapRuntimeIndex=$$$vaM("runtimeIndex") w ! zw mapRuntimeIndex
	Merge mapRuntimePath=$$$vaM("runtimePath") w ! zw mapRuntimePath
	Merge mapBidirectionalLink=$$$vaM("bidirectionalLink") w ! zw mapBidirectionalLink
	Merge mapLoopIndex=$$$vaM("loopIndex") w ! zw mapLoopIndex
 	Merge mapOrefs=..%maps("orefs") w ! zw mapOrefs
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetContentArray">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>*pContents,pMode:%String,pDocType:%String,pLevel:%Integer,pIncludeBase:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(EnsLib.HL7.Schema).GetContentArray(.pContents,.pMode,.pDocType,.pLevel,.pIncludeBase)
]]></Implementation>
</Method>

<Query name="EnumerateDocTypes">
<Description><![CDATA[
Returns a list of available DocTypes for this document class. <br/>
The DocType is returned as the first column in the result set. <br/>
The <var>Category</var> parameter can be used to restrict the list. <br/>
If <var>Category</var> is: <br/>
 0 - return only DocTypes in standard categories <br/>
 + - return only DocTypes in user-defined categories <br/>
 empty - return DocTypes from all categories <br/>
 a category name - return only DocTypes in the named category <br/>
 a partial name suffixed with '%' - return only DocTypes in categories matching the partial category name <br/>
 other - return nothing <br/>
If <var>IncludeBase</var> is: <br/>
 0 - return only DocTypes defined in the current schema category itself <br/>
 1 - return all DocTypes in the current schema category's base category in addition to those defined in the current category itself <br/>]]></Description>
<Type>%Query</Type>
<FormalSpec>Category:%String="",IncludeBase:%Boolean=0</FormalSpec>
<Parameter name="CONTAINID" value="0"/>
<Parameter name="ROWSPEC" value="Type:%String"/>
</Query>

<Method name="EnumerateDocTypesExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary,Category:%String,IncludeBase:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(EnsLib.HL7.Schema).MessageStructuresExecute(.qHandle,.Category,.IncludeBase)
]]></Implementation>
</Method>

<Method name="EnumerateDocTypesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer]]></FormalSpec>
<PlaceAfter>EnumerateDocTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=##class(EnsLib.HL7.Schema).MessageStructuresFetch(.qHandle,.Row,.AtEnd)
	Set:""'=$G(Row) Row=$LB($LG(Row))
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnumerateDocTypesClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateDocTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(EnsLib.HL7.Schema).MessageStructuresClose(.qHandle)
]]></Implementation>
</Method>

<Query name="EnumerateMessageTypes">
<Description><![CDATA[
Returns a list of available MessageTypes for this document class. <br/>
The MessageTypes is returned as the first column in the result set. <br/>
The <var>Category</var> parameter can be used to restrict the list. <br/>
If <var>Category</var> is: <br/>
 0 - return only MessageTypes in standard categories <br/>
 + - return only MessageTypes in user-defined categories <br/>
 empty - return MessageTypes from all categories <br/>
 a category name - return only MessageTypes in the named category <br/>
 a partial name suffixed with '%' - return only MessageTypes in categories matching the partial category name <br/>
 other - return nothing <br/>
If <var>IncludeBase</var> is: <br/>
 0 - return only MessageTypes defined in the current schema category itself <br/>
 1 - return all MessageTypes in the current schema category's base category in addition to those defined in the current category itself <br/>]]></Description>
<Type>%Query</Type>
<FormalSpec>Category:%String="",IncludeBase:%Boolean=0</FormalSpec>
<Parameter name="CONTAINID" value="0"/>
<Parameter name="ROWSPEC" value="Type:%String"/>
</Query>

<Method name="EnumerateMessageTypesExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary,Category:%String,IncludeBase:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(EnsLib.HL7.Schema).MessageTypesExecute(.qHandle,.Category,.IncludeBase)
]]></Implementation>
</Method>

<Method name="EnumerateMessageTypesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer]]></FormalSpec>
<PlaceAfter>EnumerateDocTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=##class(EnsLib.HL7.Schema).MessageTypesFetch(.qHandle,.Row,.AtEnd)
	Set:""'=$G(Row) Row=$LB($LG(Row))
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnumerateMessageTypesClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateDocTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(EnsLib.HL7.Schema).MessageTypesClose(.qHandle)
]]></Implementation>
</Method>

<Query name="EnumerateTypeCategories">
<Description><![CDATA[
Returns a list of document type schema categories for the document class.<br>
The <var>Standard</var> parameter can be used to restrict the list.<br>
If <var>Standard</var> is:
 0 - return only standard categories
 + - return only user-defined categories
 empty - return all categories
 a partial category name - return only categories starting with the given category name part<br/>
 other - return nothing]]></Description>
<Type>%Query</Type>
<FormalSpec>Standard:%String=""</FormalSpec>
<Parameter name="CONTAINID" value="0"/>
<Parameter name="ROWSPEC" value="Category:%String,Description:%String,IsStandard:%Boolean,Base:%String"/>
</Query>

<Method name="EnumerateTypeCategoriesExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary,Standard:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(EnsLib.HL7.Schema).TypeCategoriesExecute(.qHandle, Standard)
]]></Implementation>
</Method>

<Method name="EnumerateTypeCategoriesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer]]></FormalSpec>
<PlaceAfter>EnumerateTypeCategoriesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=##class(EnsLib.HL7.Schema).TypeCategoriesFetch(.qHandle,.Row,.AtEnd)
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnumerateTypeCategoriesClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateTypeCategoriesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(EnsLib.HL7.Schema).TypeCategoriesClose(.qHandle)
]]></Implementation>
</Method>

<Query name="EnumerateSegTypes">
<Description><![CDATA[
Returns a list of schema categories and segment types and segment fields for this document class. <br/>
The <var>Category</var> and <var>Level</var> parameters can be used to restrict the list. <br/>
If <var>Category</var> is: <br/>
 0 - return only standard categories <br/>
 + - return only user-defined categories <br/>
 empty - return all categories <br/>
 a category name - return only SegTypes in the named category <br/>
 a category name:segment type name - return only information about the named SegType <br/>
 a partial name suffixed with '%' - return only SegTypes in categories matching the partial category name <br/>
 other - return nothing <br/>
If <var>Level</var> is: <br/>
 0 - return all segment names <br/>
 n - return the given number of levels of nested field names within each segment <br/>
 empty - return all levels of nested field names within each segment <br/>
If <var>IncludeBase</var> is: <br/>
 0 - return only segment names defined in the current schema category itself <br/>
 1 - return all segment names in the current schema category's base category in addition to those defined in the current category itself <br/>]]></Description>
<Type>%Query</Type>
<FormalSpec>Category:%String="",Level:%String="",IncludeBase:%Boolean=0</FormalSpec>
<Parameter name="CONTAINID" value="0"/>
<Parameter name="ROWSPEC" value="SegType:%String,Field:%String,Description:%String,IsStandard:%Boolean"/>
</Query>

<Method name="EnumerateSegTypesExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary,Category:%String,Level:%String,IncludeBase:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(EnsLib.HL7.Schema).SegTypesExecute(.qHandle,.Category,.Level,.IncludeBase)
]]></Implementation>
</Method>

<Method name="EnumerateSegTypesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer]]></FormalSpec>
<PlaceAfter>EnumerateSegTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=##class(EnsLib.HL7.Schema).SegTypesFetch(.qHandle,.Row,.AtEnd)
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnumerateSegTypesClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateSegTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(EnsLib.HL7.Schema).SegTypesClose(.qHandle)
]]></Implementation>
</Method>

<Method name="GetAlias">
<Description>
This method computes the Alias string for a property name, given the property's node in the Content Array.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pContentArrayName:%String,pArrayPos:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[##class(EnsLib.HL7.Schema).GetAlias(pContentArrayName,pArrayPos)
]]></Implementation>
</Method>

<Method name="checkDocType">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pDocType:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Set category=$P(pDocType,":",1)
	Set secondary=$P(pDocType,":",2)
	If $P(secondary,"_")="ACK" Set secondary="ACK"
	If (""=category)||(""=secondary)||(""=$G($$$vaSchemaGbl(category,"MS",secondary))) {
		Set tSC=$$$ERROR($$$EnsEDIErrMapDocType,"HL7",pDocType)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="getSegsAsString">
<Description>
This method is for use from the RawContent property's SQL Compute invocation</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pId:%String,pMaxLen:%Integer=10000,pStartOffset:%Integer=1</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#; Use delimiters from first segment, translate all subsequent delims to those
	Set str=""  For index=1:1:+$G($$$vaExtentGbl(pId,"segs")) { Set segid=$$$vaExtentGbl(pId,"segs",index), data=$S(segid[",":$G($$$vaSegment(segid)),1:$G($$$vaSegmentGbl(segid)))
		Set:index=1 tSeparators=$E(data,1,5)
		Set:tSeparators'=$E(data,1,5) data=##class(EnsLib.HL7.Segment).replaceSeparators(data, tSeparators)
		If pStartOffset>1 {
			If pStartOffset>($L(data)-5+1) { Set pStartOffset=pStartOffset-($L(data)-5+1) }
			Else { Set pStartOffset=1, data=$E(data,pStartOffset,*) }
		}
		If pMaxLen-$L(str)>=($L(data)-5+1) { Set str=str_$E(data,6,*)_$C($$$HL7DefSegTerminatorAscii) }
		Else { Set str=str_$E(data_$S($L(data)<pMaxLen:$C($$$HL7DefSegTerminatorAscii),1:""),6,5+pMaxLen-$L(str)) }
		Quit:$L(str)>=pMaxLen
	}
	Quit str
]]></Implementation>
</Method>

<Method name="OutputToFile">
<FormalSpec>pFilename:%String,pOverwrite:%Boolean,pSeparators:%String,pSequenceNumber:%String,pIOFormatClassname:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tIOStream=##Class(%IO.FileStream).%New()
	Do tIOStream.Open(pFilename,$S($G(pOverwrite):"NEW",1:"AEW"),5,,.tSC)  Quit:$$$ISERR(tSC) tSC
	Quit ..OutputToIOStream(tIOStream, .pSeparators, .pSequenceNumber, , .pIOFormatClassname)
]]></Implementation>
</Method>

<Method name="OutputToDevice">
<Description>
Note: order of args is reversed for OutputToDevice() so we can pretend to be a Stream and pass the Sequence number in place of pLen.</Description>
<FormalSpec>pSequenceNumber:%String,pSeparators:%String,pIOFormatClassname:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tDeviceStream=##class(%IO.DeviceStream).AttachNew(,.tSC)  Quit:$$$ISERR(tSC) tSC
	Quit ..OutputToIOStream(tDeviceStream, .pSeparators, .pSequenceNumber, , .pIOFormatClassname)
]]></Implementation>
</Method>

<Method name="OutputToOldStream">
<Description>
deprecated - use OutputToLibraryStream</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pOldStream:%Stream.Object,pSeparators:%String,pSequenceNumber:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..OutputToLibraryStream(.pOldStream, .pSeparators, .pSequenceNumber)
]]></Implementation>
</Method>

<Method name="OutputToLibraryStream">
<FormalSpec>pLibStream:%Stream.Object,pSeparators:%String,pSequenceNumber:%String,pIOFormatClassname:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tIOStream=$S(pLibStream.%Extends("%IO.I.CharacterStream"):pLibStream, 1:##Class(%IO.MetaCharacterStream).%New(pLibStream))
	Quit ..OutputToIOStream(tIOStream, .pSeparators, .pSequenceNumber, , .pIOFormatClassname)
]]></Implementation>
</Method>

<Method name="OutputToString">
<FormalSpec>pSeparators:%String,pSequenceNumber:%String,*pStatus:%Status,pIOFormatClassname:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tIOStream=##Class(%IO.StringStream).%New()
	Set pStatus = ..OutputToIOStream(tIOStream, .pSeparators, .pSequenceNumber, , .pIOFormatClassname)
	Do tIOStream.Rewind()
	Quit tIOStream.Read()
]]></Implementation>
</Method>

<Method name="OutputToIOStream">
<FormalSpec>pIOStream:%IO.I.CharacterStream,pSeparators:%String,pSequenceNumber:%String,pFlush:%Boolean=1,pIOFormatClassname:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Set tSeparators=$S(""=$G(pSeparators):..Separators, 1:pSeparators)
	If ""=pIOFormatClassname || '$classmethod(pIOFormatClassname,"OutputDocument",$this,.tSC,pIOStream,tSeparators,.pSequenceNumber) {
		Do:'$D($$$vaM("runtimeIndex"))&&$D($$$vaM("runtimePath")) ..buildRuntimeIndexFromPath()
		For i=1:1:$G($$$vaM("runtimeIndex")) { Set tSeg=..getSegmentByIndex(i)
			If 'tSeg.IsChildHolder(.tRef) { Set tSC=tSeg.OutputToIOStream(pIOStream, tSeparators, .pSequenceNumber, i, $G($$$vaM("bidirectionalLink",i),i), $this, pIOFormatClassname) }
			Else {
				Set tChild=$$$NULLOREF For { Set tChild=..NextChild(tChild,tRef)  Quit:tChild=$$$NULLOREF
					Set tSC=tChild.OutputToIOStream(pIOStream, tSeparators, .pSequenceNumber, 0, pIOFormatClassname)  Quit:$$$ISERR(tSC)
				}
			}
			Do ..commitSegmentByIndex(i)
		}
		Do:""'=pIOFormatClassname $classmethod(pIOFormatClassname,"OutputDocumentEnd",$this,.tSC,pIOStream,tSeparators)
	}
	If pFlush Do pIOStream.Flush(.tSC1)  Set:$$$ISOK(tSC) tSC=tSC1
	Quit tSC
]]></Implementation>
</Method>

<Method name="OutputHTML">
<Description>
Display Segments as HTML, using DocType info if available</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Set tSeparators=..Separators  Set:""=tSeparators tSeparators=$$$HL7DefSeparators Set:""=$$$SEGTERM(tSeparators) tSeparators=tSeparators_..SegmentTerminator  Set $$$SEGTERM(tSeparators)=$ZStrip($$$SEGTERM(tSeparators),"*CW")
	Quit ..OutputToDevice(,tSeparators,"EnsLib.HL7.Util.FormatHTMLv2")
]]></Implementation>
</Method>

<Method name="OutputHTMLZen">
<Description>
Display Segments as HTML, using DocType info if available</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Set tSeparators=..Separators  Set:""=tSeparators tSeparators=$$$HL7DefSeparators Set:""=$$$SEGTERM(tSeparators) tSeparators=tSeparators_..SegmentTerminator  Set $$$SEGTERM(tSeparators)=$ZStrip($$$SEGTERM(tSeparators),"*CW")
	Quit ..OutputToDevice(,tSeparators,"EnsLib.HL7.Util.FormatHTMLv2Zen")
]]></Implementation>
</Method>

<Method name="ImportFromFile">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pFilename:%String,pDocNum:%Integer=1,*pStatus:%Status,&pConfigItem:%String,pIOFormatClassname:%String]]></FormalSpec>
<ReturnType>EnsLib.HL7.Message</ReturnType>
<Implementation><![CDATA[
	Set tIOStream=##Class(%IO.FileStream).%New()
	Do tIOStream.Open(pFilename,,5,,.pStatus)  Quit:$$$ISERR(pStatus) $$$NULLOREF
	$$$sysTRACE("Opened file '"_pFilename_"'")
	Set tDoc=$$$NULLOREF  For i=1:1:pDocNum {
		If tIOStream.AtEnd Set pStatus=$$$ERROR($$$EnsErrGeneral,"Fewer than "_pDocNum_" messages in file "_pFilename)  Quit
		Set tDoc=..ImportFromIOStream(tIOStream,.pStatus,.pConfigItem,.pIOFormatClassname)  Quit:$$$ISERR(pStatus)
	}
	Quit:$$$ISERR(pStatus) $$$NULLOREF
	Quit tDoc
]]></Implementation>
</Method>

<Method name="ImportFromDevice">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*pStatus:%Status,&pConfigItem:%String,pIOFormatClassname:%String]]></FormalSpec>
<ReturnType>EnsLib.HL7.Message</ReturnType>
<Implementation><![CDATA[
	Set tDeviceStream=##class(%IO.DeviceStream).AttachNew(,.tSC)  Quit:$$$ISERR(tSC) tSC
	Quit ..ImportFromIOStream(tDeviceStream,.pStatus,.pConfigItem,.pIOFormatClassname)
]]></Implementation>
</Method>

<Method name="ImportFromOldStream">
<Description>
deprecated - use ImportFromLibraryStream</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[pOldStream:%Stream.Object,*pStatus:%Status,&pConfigItem:%String]]></FormalSpec>
<ReturnType>EnsLib.HL7.Message</ReturnType>
<Implementation><![CDATA[..ImportFromLibraryStream(.pOldStream,.pStatus,.pConfigItem)
]]></Implementation>
</Method>

<Method name="ImportFromLibraryStream">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pLibStream:%Stream.Object,*pStatus:%Status,&pConfigItem:%String,pIOFormatClassname:%String]]></FormalSpec>
<ReturnType>EnsLib.HL7.Message</ReturnType>
<Implementation><![CDATA[
	Set tIOStream=$S(pLibStream.%Extends("%IO.I.CharacterStream"):pLibStream,1:##Class(%IO.MetaCharacterStream).%New(pLibStream))
	Quit ..ImportFromIOStream(tIOStream,.pStatus,.pConfigItem,.pIOFormatClassname)
]]></Implementation>
</Method>

<Method name="ImportFromString">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pString:%String,*pStatus:%Status,&pConfigItem:%String,pIOFormatClassname:%String]]></FormalSpec>
<ReturnType>EnsLib.HL7.Message</ReturnType>
<Implementation><![CDATA[
	Set tIOStream=##Class(%IO.StringStream).%New(pString)
	Quit ..ImportFromIOStream(tIOStream,.pStatus,.pConfigItem,.pIOFormatClassname)
]]></Implementation>
</Method>

<Method name="ImportFromIOStream">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pIOStream:%IO.I.CharacterStream,*pStatus:%Status=$$$OK,&pConfigItem:%String="",pIOFormatClassname:%String=""]]></FormalSpec>
<ReturnType>EnsLib.HL7.Message</ReturnType>
<Implementation><![CDATA[
	Quit:""'=pIOFormatClassname&&$classmethod(pIOFormatClassname,"ImportDocument",.tDoc,.pStatus,pIOStream,pConfigItem) tDoc

	If ""'=pConfigItem {
		If $IsObject(pConfigItem) {
			Set tInst=pConfigItem
		} Else {
			Set tInst=##class(Ens.Host).GetShadowInstance(pConfigItem,.pStatus)  Quit:$$$ISERR(pStatus) $$$NULLOREF
		}
		If 'tInst.%Extends("EnsLib.HL7.Service.Standard") Set pStatus=$$$ERROR($$$EnsErrGeneral,"Config Item class "_$classname(tInst)_" found For "_pConfigItem_" is not not an HL7 Service")  Quit $$$NULLOREF
	} Else {
		Set tInst=##class(Ens.Host).GetShadowInstance("class ||EnsLib.HL7.Service.FileService",.pStatus)  Quit:$$$ISERR(pStatus) $$$NULLOREF
	}
	#; Get a new parser based on a Service; OnInit not called for shadow service instances
	Set tInst.%ForwardBatchWhole=2 ; don't let Service process the document
	If '$IsObject(tInst.%Parser) Set tInst.%Parser=##class(EnsLib.HL7.Parser).%New(tInst)  $$$ASSERT($IsObject(tInst.%Parser))
	Set tInst.%Parser.Framing=tInst.Framing
	Set tInst.%Parser.DefCharEncoding=tInst.DefCharEncoding
	Set:""=tInst.AckMode tInst.AckMode="Immed"

	If tInst'=pConfigItem { ; override some default properties if we created the shadow instance
		Set tInst.SearchTableClass=""
	}
	#; call the parser
	Set tDoc=$$$CurrentClass
	Set pStatus=tInst.%Parser.ParseFramedIOStream(pIOStream,.tDoc,1)
	Set pConfigItem=tInst ; allow repeated calls on the same parser
	Quit tDoc
]]></Implementation>
</Method>

<Method name="resolveChildDocType">
<Description>
Return the DocType of this document.</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tDocType=..DocType
	Set tParent=..Parent
	If (""=tDocType)&&($IsObject(tParent))&&(""'=tParent.DocTypeCategory) {
		If ("MSH"=..GetValueAt("1:0")) {
			Set tNameFound=..GetValueAt("1:9",":_~\&")
			Set:""=tNameFound tNameFound=pDoc.Name
		} Else {
			Set tNameFound=..Name
		}
		#; Match with the DocType specified if any in MessageSchemaCategory for the received Message's type name
		Set tDocType=##class(EnsLib.HL7.Schema).ResolveSchemaTypeToDocType(tParent.DocTypeCategory,tNameFound,.tSC)
		Set:$$$ISERR(tSC) tDocType=""
	}
	Quit tDocType
]]></Implementation>
</Method>

<Method name="CopyValues">
<FormalSpec>pSource:EnsLib.HL7.Message,pSourcePath:%String,pTargetPath:%String,pAction:%String,pKey:%String,pEmptyFieldAsNull:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSourceWild=$F(pSourcePath,"()"), tTargetWild=$F(pTargetPath,"()")
	If tSourceWild||tTargetWild {
		Set tSourceHead=$E(pSourcePath,1,tSourceWild-3), tSourceTail=$E(pSourcePath,tSourceWild,*)
		Set tTargetHead=$E(pTargetPath,1,tTargetWild-3), tTargetTail=$E(pTargetPath,tTargetWild,*)
		If tSourceWild {
			If pEmptyFieldAsNull {
				If (tTargetWild)&&(tSourceHead [ ":")&&(tTargetHead [ ":") {
					Quit:(pSource.GetValueAt(tSourceHead)="") $$$OK
				}
			}
			Set i="" For { Set i=pSource.GetNextIndex(tSourceHead_"()",i,.tSC) Quit:i=""
				Set tSourceNewPath=tSourceHead_"("_(i)_")"_tSourceTail
				Set tTargetNewPath=$S(tTargetWild:tTargetHead_"("_(i)_")"_tTargetTail,1:pTargetPath)
				Set tSC=..CopyValues(pSource,tSourceNewPath,tTargetNewPath,pAction,pKey,pEmptyFieldAsNull) Quit:$$$ISERR(tSC)
			}
		} Else {
			Set i="" For { Set i=..GetNextIndex(tTargetHead_"()",i,.tSC) Quit:i=""
				Set tTargetNewPath=tTargetHead_"("_(i)_")"_tTargetTail
				Set tSC=..CopyValues(pSource,pSourcePath,tTargetNewPath,pAction,pKey) Quit:$$$ISERR(tSC)
			}
		}
	} Else {
		Set tSourceGrpPath=$P(pSourcePath,":"), tSourcePropPath=$P(pSourcePath,":",2)
		Set tTargetGrpPath=$P(pTargetPath,":"), tTargetPropPath=$P(pTargetPath,":",2)
		Set tSrcSegPath=pSource.GetNextGroupPath(tSourceGrpPath,tSourceGrpPath)
		Set tTrgSegPath=..GetNextGroupPath(tTargetGrpPath,tTargetGrpPath)
		If (""'=tSrcSegPath)||(""'=tTrgSegPath) { ; if there are group sub-elements
			If (""'=tSrcSegPath) {
				For {
					Set tSourceNewPath=tSrcSegPath_$S(""=tSourcePropPath:"",1:":"_tSourcePropPath)
					Set tTargetNewPath=tTargetGrpPath_$E(tSrcSegPath,1+$L(tSourceGrpPath),*)_$S(""=tSourcePropPath:"",1:":"_tSourcePropPath)
					Set tSC=..CopyValues(pSource,tSourceNewPath,tTargetNewPath,pAction,pKey) Quit:$$$ISERR(tSC)
					Set tSrcSegPath=pSource.GetNextGroupPath(tSourceGrpPath,tSrcSegPath,.tSC) Quit:$$$ISERR(tSC)
					Quit:""=tSrcSegPath
				}
			} Else {
				For {
					Set tTargetNewPath=tTrgSegPath_$S(""=tTargetPropPath:"",1:":"_tTargetPropPath)
					Set tSC=..CopyValues(pSource,pSourcePath,tTargetNewPath,pAction,pKey) Quit:$$$ISERR(tSC)
					Set tTrgSegPath=..GetNextGroupPath(tTargetGrpPath,tTrgSegPath,.tSC) Quit:$$$ISERR(tSC)
					Quit:""=tTrgSegPath
				}
			}
		} Else {
			If ""'=tSourcePropPath||("*"=pSourcePath)||($E(pSourcePath,*-2,*)="(*)") {
				Set tSC=..SetValueAt(pSource.GetValueAt(pSourcePath,,.tSC2),pTargetPath,pAction,pKey)
				Set:$$$ISERR(tSC2) tSC=$$$ADDSC(tSC,tSC2)
			} Else { ; create clone segment object for id or oref
				Set tId=pSource.GetSegmentIdAt(pSourcePath,.tSC)  Quit:$$$ISERR(tSC) tSC
				If tId'="" {
					Set tSegObj=##class(EnsLib.HL7.Segment).%New($LB(tId,1,"",1))
					Set:$IsObject(tSegObj) tSC=..SetSegmentAt(tSegObj,pTargetPath)
				} Else {
					Set tSegObj=pSource.GetSegmentAt(pSourcePath,.tSC)  Quit:$$$ISERR(tSC) tSC
					Set:$IsObject(tSegObj) tSC=..SetSegmentAt(tSegObj.%ConstructClone(),pTargetPath)
				}
			}
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="Purge">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pDeletedCount:%Integer,pDaysToKeep:%Integer=7,pDummy:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If 0=pDaysToKeep Do ..KillGlobals(.pDeletedCount,1,0)  Quit $$$OK

	New %tDoNotDeleteDate,%tID,%tTime  Set %tDoNotDeleteDate = $$$timeUTCHtoUTC($s($ztimezone'<0:($H-pDaysToKeep+1)_","_($ztimezone*60),1:($H-pDaysToKeep)_","_($ztimezone*60+86400)))
	Set SQLCODE=0, pDeletedCount=0
	&sql(Declare C1 Cursor for
		Select ID,TimeCreated Into :%tID,:%tTime From EnsLib_HL7.Message Order By ID)
	&sql(OPEN C1) For { &sql(FETCH C1)  Quit:SQLCODE
		If $$$timeCmp(%tTime,%tDoNotDeleteDate)<0 {
			&sql(Delete From EnsLib_HL7.Message Where ID=:%tID)
			Set pDeletedCount=pDeletedCount+%ROWCOUNT
		}
	} Set tCode=SQLCODE &sql(CLOSE C1) Set:'SQLCODE SQLCODE=tCode
	Quit:SQLCODE&&(SQLCODE'=100) $$$ERROR($$$EnsErrGeneral,"Purge error at ID "_%tID_"; SQLCODE = "_SQLCODE)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New %tID  Set %tID=$$$oidPrimary(oid)
	Do ##class(Ens.SearchTableBase).RemoveSearchTableEntries($classname(),%tID,1)
	For index=1:1:+$G($$$vaExtentGbl(%tID,"segs")) Set segid=$$$vaExtentGbl(%tID,"segs",index) If segid["," { Kill $$$vaSegmentRef(segid,%tID) If '$D($$$vaSegmentRefs(segid)) Kill $$$vaSegment(segid) } Else { Kill $$$vaSegmentGbl(segid,0,%tID) If '$D($$$vaSegmentGbl(segid,0)) Set data=$G($$$vaSegmentGbl(segid))  Kill:+data'=data $$$vaSegmentGbl(segid) }
	If $G($$$EnsConfig("HL7","DeleteNoLock"),1) {
		&sql(Delete %NOLOCK From EnsLib_HL7.Message Where OriginalDocId=:%tID)
		&sql(Delete %NOLOCK From EnsLib_HL7.Message Where ParentId=:%tID Or ParentId %StartsWith :%tID||':')
	} Else {
		&sql(Delete From EnsLib_HL7.Message Where OriginalDocId=:%tID)
		&sql(Delete From EnsLib_HL7.Message Where ParentId=:%tID Or ParentId %StartsWith :%tID||':')
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Trigger name="OnDelete">
<Code><![CDATA[	New %tID,index,segid  Set %tID={%%ID}
	Do ##class(Ens.SearchTableBase).RemoveSearchTableEntries($classname(),%tID,1)
	For index=1:1:+$G($$$vaExtentGbl(%tID,"segs")) Set segid=$$$vaExtentGbl(%tID,"segs",index) If segid["," { Kill $$$vaSegmentRef(segid,%tID) If '$D($$$vaSegmentRefs(segid)) Kill $$$vaSegment(segid) } Else { Kill $$$vaSegmentGbl(segid,0,%tID) If '$D($$$vaSegmentGbl(segid,0)) Set data=$G($$$vaSegmentGbl(segid))  Kill:+data'=data $$$vaSegmentGbl(segid) }
	If $G($$$EnsConfig("HL7","DeleteNoLock"),1) {
		&sql(Delete %NOLOCK From EnsLib_HL7.Message Where OriginalDocId=:%tID)
		&sql(Delete %NOLOCK From EnsLib_HL7.Message Where ParentId=:%tID Or ParentId %StartsWith :%tID||':')
	} Else {
		&sql(Delete From EnsLib_HL7.Message Where OriginalDocId=:%tID)
		&sql(Delete From EnsLib_HL7.Message Where ParentId=:%tID Or ParentId %StartsWith :%tID||':')
	}
	Quit]]></Code>
<Event>DELETE</Event>
</Trigger>

<Method name="KillGlobals">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pDeletedCount,pKeepExtentCount=0,pDisplayLog=1</FormalSpec>
<Implementation><![CDATA[
	Set pDeletedCount=..TotalCount()
	Set tExtentCount=$G($$$vaExtentGbl)
	Write:pDisplayLog !,"Killing ",$classname()," extent ("_pDeletedCount_"/"_tExtentCount_")"
	Do ..%KillExtent()
	Set:pKeepExtentCount $$$vaExtentGbl=tExtentCount

	Do ##class(EnsLib.HL7.SearchTable).%KillExtent()

	Set globals($Name($$$vaSegmentGbl))=""

	Set global="" For { Set global=$O(globals(global))  Quit:""=global
		Kill tExtentCount  Set:pKeepExtentCount tExtentCount=$S($D(@global)#2:@global,1:$$topNodesSum(global))
		Write:pDisplayLog !,"Killing ",global,"("_$G(tExtentCount)_")"
		Kill @global
		If $D(tExtentCount) Set @global=tExtentCount
	}
	Quit
topNodesSum(global)
	Set tSum=0,cnt=0,sub="" For { Set sub=$O(@global@(sub),1,cnt) Quit:""=sub  Set tSum=tSum+cnt }
	Quit tSum
]]></Implementation>
</Method>

<Method name="TotalCount">
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	&sql(SELECT COUNT(*) INTO :tCount From EnsLib_HL7.Message)
	Quit tCount
]]></Implementation>
</Method>

<Method name="%OnClose">
<Private>1</Private>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Kill Segment storage if not %Save'd and segment not used by other Messages
	Set tId=..%Id()
	If ""=tId {
		If $D($$$vaM("runtimeIndex")) {
			For index=1:1:$$$vaM("runtimeIndex") { Set seg=$G($$$vaM("runtimeIndex",index))
				If '$$$vaIsOref(seg) { Set segid=$P(seg,"|") }
				Else {
					Set tSegObj=..%maps("orefs",index)
					Set segid=$S(tSegObj.%Cloned:"", 1:tSegObj.ID) ; don't delete ID from cloned segs because the ID does not really belong to them
				}
				Kill:""'=segid&&'$D($$$vaSegmentRefs(segid)) $$$vaSegment(segid)
			}
		} Else {
			Set path="" For { Set path=$O($$$vaM("runtimePath",path),1,seg) Quit:""=path
				If '$$$vaIsOref(seg) { Set segid=$P(seg,"|") }
				Else {
					Set tSegObj=..%maps("orefs",$E(seg,2,*))
					Set segid=$S(tSegObj.%Cloned:"", 1:tSegObj.ID) ; don't delete ID from cloned segs because the ID does not really belong to them
				}
				Kill:""'=segid&&'$D($$$vaSegmentRefs(segid)) $$$vaSegment(segid)
			}
		}
	}
	If 'tId||$D($$$vaExtentGbl(tId)) $$$vaMkill  ; ..%maps can be undefined when aborting %OpenId() of nonexistent Id
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="NewReplyDocument">
<FormalSpec>pMessageType:%String={$S(""'=..MessageTypeCategory:..MessageTypeCategory,1:..DocTypeCategory)_":"_..Name},pLocalFacilityApplication:%String="",*pSC:%Status,pForceACK:%Boolean=1</FormalSpec>
<ReturnType>EnsLib.HL7.Message</ReturnType>
<Implementation><![CDATA[
	Set pSC=$$$OK
	Do ##class(EnsLib.HL7.Schema).ResolveReplyNameAndDocType(pMessageType,.tReplyDocName,.tReplyDocType,pForceACK)
	Set tReplyMessage=..%New($LB("",..Separators))
	Quit:'$IsObject(tReplyMessage) $$$NULLOREF
	Do tReplyMessage.PokeTypeCategory($P(pMessageType,":"))
	Do tReplyMessage.PokeDocType(tReplyDocType)
	Set tMSH=..GetSegmentAt(1)
	Set tUTCH=$$$timeUTCH, tTime=$$$timeUTCtoUTCH($$$timeUTCtoLocal($$$timeUTCHtoUTC(tUTCH)))
	Set tReplyMSH=tReplyMessage.GetSegmentAt(1)
	#; Support indirection and escaping to allow @ to represent the caller's destination value
	Set tFacil=$P(pLocalFacilityApplication,":",1), tApp=$P(pLocalFacilityApplication,":",2)
	If pLocalFacilityApplication["@" {
		Set pos=1 For { Set pos=$F(tFacil,"\",pos)  Quit:'pos  Set c=$E(tFacil,pos)
			Set tNew=$Case(c, "@":-1, "\":"\", :"\"_c), $E(tFacil,pos-1,pos)=tNew, pos=pos+$L(tNew)-1
		} Set tFacil=$Replace($Replace(tFacil,"@",tMSH.GetValueAt(6)),-1,"@")
		Set pos=1 For { Set pos=$F(tApp,"\",pos)  Quit:'pos  Set c=$E(tApp,pos)
			Set tNew=$Case(c, "@":-1, "\":"\", :"\"_c), $E(tApp,pos-1,pos)=tNew, pos=pos+$L(tNew)-1
		} Set tApp=$Replace($Replace(tApp,"@",tMSH.GetValueAt(5)),-1,"@")
	}
	Do tReplyMSH.SetValueAt(tMSH.GetValueAt(3),5)
	Do tReplyMSH.SetValueAt(tMSH.GetValueAt(4),6)
	Do tReplyMSH.SetValueAt(tApp,3)
	Do tReplyMSH.SetValueAt(tFacil,4)
	Do tReplyMSH.SetValueAt($ZDate(tTime,8)_$TR($ZTime($P(tTime,",",2),2),":"),7)
	Do tReplyMSH.SetValueAt($TR(tReplyDocName,"_",..CS),9)
	Do tReplyMSH.SetValueAt(..NewControlID(tUTCH),10)
	Do tReplyMSH.SetValueAt(tMSH.GetValueAt(11),11)
	Do tReplyMSH.SetValueAt(tMSH.GetValueAt(12),12)
	Set tSeqNum=tMSH.GetValueAt(13)  Do:""'=tSeqNum tReplyMSH.SetValueAt(tSeqNum,13)
	Quit tReplyMessage
]]></Implementation>
</Method>

<Method name="NewControlID">
<Description>
Get an new 20-character control ID, given $ZTS and $ZH timestamps.
2-char base-62 hash(letters or digits) of machine name (mod 31) and job slot(mod 124), 2-digit year,month,day,millisecond UTC time,and microseconds from $ZH</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTimeUTCH:%String=$ZTS</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
#define map62(%n) $C($S(%n<0:$A("-"), %n<10:%n+$A(0), %n<36:%n-10+$A("a"), %n<62:%n-36+$A("A"), 1:$A("+")))
 Set tSys=$G($$$EnsRuntime("System",$$$SystemName))  Set:""=tSys tSys=$p($zu(54,13,$zu(54,0)),",",1)_":"_$get(^%SYS("SSPort"),1972)_":"_$znspace
 Set:'$D($$$EnsJobLocal("JobSlot")) $$$EnsJobLocal("JobSlot")=$ZU(67,3,$J)-1, $$$EnsJobLocal("MachineHash")=$ZCRC(tSys,7)#31*2+($$$EnsJobLocal("JobSlot")\62#2)
 Quit $$$map62($$$EnsJobLocal("MachineHash"))_$$$map62($$$EnsJobLocal("JobSlot")#62)_
	$E($ZDate(pTimeUTCH,8),3,8)_
	$TR($ZTime($P(pTimeUTCH,",",2),1,3),":.")_
	$TR($$$PAD($E($P($ZH,".",2),4,6),3)," ","0")
]]></Implementation>
</Method>

<Method name="Clear">
<Description>
Delete All Content and reset all properties</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsMutable $$$ERROR($$$EnsErrGeneral,"Object is immutable")
	Set tSC=..%OnClose()  Quit:$$$ISERR(tSC) tSC
	Kill $$$vaM("runtimeIndex"), $$$vaM("runtimePath"), $$$vaM("bidirectionalLink"), $$$vaM("loopIndex")
	Set $$$vaM("runtimeIndex")=0
	Set i%BuildMapStatus=""
	Set ..Source=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getId">
<Description>
The same as %Id(), but allocates the Id even if the object hasn't been saved already</Description>
<CodeMode>generator</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	$$$GENERATE(" If ..%Id()="""" Do ..%IdSet($increment("_$$$EXTidlocation($$$pEXT,%class)_"))")
	$$$GENERATE(" Quit ..%Id()")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetFieldStreamRaw">
<Description><![CDATA[
Read a field from a segment into a stream.
<var>pRemainder</var> is the remainder of the segment after the stream field, including the field's terminating separator]]></Description>
<FormalSpec><![CDATA[&pStream:%Stream.Object,pPropertyPath:%String="",*pRemainder:%String,pProc:%String,&pHint]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSegObj=..GetSegmentAt($P(pPropertyPath,":",1),.tSC)  Quit:$$$ISERR(tSC) tSC
	Quit tSegObj.GetFieldStreamRaw(.pStream,$P(pPropertyPath,":",2),.pRemainder,.pProc,.pHint)
]]></Implementation>
</Method>

<Method name="GetFieldStreamBase64">
<Description><![CDATA[
Read a field from a segment into a stream, decoding from Base64 to plain binary.
<var>pRemainder</var> is the remainder of the segment after the stream field, including the field's terminating separator]]></Description>
<FormalSpec><![CDATA[&pStream:%Stream.Object,pPropertyPath:%String="",*pRemainder:%String,pUnescapeFirst:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSegObj=..GetSegmentAt($P(pPropertyPath,":",1),.tSC)  Quit:$$$ISERR(tSC) tSC
	Quit tSegObj.GetFieldStreamBase64(.pStream,$P(pPropertyPath,":",2),.pRemainder,.pUnescapeFirst)
]]></Implementation>
</Method>

<Method name="GetFieldStreamUnescaped">
<Description><![CDATA[
Read a field from a segment into a stream, unescaping any encoded separators or newlines, to plain text.
<var>pRemainder</var> is the remainder of the segment after the stream field, including the field's terminating separator]]></Description>
<FormalSpec><![CDATA[&pStream:%Stream.Object,pPropertyPath:%String="",*pRemainder:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSegObj=..GetSegmentAt($P(pPropertyPath,":",1),.tSC)  Quit:$$$ISERR(tSC) tSC
	Quit tSegObj.GetFieldStreamUnescaped(.pStream,$P(pPropertyPath,":",2),.pRemainder)
]]></Implementation>
</Method>

<Method name="StoreFieldStreamRaw">
<Description>
Store a stream into a segment field. Note that this renders the segment immutable after completing, and therefore works only once per segment.</Description>
<FormalSpec><![CDATA[pStream:%Stream.Object,pPropertyPath:%String="",pRemainder:%String,pProc:%String,&pHint]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSegObj=..GetMutableSegmentAt($P(pPropertyPath,":",1),.tSC)  Quit:$$$ISERR(tSC) tSC
	Quit tSegObj.StoreFieldStreamRaw(.pStream,$P(pPropertyPath,":",2),.pRemainder,.pProc,.pHint)
]]></Implementation>
</Method>

<Method name="StoreFieldStreamBase64">
<Description>
Store a stream into a segment field, encoding as Base64. Note that this renders the segment immutable after completing, and therefore works only once per segment.</Description>
<FormalSpec>pStream:%Stream.Object,pPropertyPath:%String="",pRemainder:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSegObj=..GetMutableSegmentAt($P(pPropertyPath,":",1),.tSC)  Quit:$$$ISERR(tSC) tSC
	Quit tSegObj.StoreFieldStreamBase64(.pStream,$P(pPropertyPath,":",2),.pRemainder)
]]></Implementation>
</Method>

<Method name="StoreFieldStreamEscaped">
<Description>
Store a stream into a segment field, applying HL7 escaping. Note that this renders the segment immutable after completing, and therefore works only once per segment.</Description>
<FormalSpec>pStream:%Stream.Object,pPropertyPath:%String="",pRemainder:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSegObj=..GetMutableSegmentAt($P(pPropertyPath,":",1),.tSC)  Quit:$$$ISERR(tSC) tSC
	Quit tSegObj.StoreFieldStreamEscaped(.pStream,$P(pPropertyPath,":",2),.pRemainder)
]]></Implementation>
</Method>

<Method name="GetManagerLinks">
<Description>
Returns an array of links to manager pages for this type of VDoc; item 0 is the family description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pColumns</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set iCol=0
	Set pColumns(iCol,"page")="http://www.hl7.org"
	Set pColumns(iCol,"name")=$$$Text("HL7 version 2")
	Set pColumns(iCol,"desc")=$$$Text("Health Level 7 version 2.x Message documents")
	
	Set iCol=iCol+1
	Set pColumns(iCol,"page")=##class(%CSP.Page).Link("HL7/HL7SchemaMain.csp")
	Set pColumns(iCol,"name")=$$$Text("Schema Structures")
	Set pColumns(iCol,"desc")=$$$Text("View schema definitions for various versions/categories of HL7 v2.x message types, structures, segments, fields, components and code tables")

	Set iCol=iCol+1
	Set pColumns(iCol,"page")=##class(%CSP.Page).Link("EDIDocumentView.csp?NAME="_$ZCVT("HL7 Message","O","URL")_"&CLASS=EnsLib.HL7.Message")
	Set pColumns(iCol,"name")=$$$Text("Message Viewer")
	Set pColumns(iCol,"desc")=$$$Text("View HL7 Messages from a variety of sources and test them with various DocType schema definitions and Data Transformations")
	Quit 1
]]></Implementation>
</Method>

<Method name="GetNewManagerLinks">
<Description>
Returns an array of links to manager pages for this type of VDoc; item 0 is the family description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pColumns</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set iCol=0
	Set pColumns(iCol,"page")="http://www.hl7.org"
	Set pColumns(iCol,"name")=$$$Text("HL7 version 2")
	Set pColumns(iCol,"desc")=$$$Text("Health Level 7 version 2.x Message documents")
	
	Set iCol=iCol+1
	Set pColumns(iCol,"page")=##class(%CSP.Page).Link("EnsPortal.HL7.SchemaMain.cls")
	Set pColumns(iCol,"name")=$$$Text("Schema Structures")
	Set pColumns(iCol,"desc")=$$$Text("View schema definitions for various versions/categories of HL7 v2.x message types, structures, segments, fields, components and code tables")

	Set iCol=iCol+1
	Set pColumns(iCol,"page")=##class(%CSP.Page).Link("EDIDocumentView.csp?NAME="_$ZCVT("HL7 Message","O","URL")_"&CLASS=EnsLib.HL7.Message")
	Set pColumns(iCol,"name")=$$$Text("Message Viewer")
	Set pColumns(iCol,"desc")=$$$Text("View HL7 Messages from a variety of sources and test them with various DocType schema definitions and Data Transformations")
	Quit 1
]]></Implementation>
</Method>

<Method name="Validate">
<Description>
Validates the HL7 message content against the schema that is referenced in its DocType property.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pValidationSpec:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(EnsLib.HL7.Util.Validator).Validate($this,pValidationSpec)
]]></Implementation>
</Method>

<Method name="toEasyXML">
<Description>
Deprecated - to be removed</Description>
<Internal>1</Internal>
<FormalSpec><![CDATA[&xml:%GlobalCharacterStream,&schema,pToDevice:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#define APPEND(%x,%s) If pToDevice { Write %s,! } Else { Do %x.WriteLine(%s) }

	Set xml = $S(pToDevice:$$$NULLOREF,1:##class(%GlobalCharacterStream).%New())

	Set name = $ZCVT(..GetMsgType(..Name),"O","XML")
	Set base = ..DocType
	Set:base'="" base=$G($$$vaSchemaGbl($P(..DocType,":"),"base"))
	Set:base="" base=$P(..DocType,":")
	
	$$$APPEND(xml,"<?xml version=""1.0"" encoding=""UTF-16""?>")
	$$$APPEND(xml,"<"_name_" docType="""_$ZCVT($P(..DocType,":"),"O","XML")_""">")
	For i = 1:1:..SegCount {
		Set segment = ..getSegmentByIndex(i)
		Do segment.toEasyXML(.xml,i,base,.schema,pToDevice)
	}
	$$$APPEND(xml,"</"_name_">")
	Do:'pToDevice xml.Rewind()
	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^EnsLib.H.MessageD</DataLocation>
<DefaultData>MessageDefaultData</DefaultData>
<IdLocation>^EnsLib.H.MessageD</IdLocation>
<IndexLocation>^EnsLib.H.MessageI</IndexLocation>
<StreamLocation>^EnsLib.H.MessageS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="MessageDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ParentId</Value>
</Value>
<Value name="3">
<Value>DocType</Value>
</Value>
<Value name="4">
<Value>IsMutable</Value>
</Value>
<Value name="5">
<Value>TimeCreated</Value>
</Value>
<Value name="6">
<Value>MessageTypeCategory</Value>
</Value>
<Value name="7">
<Value>Source</Value>
</Value>
<Value name="8">
<Value>Envelope</Value>
</Value>
<Value name="9">
<Value>OriginalDocId</Value>
</Value>
</Data>
<Data name="UserValues">
<Attribute>UserValues</Attribute>
<Structure>subnode</Structure>
<Subscript>"UserValues"</Subscript>
</Data>
</Storage>
</Class>


<Class name="EnsLib.HL7.Segment">
<ClassType/>
<IncludeCode>EnsHL7</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%RegisteredObject,EnsLib.EDI.Segment</Super>
<System>4</System>
<TimeChanged>63920,75710</TimeChanged>
<TimeCreated>59269,41535.554</TimeCreated>
<Inheritance>right</Inheritance>

<UDLText name="T">
<Content><![CDATA[
// Override Name Maxlen & Minlen

]]></Content>
</UDLText>

<Property name="Name">
<Description>
Segment Type name</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<ReadOnly>1</ReadOnly>
<Parameter name="MAXLEN" value="6"/>
<Parameter name="MINLEN" value="3"/>
</Property>

<Property name="FS">
<Description>
Field Separator character</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
</Property>

<Property name="CS">
<Description>
Component Separator character</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
</Property>

<Property name="RS">
<Description>
Repetition Separator character</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
</Property>

<Property name="ESC">
<Description>
Escape Character</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
</Property>

<Property name="SS">
<Description>
Subcomponent Separator character</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
</Property>

<Property name="TC">
<Description>
Truncation Character</Description>
<Type>%String</Type>
</Property>

<Property name="Separators">
<Description>
All 5 Separators as a single String</Description>
<Type>%String</Type>
<InitialExpression>$$$HL7DefSeparators</InitialExpression>
<Parameter name="MAXLEN" value="5"/>
<Parameter name="MINLEN" value="5"/>
</Property>

<Property name="DataArray">
<Description>
Local copy of segment data decomposed into multidimensional array</Description>
<Internal>1</Internal>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="SegType">
<Description>
Deprecated: use DocType</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
</Property>

<Property name="SegTypeCategory">
<Description>
Deprecated: use DocTypeCategory</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="SegTypeName">
<Description>
Deprecated: use DocTypeName</Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="FullSize">
<Description>
Size in bytes of the full segment content including any continuation nodes.</Description>
<Type>%Integer</Type>
<Calculated>1</Calculated>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="%Cloned">
<Description>
Were we cloned from another Segment object? (If so, we won't be responsible for deleting the underlying segment ID data node if any)</Description>
<Type>%Boolean</Type>
<Internal>1</Internal>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="SegTypeGet">
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[i%DocType
]]></Implementation>
</Method>

<Method name="SegTypeSet">
<Internal>1</Internal>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..DocType = val
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SegTypeCategoryGet">
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[i%DocTypeCategory
]]></Implementation>
</Method>

<Method name="SegTypeNameGet">
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[i%DocTypeName
]]></Implementation>
</Method>

<Method name="PokeDocType">
<CodeMode>expression</CodeMode>
<FormalSpec>pDocType:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..DocTypeSet(pDocType)
]]></Implementation>
</Method>

<Method name="DocTypeSet">
<Internal>1</Internal>
<FormalSpec>pDocType:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%DocType=pDocType
	Set i%DocTypeCategory=$P(i%DocType,":",1)
	Set i%DocTypeName=$P(i%DocType,":",2)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="FSGet">
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$FSSEP(..Separators)
]]></Implementation>
</Method>

<Method name="CSGet">
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$CSSEP(..Separators)
]]></Implementation>
</Method>

<Method name="RSGet">
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$RSSEP(..Separators)
]]></Implementation>
</Method>

<Method name="ESCGet">
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$ESCSEP(..Separators)
]]></Implementation>
</Method>

<Method name="SSGet">
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$$$SSSEP(..Separators)
]]></Implementation>
</Method>

<Method name="FSSet">
<Internal>1</Internal>
<FormalSpec>newval</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $$$FSSEP(i%Separators)=$E(newval_$$$HL7DefFS)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="CSSet">
<Internal>1</Internal>
<FormalSpec>newval</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $$$CSSEP(i%Separators)=$E(newval_$$$HL7DefCS)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="RSSet">
<Internal>1</Internal>
<FormalSpec>newval</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $$$RSSEP(i%Separators)=$E(newval_$$$HL7DefRS)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ESCSet">
<Internal>1</Internal>
<FormalSpec>newval</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $$$ESCSEP(i%Separators)=$E(newval_$$$HL7DefESC)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SSSet">
<Internal>1</Internal>
<FormalSpec>newval</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $$$SSSEP(i%Separators)=$E(newval_$$$HL7DefSS)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SeparatorsSet">
<Internal>1</Internal>
<FormalSpec>newvalue:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%Separators=$S(""=newvalue:$$$HL7DefSeparators, $L(newvalue)<5:newvalue_$E($C(17,18,19,20),$L(newvalue),4), 1:$E(newvalue,1,5))
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="FullSizeGet">
<Internal>1</Internal>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set data=..GetValueAt("")
	If data=""||(..ID="")||$D(..DataArray)||'$D($$$vaSegmentExt(..ID,1)) {
		Set len=$L(data)
	} Else {
		Set len=$L(data)
		For i=1:1 { Quit:'$D($$$vaSegmentExt(..ID,i),data)
			Set len=len+$L(data)
		}
	}
	Quit len
]]></Implementation>
</Method>

<Method name="init">
<Internal>1</Internal>
<FormalSpec>pSegID:%String,pMutable:%Boolean,pDocType:%String,pSegData:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..DocType=pDocType
	If pSegID="" {
		If ""=pSegData {
			Set i%IsMutable=1
		} Else {
			#; If SegData supplied, use that
			Set i%IsMutable=+pMutable
			Set tSC=..decomposeData(pSegData)  Quit:$$$ISERR(tSC) tSC
			Set ..Separators=pSegData
		}
		Quit $$$OK
	}
	#; Verify that segment exists
	Set data=$G($$$vaSegment(pSegID))
	Quit:""=data $$$ERROR($$$EnsErrGeneral,"Segment "_pSegID_" does not exist")
	Set i%ID=pSegID, i%IsMutable=+pMutable, i%%Cloned=''pSegData
	Set ..Separators=data
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnConstructClone">
<Internal>1</Internal>
<FormalSpec><![CDATA[object:%RegisteredObject,deep:%Boolean=0,&cloned:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%IsMutable=1, i%%Cloned=1
	Set:$D(..DataArray) i%ID=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SaveData">
<Description>
Compose the segment and store it at a new ID</Description>
<FormalSpec>pSeparators:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If $D(..DataArray) && (""=..ID || ..IsMutable) {
		Set tSeparators=$S(""=$G(pSeparators):..Separators, 1:pSeparators)
		Set tJK=$$$JobKey
		Set:'$D(%topSegIndex) %topSegIndex=$G($$$vaSegmentGbl(tJK)), tNoTop=1

		#; Relocate all old-style segments of all msg objects that reference the current segment. (Opening one will do them all)
		If $G($$$EnsConfig("HL7Segs-Compat")) {
			Lock +$$$vaSegmentGbl(tJK):2
			If $Test {
				Set data=$G($$$vaSegmentGbl(tJK))
				Set:data'=+data msg=##class(EnsLib.HL7.Message).%OpenId($O($$$vaSegmentGbl(tJK,0,"")))  Kill msg
				Lock -$$$vaSegmentGbl(tJK)
			}
		}
		Set tIndex=tJK_","_$I(%topSegIndex)
		Set $$$vaSegment(tIndex)=$E(tSeparators,1,5)_..getAtFromArray("",tSeparators)
		Set i%ID=tIndex, i%IsMutable=0, i%%Cloned=0
		Set $$$vaSegmentGbl(tJK)=%topSegIndex  Kill:$G(tNoTop) %topSegIndex
	} Else { $$$ASSERT(+..ID=$P(..ID,",")&&(..ID>0)) }
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OutputToDevice">
<FormalSpec>pSeparators:%String,pSequenceNumber:%String,pSegNum:%String,pSegPath:%String,pParentDoc:EnsLib.EDI.Document,pIOFormatClassname:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tDeviceStream=##class(%IO.DeviceStream).AttachNew(,.tSC)  Quit:$$$ISERR(tSC) tSC
	Quit ..OutputToIOStream(tDeviceStream, .pSeparators, .pSequenceNumber, .pSegNum, .pSegPath, .pParentDoc, .pIOFormatClassname)
]]></Implementation>
</Method>

<Method name="OutputToOldStream">
<Description>
deprecated - use OutputToLibraryStream</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pOldStream:%Stream.Object,pSeparators:%String,pSequenceNumber:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..OutputToLibraryStream(.pOldStream, .pSeparators, .pSequenceNumber)
]]></Implementation>
</Method>

<Method name="OutputToLibraryStream">
<FormalSpec>pLibStream:%Stream.Object,pSeparators:%String,pSequenceNumber:%String,pSegNum:%String,pSegPath:%String,pParentDoc:EnsLib.EDI.Document,pIOFormatClassname:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tIOStream=$S(pLibStream.%Extends("%IO.I.CharacterStream"):pLibStream,1:##Class(%IO.MetaCharacterStream).%New(pLibStream))
	Quit ..OutputToIOStream(tIOStream, .pSeparators, .pSequenceNumber, .pSegNum, .pSegPath, .pParentDoc, .pIOFormatClassname)
]]></Implementation>
</Method>

<Method name="OutputToString">
<FormalSpec>pSeparators:%String,pSequenceNumber:%String,*pStatus:%Status,pCharEncoding:%String="",pSegNum:%String,pSegPath:%String,pParentDoc:EnsLib.EDI.Document,pIOFormatClassname:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tIOStream=##Class(%IO.StringStream).%New()
	Set:""'=pCharEncoding tIOStream.CharEncoding=pCharEncoding
	Set pStatus = ..OutputToIOStream(tIOStream, .pSeparators, .pSequenceNumber, .pSegNum, .pSegPath, .pParentDoc, .pIOFormatClassname)
	Do tIOStream.Rewind()
	Quit tIOStream.Read()
]]></Implementation>
</Method>

<Method name="OutputToIOStream">
<Description>
Convert segments back to Stream, using sequence number</Description>
<FormalSpec>pIOStream:%IO.I.CharacterStream,pSeparators:%String,pSequenceNumber:%String="",pSegNum:%String,pSegPath:%String,pParentDoc:EnsLib.EDI.Document,pIOFormatClassname:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSeparators=$S(""=$G(pSeparators):..Separators, 1:pSeparators)
	Quit:""'=pIOFormatClassname&&$classmethod(pIOFormatClassname,"OutputSegment",$this,.tSC,pIOStream,tSeparators,.pSegNum,.pSegPath,.pParentDoc,.pSequenceNumber) tSC

	Set tSegTerminator=$$$SEGTERM(tSeparators)  Set:""=tSegTerminator tSegTerminator=$C($$$HL7DefSegTerminatorAscii)
	If (..Name="MSH")&&(pSequenceNumber'="") {
		Set tSeparators=$E(tSeparators,1,5)
		If $E(tSeparators_$C(0,0,0,0),5)?1C {
			Set tSeparators=$E(tSeparators,1,5)_$E($C(17,18,19,20),$L(tSeparators),4)
			Set tShowSeparators=$ZStrip(tSeparators,">C")
		} Else { Set tShowSeparators=tSeparators }

		Set tFS=$$$FSSEP(tSeparators)
		Do pIOStream.Write(..Name_tShowSeparators_..TC,0,.tSC)  Quit:$$$ISERR(tSC) tSC
		For i=3:1:12 Do pIOStream.Write(tFS_..GetValueAt(i,tSeparators),0,.tSC)  Quit:$$$ISERR(tSC)
		Quit:$$$ISERR(tSC) tSC
		Do pIOStream.Write(tFS_pSequenceNumber,0,.tSC)  Quit:$$$ISERR(tSC) tSC
		For i=14:1:..Count Do pIOStream.Write(tFS_..GetValueAt(i,tSeparators),0,.tSC)  Quit:$$$ISERR(tSC)
		Do pIOStream.Write(tSegTerminator,0,.tSC)  Quit:$$$ISERR(tSC) tSC
	} Else {
		Set data=..GetValueAt("",.pSeparators)
		If data'="" {
			If (..ID="")||$D(..DataArray)||'$D($$$vaSegmentExt(..ID,1)) {
				Do pIOStream.Write(data_tSegTerminator,0,.tSC)  Quit:$$$ISERR(tSC) tSC
			} Else {
				Do pIOStream.Write(data,0,.tSC)  Quit:$$$ISERR(tSC) tSC
				For i=1:1 { Quit:'$D($$$vaSegmentExt(..ID,i),data)
					Do pIOStream.Write(data,0,.tSC)  Quit:$$$ISERR(tSC)
				}
				Quit:$$$ISERR(tSC) tSC
				Do pIOStream.Write(tSegTerminator,0,.tSC)  Quit:$$$ISERR(tSC) tSC
			}
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="outputHTMLSeg">
<FormalSpec>pSeparators:%String,pSegNum:%String="",pSegPath:%String="",pDocument:EnsLib.EDI.Document=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..OutputToDevice(.pSeparators,,pSegNum,pSegPath,pDocument,"EnsLib.HL7.Util.FormatHTMLv2")
]]></Implementation>
</Method>

<Method name="outputHTMLSegZen">
<FormalSpec>pSeparators:%String,pSegNum:%String="",pSegPath:%String="",pDocument:EnsLib.EDI.Document=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..OutputToDevice(.pSeparators,,pSegNum,pSegPath,pDocument,"EnsLib.HL7.Util.FormatHTMLv2Zen")
]]></Implementation>
</Method>

<Method name="ImportFromString">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pString:%String,*pStatus:%Status,pSeparators:%String,&pConfigItem:%String="",pIOFormatClassname:%String]]></FormalSpec>
<ReturnType>EnsLib.HL7.Segment</ReturnType>
<Implementation><![CDATA[
	If ""'=$G(pIOFormatClassname) {
		Set tIOStream=##Class(%IO.StringStream).%New(pString)
		Set tSeg=..ImportFromIOStream(tIOStream,.pStatus,.pSeparators,.pIOFormatClassname)
		Quit:$$$IsdefObject(tSeg)||$$$ISERR(pStatus) $G(tSeg)
		// Else assume it abdicated and continue to decomposeData()
	}
	Set tSeg=..%New()
	Set tSeparators=$S(""=$G(pSeparators):tSeg.Separators, 1:pSeparators)
	Set tFS=$E($ZStrip($E(pString,1,1+$$$MAXSEGNAME),"*AN")) ; separator is first non-alphanumeric char
	If (""=$G(pSeparators))&&(tFS=$E(pString))&&(tFS=$E(pString,9))&&($E(pString,6,8)?1U1U1UN) {
		#; the input comes with separators prefix
		Set tSeparators=$E(pString,1,5), pString=$E(pString,6,*)
	}
	If $Case($P(pString,tFS),"MSH":1,"FHS":1,"BHS":1,:0) {
		Set tSeparators=tFS_$P(pString,tFS,2)
		Set:$L(tSeparators)'=5 tSeparators=$E(tSeparators,1,5)_$E($$$HL7DefFS_$C(17,18,19,20),$L(tSeparators)+1,5)
	} ElseIf tFS'=$E(tSeparators) {
		Set $E(tSeparators,1)=tFS  For i=2:1:5 { Set:tFS=$E(tSeparators,i) $E(tSeparators,i)=$E($C(0,17,18,19,20),i) }
	}
	Set pStatus=tSeg.decomposeData(tSeparators_pString)
	Quit:$$$ISERR(pStatus) $$$NULLOREF
	Quit tSeg
]]></Implementation>
</Method>

<Method name="ImportFromIOStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>pIOStream:%IO.I.CharacterStream,*pStatus:%Status=$$$OK,pSeparators:%String,pIOFormatClassname:%String=""</FormalSpec>
<ReturnType>EnsLib.HL7.Message</ReturnType>
<Implementation><![CDATA[
	Quit:""'=pIOFormatClassname&&$classmethod(pIOFormatClassname,"ImportSegment",.tSeg,.pStatus,pIOStream,.pSeparators) tSeg
	Set tString=pIOStream.Read()
	Quit ..ImportFromString(tString,.pStatus,.pSeparators)
]]></Implementation>
</Method>

<Method name="newFieldStream">
<Description>
Create a new output stream based on an input spec: used as classname if class exists, otherwise as filename for a writable %IO.FileStream </Description>
<Internal>1</Internal>
<FormalSpec>pStreamSpec:%String,*pSC:%Status=$$$OK</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
	Kill %objlasterror
	If $G(pStreamSpec)=$$$NULLOREF {
		Set tStream=##class(%Stream.GlobalCharacter).%New(), tType="%Stream.GlobalCharacter"
	} ElseIf ##class(%Dictionary.CompiledClass).%ExistsId(pStreamSpec) && ($classmethod(pStreamSpec,"%Extends","%IO.I.Stream") || $classmethod(pStreamSpec,"%Extends","%Stream.Object")) {
		Set tType=pStreamSpec, tStream=$classmethod(pStreamSpec,"%New")
	} Else {
		Set tStream=##class(%IO.FileStream).%New(), tType="%IO.FileStream"
		Do:$IsObject(tStream) tStream.Open(pStreamSpec,"NEWR",,.pSC)
	}
	Set:'$IsObject(tStream) pSC=$$$ERROR($$$EnsErrGeneral,"Unable to create "_tType_" object:"_$$$StatusDisplayString($G(%objlasterror,$$$OK)))
	Quit tStream
]]></Implementation>
</Method>

<Method name="GetFieldStreamRaw">
<Description><![CDATA[
Read a field from a segment into a stream.
<var>pRemainder</var> is the remainder of the segment after the stream field, including the field's terminating separator]]></Description>
<FormalSpec><![CDATA[&pStream:%Stream.Object,pPropertyPath:%String="",*pRemainder:%String="",pProc:%String="writeRaw",&pHint]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Construct pStream stream object if it is not an object passed in
	Set:'$$$IsdefObject(pStream) pStream=..newFieldStream(.pStream)

	#; We're done if the (partial) field is not the whole remainder of the segment chunk
	Set tData=..GetValueAt(pPropertyPath,,.tSC)  Quit:$$$ISERR(tSC) tSC
	If ""=..ID {
		Set pRemainder=..getRemainderFromArray(pPropertyPath,.tSC)
		Set tPrev=tData, next=6 ; use next as a flag for pRemainder already gotten
		Set pHint("%seps")=..Separators
	} Else {
		Set data0=$$$vaSegment(..ID), pHint("%seps")=$E(data0,1,5)
		Set next=$F(data0,tData,6)
		If 'next {
			Quit $$$ERROR($$$EnsErrGeneral,"Array/Global mismatch reading segment data at property path '"_pPropertyPath_"'")
		} ElseIf (next <= $L(data0)) {
			Set pRemainder=$E(data0,next,*)_$G($$$vaSegmentExt(..ID,1))
			Set tPrev=tData
		} Else {
			Set tMaxStr=$$$MaxLocalLength-50 ; 50 for the 10-char unescape extra plus 30 for 3 mod4 escape sequences plus 10 for good luck
			Set next=0, tPrev=""  For i=0:1 {
				#; Only process enough to leave 16k tail for separators checking
				#; process chunks rounded to nearest 4 for base64 processing
				#; leave at least 10 left over after last unescape for further unescaping
				Quit:i>0&&'$D($$$vaSegmentExt(..ID,i),tData) ; tPrev is the final chunk
				Set tPos=$L(tPrev)+$L(tData)-16000  Set tPos=$S(tPos<0:0, 1:tPos-(tPos#4))
				If tPos<$L(tPrev) { Set tCurr=$E(tPrev,1,tPos), tPrev=$E(tPrev,tPos+1,*)_tData, tData="" }
				Else {
					Set tCurr=tPrev, tPrev=$E(tData,tPos+1-$L(tCurr),*), tData=$E(tData,1,tPos-$L(tCurr))
					#; Rebalance to ensure enough elbow room in each string
					If $L(tCurr)+$L(tData)<tMaxStr { Set tCurr=tCurr_tData, tData="" }
					ElseIf $L(tData)<20 {
						Set tData=$E(tCurr,16000+1,*)_tData, $E(tCurr,16000+1,$L(tCurr))=""
					} ElseIf $L(tCurr)<20 {
						Set tMov=16000-$L(tCurr)
						Set tCurr=tCurr_$E(tData,1,tMov), $E(tData,1,tMov)=""
					}
				}
				#; Process (most of) tCurr and tData if any
				Set tSC=$method($this,pProc,pStream,tCurr,.pHint)  Quit:$$$ISERR(tSC)
				Set:""'=tData tSC=$method($this,pProc,pStream,tData,.pHint)  Quit:$$$ISERR(tSC)
			} Quit:$$$ISERR(tSC) tSC
		}
	}
	If ""'=tPrev {
		If 'next {
			#; Find separators relevant to the given Property Path
			Set tSeps=""
			Set:pPropertyPath'="" tSeps=$$$FSSEP(data0)
			Set:pPropertyPath["(" tSeps=tSeps_$$$RSSEP(data0)
			Set pd=$F(pPropertyPath,".") Set:pd tSeps=tSeps_$$$CSSEP(data0)
			Set:pd&&$F(pPropertyPath,".",pd) tSeps=tSeps_$$$SSSEP(data0)

			#; Find first relevant separator in last chunk
			For i=1:1 { Quit:""=$E(tSeps,i)  Set rpos=$F(tPrev,$E(tSeps,i)) Set:rpos tHit(rpos-1)="" }
			Set tHit=$O(tHit(""))
			Set:tHit pRemainder=$E(tPrev,tHit,*), $E(tPrev,tHit,$L(tPrev))=""
		}
		Set pHint("%fin")=1
		Set tSC=$method($this,pProc,pStream,tPrev,.pHint)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="writeRaw">
<Internal>1</Internal>
<FormalSpec><![CDATA[pStream:%Stream.Object,pData:%String,&pHint]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If pStream.%Extends("%IO.I.Stream") {
		Do pStream.Write(pData,,.tSC)
		Quit tSC
	}
	Quit pStream.Write(pData)
]]></Implementation>
</Method>

<Method name="GetFieldStreamBase64">
<Description><![CDATA[
Read a field from a segment into a stream, decoding from Base64 to plain binary.
<var>pRemainder</var> is the remainder of the segment after the stream field, including the field's terminating separator]]></Description>
<FormalSpec><![CDATA[&pStream:%Stream.Object,pPropertyPath:%String="",*pRemainder:%String="",pUnescapeFirst:%Boolean=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tHint("%unesc64")=pUnescapeFirst
	Quit ..GetFieldStreamRaw(.pStream,.pPropertyPath,.pRemainder,$S(pUnescapeFirst:"writeUnescaped",1:"writeBase64"),.tHint)
]]></Implementation>
</Method>

<Method name="writeBase64">
<Internal>1</Internal>
<FormalSpec><![CDATA[pStream:%Stream.Object,pData:%String,&pHint]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		Set tSC=..writeRaw(pStream,$System.Encryption.Base64Decode(pData))
	} catch {
		Set tSC=$$$ERROR($$$EnsErrGeneral,"Error "_$$$StatusDisplayString($$$SystemError)_" writing decoded Base64 from data '"_$S($L(pData)<200:pData,1:$E(pData,1,100)_"..."_$E(pData,*+1-100,*))_"'")
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetFieldStreamUnescaped">
<Description><![CDATA[
Read a field from a segment into a stream, unescaping any encoded separators or newlines, to plain text.
<var>pRemainder</var> is the remainder of the segment after the stream field, including the field's terminating separator]]></Description>
<FormalSpec><![CDATA[&pStream:%Stream.Object,pPropertyPath:%String="",*pRemainder:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..GetFieldStreamRaw(.pStream,.pPropertyPath,.pRemainder,"writeUnescaped",.tHint)
]]></Implementation>
</Method>

<Method name="writeUnescaped">
<Internal>1</Internal>
<FormalSpec><![CDATA[pStream:%Stream.Object,pData:%String,&pHint]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set:""'=$G(pHint) pData=pHint_pData, pHint=""
	If $G(pHint("%fin")) {
		Set pData=..UnescapeEx(pData,pHint("%seps")), tExtra=""
	} ElseIf '$G(pHint("%unesc64")) {
		Set pData=..UnescapeEx(pData,pHint("%seps"),,.tAfterPos), tExtra=""
		If tAfterPos<=$L(pData) {
			Set:$L(pData)+2-10>tAfterPos tAfterPos=$L(pData)+2-10
			Set tExtra=$E(pData,tAfterPos,*)_tExtra, $E(pData,tAfterPos,$L(pData))=""
		}
	} Else {
		#; Find the site of the last replacement
		#; Make it mod 4 in case we need to base64 decode
		#; save some extra extra in case there is a replacement right at the end
		Set tExtra=$E(pData,*+1-30,*), pData=$E(pData,1,*-30)
		Set pData=..UnescapeEx(pData,pHint("%seps"),,.tAfterPos)
		Set tMod4Tail=$L(pData)+2-10-($L(pData)+1-10#4)
		If tMod4Tail>=tAfterPos {
			Set tAfterPos=tMod4Tail
			Set tExtra=$E(pData,tAfterPos,*)_tExtra, $E(pData,tAfterPos,$L(pData))=""
		} Else {
			#; Increment escaped pData until we get to Mod4
			Set tExtra=$E(pData,tAfterPos,*)_tExtra, $E(pData,tAfterPos,$L(pData))=""
			Set tNeeded=4-($L(pData)#4)
			For i=3:1:30 { Quit:tNeeded=4
				Set tAfterPos=0, tTail=..UnescapeEx($E(tExtra,1,i),pHint("%seps"),,.tAfterPos)
				If tAfterPos { ; we hit an escape sequence - is it far enough along?
					If tAfterPos-1<tNeeded {
						Set pData=pData_$E(tTail,1,tAfterPos-1), $E(tExtra,1,i)="", i=0
						Set tNeeded=4-($L(pData)#4)
					} Else {
						Set pData=pData_$E(tTail,1,tNeeded)
						If tAfterPos-1=tNeeded {
							Set $E(tExtra,1,i)=""
						} Else {
							Set $E(tExtra,1,tNeeded)=""
						}
						Set tNeeded=4 ; done
					}
				} ElseIf i-10>0 { ; 10 is enough to be sure of no escape seqence
					Set pData=pData_$E(tExtra), $E(tExtra)="", i=i-1
					Set tNeeded=4-($L(pData)#4)
				}
			}
		}
	}
	Set pHint=tExtra
	If $G(pHint("%unesc64")) {
		Quit ..writeBase64(pStream,pData,.pHint)
	}
	Quit ..writeRaw(pStream,pData,.pHint)
]]></Implementation>
</Method>

<Method name="ReadRawDataStream">
<Description>
deprecated: use GetFieldStreamRaw(), GetFieldStreamUnescaped(), or GetFieldStreamBase64()</Description>
<Internal>1</Internal>
<FormalSpec><![CDATA[&pStream:%Stream.Object,pPropertyPath:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set:'$$$IsdefObject(pStream) pStream=$classmethod($S(""'=$G(pStream):pStream, 1:"%Library.GlobalCharacterStream"),"%New")

	Set tMarker=..GetValueAt(pPropertyPath,,.tSC)  Quit:$$$ISERR(tSC) tSC
	If pStream.%Extends("%IO.I.Stream") {
		Do pStream.Write(tMarker,.tSC)  Quit:$$$ISERR(tSC) tSC
	} Else {
		Set tSC=pStream.Write(tMarker)  Quit:$$$ISERR(tSC) tSC
	}
	Set data0=$S(""=..ID:".", 1:$$$vaSegment(..ID))
	Quit:""=..ID||($F(data0,tMarker,6)-1<$L(data0)) tSC
	For i=1:1 { Quit:'$D($$$vaSegmentExt(..ID,i),data)
		If pStream.%Extends("%IO.I.Stream") {
			Do pStream.Write(data,.tSC)  Quit:$$$ISERR(tSC)
		} Else {
			Set tSC=pStream.Write(data)  Quit:$$$ISERR(tSC)
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="StoreFieldStreamRaw">
<Description><![CDATA[
Store a stream into a segment field. Note that this renders the segment immutable after completing, and therefore works only once per segment.
<var>pRemainder</var> contains trailing segment text to be appended raw after the stream value.]]></Description>
<FormalSpec><![CDATA[pStream:%Stream.Object,pPropertyPath:%String="",pRemainder:%String="",pProc:%String="readRaw",&pHint]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tMaxStr=$$$MaxLocalLength
	Set tSC=$$$OK, i=0, tMarker=..ESC_".stream"_..ESC

	#; Place a marker at the target site
	Set tSC=..SetValueAt(tMarker,pPropertyPath)  Quit:$$$ISERR(tSC) tSC
	Set tSC=..SaveData()  Quit:$$$ISERR(tSC) tSC
	Kill ..DataArray
	Set data=$$$vaSegment(..ID), pHint("%seps")=$E(data,1,5)
	Set pos=$F(data,tMarker,6) Quit:'pos $$$ERROR($$$EnsErrGeneral,"Unable find stream store location in segment")
	Set data2=$S(""'=pRemainder:pRemainder,1:$E(data,pos,*))
	Set maxSegLen=$$$HL7MaxSegLen, chunkpos=pos-$L(tMarker), chunkmax=maxSegLen-(chunkpos-1)

	Set chunk=$method($this,pProc,pStream,tMaxStr,.tSC,.pHint)  Quit:$$$ISERR(tSC) tSC
	Set $E($$$vaSegment(..ID),chunkpos,$L(data))=$E(chunk,1,chunkmax)

	Set i=0,prevchunk="",tLast2=0 For {
		Set:""=chunk&&'tLast2 tLast2=1
		Set chunk=$S(chunkmax-$L(prevchunk)>$L(chunk):"", 1:$E(chunk,chunkmax-$L(prevchunk)+1,*))
		Set chunkpos=1+$L($S('i:$$$vaSegment(..ID),1:$$$vaSegmentExt(..ID,i)))
		If chunkpos>maxSegLen { Set i=i+1, chunkpos=1, chunkmax=maxSegLen }
		Else { Set chunkmax=maxSegLen-(chunkpos-1) }
		
		If tLast2 {
			Set prevchunk=""
			Quit:data2_chunk=""
			Set:data2'="" chunk=data2, data2=""
		} Else {
			Set prevchunk=chunk
			Set chunk=$method($this,pProc,pStream,tMaxStr,.tSC,.pHint)  Quit:$$$ISERR(tSC)
		}
		If 'i {
			Set $$$vaSegment(..ID)=$$$vaSegment(..ID)_prevchunk_$E(chunk,1,chunkmax-$L(prevchunk))
		} Else {
			Set $$$vaSegmentExt(..ID,i)=$G($$$vaSegmentExt(..ID,i))_prevchunk_$E(chunk,1,chunkmax-$L(prevchunk))
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="readRaw">
<Internal>1</Internal>
<FormalSpec><![CDATA[pStream:%Stream.Object,pMaxRead:%Integer,pSC:%Status,&pHint]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If pStream.%Extends("%IO.I.Stream") {
		Quit pStream.Read(pMaxRead,,.pSC)
	}
	Quit pStream.Read(pMaxRead,.pSC)
]]></Implementation>
</Method>

<Method name="StoreFieldStreamBase64">
<Description>
Store a stream into a segment field, encoding as Base64. Note that this renders the segment immutable after completing, and therefore works only once per segment.</Description>
<FormalSpec>pStream:%Stream.Object,pPropertyPath:%String="",pRemainder:%String="",pEscapeAfter:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tHint("%esc64")=pEscapeAfter
	Quit ..StoreFieldStreamRaw(.pStream,.pPropertyPath,.pRemainder,"readBase64",.tHint)
]]></Implementation>
</Method>

<Method name="readBase64">
<Internal>1</Internal>
<FormalSpec><![CDATA[pStream:%Stream.Object,pMaxRead:%Integer,pSC:%Status,&pHint]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pMaxRead=pMaxRead\4*3-(pMaxRead\52*2) ; make room for Base64 expansion
	Set:$G(pHint("%esc64")) pMaxRead=pMaxRead\10 ; make room for escape codes
	#; round down to multiple of 3 for Base64 chunk
	Set pMaxRead=pMaxRead-(pMaxRead#3)
	Set tData=..readRaw(pStream,pMaxRead,.pSC,.pHint)  Quit:$$$ISERR(pSC) ""
	Set tData=$System.Encryption.Base64Encode(tData)
	Set:$G(pHint("%esc64")) tData=..EscapeEx(tData,pHint("%seps"))
	Quit tData
]]></Implementation>
</Method>

<Method name="StoreFieldStreamEscaped">
<Description>
Store a stream into a segment field, applying HL7 escaping. Note that this renders the segment immutable after completing, and therefore works only once per segment.</Description>
<FormalSpec>pStream:%Stream.Object,pPropertyPath:%String="",pRemainder:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..StoreFieldStreamRaw(.pStream,.pPropertyPath,.pRemainder,"readEscaped",.tHint)
]]></Implementation>
</Method>

<Method name="readEscaped">
<Internal>1</Internal>
<FormalSpec><![CDATA[pStream:%Stream.Object,pMaxRead:%Integer,pSC:%Status,&pHint]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tData=..readRaw(pStream,pMaxRead\10,.pSC,.pHint)  Quit:$$$ISERR(pSC) "" ; make room for escape codes
	Quit ..EscapeEx(tData,pHint("%seps"))
]]></Implementation>
</Method>

<Method name="StoreRawDataStream">
<Description>
deprecated: use StoreFieldStreamRaw(), StoreFieldStreamEscaped() or StoreFieldStreamBase64()</Description>
<FormalSpec>pStream:%Stream.Object,pPropertyPath:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK, i=0, tMarker=..ESC_".stream"_..ESC, tMaxSegLen = $$$HL7MaxSegLen
	If pStream.%Extends("%IO.I.Stream") {
		Set chunk=pStream.Read(tMaxSegLen,,.tSC)  Quit:$$$ISERR(tSC) tSC
	} Else {
		Set chunk=pStream.Read(tMaxSegLen,.tSC)  Quit:$$$ISERR(tSC) tSC
	}
	Set tSC=..SetValueAt(tMarker,pPropertyPath)  Quit:$$$ISERR(tSC) tSC
	Set tSC=..SaveData()  Quit:$$$ISERR(tSC) tSC
	Kill ..DataArray
	Set data=$$$vaSegment(..ID)
	Set pos=$F(data,tMarker,6) Quit:'pos $$$ERROR($$$EnsErrGeneral,"Unable find stream store location in segment")
	Set data2=$E(data,pos,*)

	Set chunkpos=pos-$L(tMarker), chunkmax=tMaxSegLen-(chunkpos-1)
	Set $E($$$vaSegment(..ID),chunkpos,$L(data))=$E(chunk,1,chunkmax)

	Set i=0,prevchunk="",tLast2=0 For {
		Set:""=chunk&&'tLast2 tLast2=1
		Set chunk=$S(chunkmax-$L(prevchunk)>$L(chunk):"", 1:$E(chunk,chunkmax-$L(prevchunk)+1,*))
		Set chunkpos=$L($S('i:$$$vaSegment(..ID),1:$$$vaSegmentExt(..ID,i)))+1
		If chunkpos>tMaxSegLen { Set i=i+1, chunkpos=1, chunkmax=tMaxSegLen }
		Else { Set chunkmax=tMaxSegLen-(chunkpos-1) }
		
		If tLast2 {
			Set prevchunk=""
			Quit:data2_chunk=""
			Set:data2'="" chunk=data2, data2=""
		} Else {
			Set prevchunk=chunk
			If pStream.%Extends("%IO.I.Stream") {
				Set chunk=pStream.Read(tMaxSegLen,,.tSC)  Quit:$$$ISERR(tSC)
			} Else {
				Set chunk=pStream.Read(tMaxSegLen,.tSC)  Quit:$$$ISERR(tSC)
			}
		}
		If 'i {
			Set $$$vaSegment(..ID)=$$$vaSegment(..ID)_prevchunk_$E(chunk,1,chunkmax-$L(prevchunk))
		} Else {
			Set $$$vaSegmentExt(..ID,i)=$G($$$vaSegmentExt(..ID,i))_prevchunk_$E(chunk,1,chunkmax-$L(prevchunk))
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetValueAt">
<Description><![CDATA[
<var>pPropertyPath</var> is of syntax: <code>field [ ( array ) ] [ . component [ . subcomponent ] ]</code>
Returns the value at the specified property path. 
<var>pSeparators</var> is used to specify the separators to be used when a non-atomic value is returned.
All property path elements must be either name or index.
If a segment's total length is greater than the maximum string length on the system, then fields beyond the 
maximum string length can't be retrieved using this method. (Note that on older Ensemble systems, this 
limit was 32K, but with long strings enabled the limit is approximately 3.6MB.)
If you are dealing with strings longer than the string limit, use one of the following methods:
<ul><li><method>GetFieldStreamRaw</method>(),
<li><method>GetFieldStreamUnescaped</method>(), or</li>
<li><method>GetFieldStreamBase64</method>()</li></ul>]]></Description>
<FormalSpec>pPropertyPath:%String,pSeparators:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If (..ID="")||$D(..DataArray) {
		Quit ..getAtFromArray(.pPropertyPath,.pSeparators,.pStatus)
	} Else {
		Quit ..getAtFromGlobal(.pPropertyPath,.pSeparators,.pStatus)
	}
]]></Implementation>
</Method>

<Method name="GetNextIndex">
<Description>
Gets the next index in an array</Description>
<FormalSpec><![CDATA[pPath:%String,pIndex:%String,&pStatus:%Status=$$$OK]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If $E(pPath,*-1,*)'="()" Set pStatus=$$$ERROR($$$EnsErrGeneral,"Can't iterate on PropertyPath '"_pPath_"'")  Quit ""
	Set field=$E(pPath,1,*-2)
	If +field'=field {
		If field="" Set pStatus=$$$ERROR($$$EnsErrGeneral,"Can't iterate on empty PropertyPath")  Quit ""
		Set field=$S((..DocTypeCategory="")||(..DocTypeName=""):"", 1:$G($$$vaSchemaGbl(..DocTypeCategory,"SS",..DocTypeName,"map",$ZCVT(field,"L"))))
		If $E(field,*-1,*)'="()" Set pStatus=$$$ERROR($$$EnsErrGeneral,"PropertyPath '"_field_"' is not an array property")  Quit ""
		Set field=$E(field,1,*-2)
		If +field'=field Set pStatus=$$$ERROR($$$EnsErrGeneral,"Unrecognized Property Index '"_field_"'")  Quit ""
	}
	If $Case(..Name,"MSH":0,"FHS":0,"BHS":0,:1) Set field=field+1
	If '$D(..DataArray) Set pStatus=..decompose() Quit:$$$ISERR(pStatus) ""
	Quit $O(..DataArray(field,pIndex))
]]></Implementation>
</Method>

<Method name="SetValueAt">
<Description><![CDATA[
Sets the value at the specified property path.
pPropertyPath is of syntax: field [ ( array ) ] [ . component [ . subcomponent ] ]
All property path elements must be either name or index. pKey is used to append an array index to the value at
the given property path. pAction corresponds to the actions in the DTL <assign> statement.
If a segment's total length is more than the current string length limit, or will be after setting the value, then this method can't be used. Instead, use one of the methods StoreFieldStreamRaw(), StoreFieldStreamEscaped() or StoreFieldStreamBase64()]]></Description>
<FormalSpec>pValue:%String,pPropertyPath:%String="",pAction:%String="set",pKey:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'..IsMutable $$$ERROR($$$EnsErrGeneral,"Segment is immutable")
	Set:$Case(pAction,"remove":1,"clear":1,:'($D(pValue)#2)) pValue=""
	If '$D(..DataArray) Set tSC=..decompose()  Quit:$$$ISERR(tSC) tSC
	Set i%ID="" ; clear the ID because we are no longer referring to it
	If pKey'="" Set pPropertyPath=pPropertyPath_"("_pKey_")"
	Set tSC=..parsePropertyPath(pPropertyPath,.field,.array,.component,.subcomponent)  Quit:$$$ISERR(tSC) tSC
	If $Case(..Name,"MSH":1,"FHS":1,"BHS":1,:0) {
		If field=2 Set ..FS=pValue Quit $$$OK
		If field=3 Set ..Separators=..FS_pValue, ..TC=$E(pValue,5) Quit $$$OK
		If field'="",field>1 Set field=field-1
	}
	Set data=pValue
	If field="" {
		Kill:pAction'="append" ..DataArray
		Set data1=data
		For i=1:1:$L(data1,..FS) { Set data2=$P(data1,..FS,i)
			For j=1:1:$L(data2,..RS) { Set data3=$P(data2,..RS,j)
				For k=1:1:$L(data3,..CS) { Set data4=$P(data3,..CS,k)
					For l=1:1:$L(data4,..SS) { Set ..DataArray(i,j,k,l)=$S(pAction="append":$G(..DataArray(i,j,k,l)),1:"")_$P(data4,..SS,l) }
				}
			}
		}
	} ElseIf array="" {
		Kill:pAction'="append" ..DataArray(field)
		Set data2=data
		For j=1:1:$L(data2,..RS) { Set data3=$P(data2,..RS,j)
			For k=1:1:$L(data3,..CS) { Set data4=$P(data3,..CS,k)
				For l=1:1:$L(data4,..SS) { Set ..DataArray(field,j,k,l)=$S(pAction="append":$G(..DataArray(field,j,k,l)),1:"")_$P(data4,..SS,l) }
			}
		}
	} ElseIf component="" {
		Kill:pAction'="append" ..DataArray(field,array)
		Set data3=data
		For k=1:1:$L(data3,..CS) { Set data4=$P(data3,..CS,k)
			For l=1:1:$L(data4,..SS) { Set ..DataArray(field,array,k,l)=$S(pAction="append":$G(..DataArray(field,array,k,l)),1:"")_$P(data4,..SS,l) }
		}
	} ElseIf subcomponent="" {
		Kill:pAction'="append" ..DataArray(field,array,component)
		Set data4=data
		For l=1:1:$L(data4,..SS) { Set ..DataArray(field,array,component,l)=$S(pAction="append":$G(..DataArray(field,array,component,l)),1:"")_$P(data4,..SS,l) }
	} Else {
		Set ..DataArray(field,array,component,subcomponent)=$S(pAction="append":$G(..DataArray(field,array,component,subcomponent)),1:"")_data
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="CopyValues">
<FormalSpec>pSource:EnsLib.HL7.Segment,pSourcePath:%String,pTargetPath:%String,pAction:%String,pKey:%String,pEmptyFieldAsNull:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSourceWild=$F(pSourcePath,"()"), tTargetWild=$F(pTargetPath,"()")
	If tSourceWild||tTargetWild {
		Set tSourceHead=$P(pSourcePath,"()"), tSourceTail=$P(pSourcePath,"()",2,*)
		Set tTargetHead=$P(pTargetPath,"()"), tTargetTail=$P(pTargetPath,"()",2,*)
		If tSourceWild {
			If pEmptyFieldAsNull&&tTargetWild {
				Quit:(pSource.GetValueAt(tSourceHead)="") $$$OK
			}
			Set i=""
			For {
				Set i=pSource.GetNextIndex(tSourceHead_"()",i,.tSC) Quit:i=""
				Set tSourceNewPath=tSourceHead_"("_(i)_")"_tSourceTail
				Set tTargetNewPath=$S(tTargetWild:tTargetHead_"("_(i)_")"_tTargetTail,1:pTargetPath)
				Set tSC=..CopyValues(pSource,tSourceNewPath,tTargetNewPath,pAction,pKey,pEmptyFieldAsNull) Quit:$$$ISERR(tSC)
			}
		} Else {
			Set i=""
			For {
				Set i=..GetNextIndex(tTargetHead_"()",i,.tSC) Quit:i=""
				Set tTargetNewPath=tTargetHead_"("_(i)_")"_tTargetTail
				Set tSC=..CopyValues(pSource,pSourcePath,tTargetNewPath,pAction,pKey) Quit:$$$ISERR(tSC)
			}
		}
	} Else {
		Set tSC=..SetValueAt(pSource.GetValueAt(pSourcePath),pTargetPath,pAction,pKey)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="decompose">
<Description>
Decompose the segment from a single string into a multidimensional array</Description>
<CodeMode>expression</CodeMode>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[$S($D(..DataArray):$$$ERROR($$$EnsErrGeneral,"array data already exists"), ""=..ID:$$$OK, 1:..decomposeData($$$vaSegment(..ID)))
]]></Implementation>
</Method>

<Method name="decomposeData">
<FormalSpec>pData:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set FS=$E(pData,1), CS=$E(pData,2), RS=$E(pData,3), ESC=$E(pData,4), SS=$E(pData,5), data1=$E(pData,6,*)
	For i=1:1:$L(data1,FS) { Set data2=$P(data1,FS,i)
		For j=1:1:$L(data2,RS) { Set data3=$P(data2,RS,j)
			For k=1:1:$L(data3,CS) { Set data4=$P(data3,CS,k)
				For l=1:1:$L(data4,SS) { Set ..DataArray(i,j,k,l)=$P(data4,SS,l) }
			}
		}
	}
	Set:$Case($P(data1,FS),"MSH":1,"BHS":1,"FHS":1,:0) ..TC=$G(..DataArray(2,2,1,2))
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getAtFromGlobal">
<FormalSpec>pPropertyPath:%String="",pSeparators:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set data=$$$vaSegment(..ID)
	If ""=$G(pSeparators) { Set (tShowSeparators,tSeparators)=$E(data,1,5), FS=$$$FSSEP(tSeparators), data=$E(data,6,*) }
	Else {
		Set tSeparators=$E(pSeparators,1,5), FS=$$$FSSEP(tSeparators)
		If $E(tSeparators_$C(0,0,0,0),5)?1C {
			Set tSeparators=tSeparators_$E($C(17,18,19,20),$L(tSeparators),4)
			Set tShowSeparators=$ZStrip(tSeparators,">C") ; allow short separators list
		} Else { Set tShowSeparators=tSeparators }
		If $E(data,1,5)'=tSeparators {
			Set data=..replaceSeparators(data,tSeparators), data=$E(data,6,*) 
			Set:""=pPropertyPath&&$Case($P(data,FS),"MSH":1,"FHS":1,"BHS":1,:0) $P(data,FS,2)=$E(tShowSeparators,2,5)_$E($P(data,FS,2),5)
		} Else {
			Set data=$E(data,6,*)
			Set:""=pPropertyPath&&$Case($P(data,FS),"MSH":1,"FHS":1,"BHS":1,:0)&&(tShowSeparators'=tSeparators) $P(data,FS,2)=$E(tShowSeparators,2,5)_$E($P(data,FS,2),5)
		}
	}
	Set tName=$P(data,FS)
	Set:$Case(tName,"MSH":1,"FHS":1,"BHS":1,:0) ..TC = $E($P(data,FS,2),5)
	If ""=pPropertyPath Set pStatus=$$$OK  Quit data
	Set pStatus=..parsePropertyPath(pPropertyPath,.field,.array,.component,.subcomponent)  Quit:$$$ISERR(pStatus) ""
	If $Case(tName,"MSH":1,"FHS":1,"BHS":1,:0) {
		Quit:field=1 tName
		Quit:field=2 FS
		Quit:field=3 $E(tShowSeparators,2,5)_..TC
		Quit:field="*" $L(data,FS)
		Set:field'="" field=field-1
	}
	If field'="" Set data=$S(field="*":$L(data,FS)-1,1:$P(data,FS,field))
	If array'="" Set RS=$$$RSSEP(tSeparators), data=$S(array="*":$L(data,RS),1:$P(data,RS,array))
	If component'="" Set CS=$$$CSSEP(tSeparators), data=$S(component="*":$L(data,CS),1:$P(data,CS,component))
	If subcomponent'="" Set SS=$$$SSSEP(tSeparators), data=$S(subcomponent="*":$L(data,SS),1:$P(data,SS,subcomponent))
	Quit data
]]></Implementation>
</Method>

<Method name="getAtFromArray">
<FormalSpec>pPropertyPath:%String="",pSeparators:%String,*pStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tSeparators=$S(""=$G(pSeparators):..Separators, 1:$E(pSeparators,1,5))
	If $E(tSeparators_$C(0,0,0,0),5)?1C {
		Set tSeparators=tSeparators_$E($C(17,18,19,20),$L(tSeparators),4)
		Set tShowSeparators=$ZStrip(tSeparators,">C") ; allow short separators list
	} Else { Set tShowSeparators=tSeparators }
	Set FS=$$$FSSEP(tSeparators), CS=$$$CSSEP(tSeparators), RS=$$$RSSEP(tSeparators), SS=$$$SSSEP(tSeparators)
	Set pStatus=..parsePropertyPath(pPropertyPath,.I,.J,.K,.L) Quit:$$$ISERR(pStatus) ""
	Set tName=$G(..DataArray(1,1,1,1))
	If $Case(tName,"MSH":1,"FHS":1,"BHS":1,:0) {
		Quit:I=1 tName
		Quit:I=2 FS
		Quit:I=3 $E(tShowSeparators,2,5)_..TC
		Quit:I="*" $O(..DataArray(""),-1)
		If I="" {
			Set data=tName_tShowSeparators_..TC, tCount=$O(..DataArray(""),-1)
			For i=3:1:tCount Set data=data_FS_..getAtFromArray(i,tSeparators)
			Quit data
		}
		Set I=I-1
	}
	Set lasti=$O(..DataArray(""),-1)
	If I="*" {
		Set data=lasti-1
	} Else {
		Set data=""
		For i=1:1:lasti {
			If I'="",i'=I Continue
			If I="",i>1 Set data=data_FS
			Set lastj=$O(..DataArray(i,""),-1)
			If J="*" Set data=lastj Quit
			For j=1:1:lastj {
				If J'="",j'=J Continue
				If J="",j>1 Set data=data_RS
				Set lastk=$O(..DataArray(i,j,""),-1)
				If K="*" Set data=lastk Quit
				For k=1:1:lastk {
					If K'="",k'=K Continue
					If K="",k>1 Set data=data_CS
					Set lastl=$O(..DataArray(i,j,k,""),-1)
					If L="*" Set data=lastl Quit
					For l=1:1:lastl {
						If L'="",l'=L Continue
						If L="",l>1 Set data=data_SS
						Set value=$G(..DataArray(i,j,k,l))
						Set:tSeparators'=..Separators value=$E(..replaceSeparators(..Separators_value,tSeparators),6,*)
						Set data=data_value
					}
				}
			}
		}
	}
	Quit data
]]></Implementation>
</Method>

<Method name="getRemainderFromArray">
<FormalSpec>pPropertyPath:%String="",*pStatus:%Status=$$$OK</FormalSpec>
<Implementation><![CDATA[
	Set tSeparators=$S(""=$G(pSeparators):..Separators, 1:$E(pSeparators,1,5))
	If $E(tSeparators_$C(0,0,0,0),5)?1C {
		Set tSeparators=tSeparators_$E($C(17,18,19,20),$L(tSeparators),4)
		Set tShowSeparators=$ZStrip(tSeparators,">C") ; allow short separators list
	} Else { Set tShowSeparators=tSeparators }
	Set FS=$$$FSSEP(tSeparators), CS=$$$CSSEP(tSeparators), RS=$$$RSSEP(tSeparators), SS=$$$SSSEP(tSeparators)
	Set pStatus=..parsePropertyPath(pPropertyPath,.I,.J,.K,.L) Quit:$$$ISERR(pStatus) ""
	Quit:I="" ""
	If (I="*")||(J="*")||(K="*")||(L="*") {
		Quit ""
	}
	Set depth = $Select(L'="":4,K'="":3,J'="":2,1:1)
	Set data=""

	Set tName=$G(..DataArray(1,1,1,1))
	If $Case(tName,"MSH":1,"FHS":1,"BHS":1,:0) {
		If $Case(I,1:1,2:1,:0) {
			Set:I=1 data=tShowSeparators_..TC
			Set:I=2 data=$E(tShowSeparators,2,5)_..TC
			Set tCount=$O(..DataArray(""),-1)
			Set I=2
		}
		Else {
			Set I=I-1
		}
	}
	
	Set lasti=$O(..DataArray(""),-1)
	For i=I:1:lasti {
		Continue:(depth=1)&&(i<=I)
		Set:(i>1)&&'((i=I)&&(depth>1)) data=data_FS
		Set lastj=$O(..DataArray(i,""),-1)
		For j=1:1:lastj {
			Continue:(i=I)&&((j<J)||((depth=2)&&(j=J)))
			Set:(j>1)&&'((i=I)&&(j=J)&&(depth'=2)) data=data_RS
			Set lastk=$O(..DataArray(i,j,""),-1)
			For k=1:1:lastk {
				Continue:(i=I)&&(j=J)&&((k<K)||((depth=3)&&(k=K)))
				Set:(k>1)&&'((i=I)&&(j=J)&&(k=K)&&(depth'=3)) data=data_CS
				Set lastl=$O(..DataArray(i,j,k,""),-1)
				For l=1:1:lastl {
					Continue:(i=I)&&(j=J)&&(k=K)&&((l<L)||((depth=4)&&(l=L)))
					Set:l>1 data=data_SS
					Set value=$G(..DataArray(i,j,k,l))
					Set:tSeparators'=..Separators value=$E(..replaceSeparators(..Separators_value,tSeparators),6,*)
					Set data=data_value
				}
			}
		}
	}
	Quit data
]]></Implementation>
</Method>

<Method name="Escape">
<FormalSpec>pData</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..EscapeEx(pData,..Separators)
]]></Implementation>
</Method>

<Method name="Unescape">
<FormalSpec>pData</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..UnescapeEx(pData,..Separators)
]]></Implementation>
</Method>

<Method name="EscapeEx">
<ClassMethod>1</ClassMethod>
<FormalSpec>pData,pSeparators,pEscapeChar</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tEscape=$g(pEscapeChar,$$$ESCSEP(pSeparators))
	Set replace($C(10))=tEscape_"X0A"_tEscape
	Set replace($C(13))=tEscape_"X0D"_tEscape
	Set replace($$$FSSEP(pSeparators))=tEscape_"F"_tEscape
	Set replace($$$RSSEP(pSeparators))=tEscape_"R"_tEscape
	Set replace($$$CSSEP(pSeparators))=tEscape_"S"_tEscape
	Set replace($$$SSSEP(pSeparators))=tEscape_"T"_tEscape
	Set replace($$$ESCSEP(pSeparators))=tEscape_"E"_tEscape
	Quit $$replaceArray^EnsUtil(pData,.replace)
]]></Implementation>
</Method>

<Method name="UnescapeEx">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pData,pSeparators,pEscapeChar,&pLastPos]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tEscape=$g(pEscapeChar,$$$ESCSEP(pSeparators))
	Set replace(tEscape_"X0A"_tEscape)=$c(10)
	Set replace(tEscape_"X0D"_tEscape)=$c(13)
	Set replace(tEscape_".br"_tEscape)=$C(13)
	Set replace(tEscape_"F"_tEscape)=$$$FSSEP(pSeparators)
	Set replace(tEscape_"R"_tEscape)=$$$RSSEP(pSeparators)
	Set replace(tEscape_"S"_tEscape)=$$$CSSEP(pSeparators)
	Set replace(tEscape_"T"_tEscape)=$$$SSSEP(pSeparators)
	Set replace(tEscape_"E"_tEscape)=$$$ESCSEP(pSeparators)
	Quit $$replaceArrayLeftToRight^EnsUtil(pData,.replace,5,.pLastPos)
]]></Implementation>
</Method>

<Method name="parsePropertyPath">
<Description>
Given a property path, determine the Field, Array, Component and Subcomponent positions</Description>
<FormalSpec>pPropertyPath:%String,*pField:%Integer,*pArray:%Integer,*pComponent:%Integer,*pSubcomponent:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pField=$P($P(pPropertyPath,".",1),"(",1)
	Set pArray=$P($P($P(pPropertyPath,".",1),"(",2),")",1)
	Set pComponent=$P(pPropertyPath,".",2)
	Set pSubcomponent=$P(pPropertyPath,".",3)

	If pField'="",pField'="*",pField'=0,+pField'=pField {
		Set index=$ZCVT(pField_$S(pComponent="":"",1:"."_pComponent)_$S(pSubcomponent="":"",1:"."_pSubcomponent),"L")
		Set newspec=$S((..DocTypeCategory="")||(..DocTypeName=""):"", 1:$G($$$vaSchemaGbl(..DocTypeCategory,"SS",..DocTypeName,"map",index)))
		If newspec="" Quit $$$ERROR($$$EnsErrGeneral,"PropertyPath '"_pPropertyPath_"' is invalid.")
		Set pField=$P($P(newspec,".",1),"(",1)
		Set pComponent=$P(newspec,".",2)
		Set pSubcomponent=$P(newspec,".",3)
	}
	If +pField=pField Set pField=pField+1
	If pArray="",pComponent'="" Set pArray=1
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="replaceSeparators">
<ClassMethod>1</ClassMethod>
<FormalSpec>pInputData,oSeparators</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set iSeparators=$e(pInputData,1,5)
	Set mSeparators=$c(1,2,3,4,5)
	set tData=$e(pInputData,6,*)
	Set tData=$tr(tData,iSeparators,mSeparators)
	Set tData=..UnescapeEx(tData,iSeparators,$$$ESCSEP(mSeparators))
	Set tData=..EscapeEx(tData,oSeparators,$$$ESCSEP(mSeparators))
	Quit oSeparators_$tr(tData,mSeparators,oSeparators)
]]></Implementation>
</Method>

<Method name="OutputHTML">
<Description>
Display Segment as HTML, using DocType info if available</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	&html<
	<table border="0" cellspacing="0" cellpadding="0" cols="2" width="100%"><tr><td align="left"><div class="Text" style="margin: 3px;">>
	If ""'=..DocType {
		Set tDesc=##class(EnsLib.HL7.Schema).GetDescription("SS:"_..DocType)
		&html<HL7 <b>#($ZCVT(..Name,"O","HTML"))#</b> Segment, DocType = '<a#($S(""=tDesc:"",1:" title='"_$ZCVT(tDesc,"O","HTML")_"'")_##class(EnsLib.HL7.Util.FormatHTMLv2).getSegLink(..DocType))#><b>#($ZCVT(..DocType,"O","HTML"))#</b></a>'
			<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#($S(""=tDesc:"", 1:"'<b><i>"_$ZCVT(tDesc,"O","HTML")_"</i></b>', "))#>
	} Else {
		&html<HL7 <b>#($ZCVT(..Name,"O","HTML"))#</b> Segment, DocType = <b>''</b>>
	}
	&html<</div></td></tr></table>>
	&html<<table class="EDIDocumentTable" BORDER="0" CELLSPACING="0" CELLPADDING="0">>
	&html<<TR CLASS="EDIDocumentTableRow"><TD CLASS="EDIDocumentTableExpandor">&nbsp;</TD>>
	Set tSC=..outputHTMLSeg()  Quit:$$$ISERR(tSC)
	&html<</TR>>
	&html<</table>>
	Write:$$$ISERR(tSC) $ZCVT($$$StatusDisplayString(tSC),"O","HTML")
	Quit tSC
]]></Implementation>
</Method>

<Method name="OutputHTMLZen">
<Description>
Display Segment as HTML, using DocType info if available</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Set tSeg = $$$Text("Segment","EDIDocumentView")
	Set tTyp = $$$Text("DocType","EDIDocumentView")
	&html<
	<table border="0" cellspacing="0" cellpadding="0" cols="2" width="100%"><tr><td align="left"><div class="Text" style="margin: 3px;">>
	If ""'=..DocType {
		Set tDesc=##class(EnsLib.HL7.Schema).GetDescription("SS:"_..DocType)
		&html<HL7 <b>#($ZCVT(..Name,"O","HTML"))#</b> #(tSeg)#, #(tTyp)# = '<a#($S(""=tDesc:"",1:" title='"_$ZCVT(tDesc,"O","HTML")_"'")_##class(EnsLib.HL7.Util.FormatHTMLv2Zen).getSegLink(..DocType))#><b>#($ZCVT(..DocType,"O","HTML"))#</b></a>'
			<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#($S(""=tDesc:"", 1:"'<b><i>"_$ZCVT(tDesc,"O","HTML")_"</i></b>', "))#>
	} Else {
		&html<HL7 <b>#($ZCVT(..Name,"O","HTML"))#</b> #(tSeg)#, #(tTyp)# = <b>''</b>>
	}
	&html<</div></td></tr></table>>
	&html<<table class="EDIDocumentTable" BORDER="0" CELLSPACING="0" CELLPADDING="0">>
	&html<<TR CLASS="EDIDocumentTableRow"><TD CLASS="EDIDocumentTableExpandor">&nbsp;</TD>>
	Set tSC=..outputHTMLSegZen()  Quit:$$$ISERR(tSC)
	&html<</TR>>
	&html<</table>>
	Write:$$$ISERR(tSC) $ZCVT($$$StatusDisplayString(tSC),"O","HTML")
	Quit tSC
]]></Implementation>
</Method>

<Method name="DumpMaps">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set DocType=..DocType w ! zw DocType
	Set ID=..ID w ! zw ID
	If ..DocTypeCategory'="",..DocTypeName'=""	Merge MapArray=$$$vaSchemaGbl(..DocTypeCategory,"SS",..DocTypeName,"map") w ! zw MapArray
	Merge DataArray=..DataArray w ! zw DataArray
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="buildSchema">
<Description>
Deprecated - to be removed - only used by deprecated toEasyXML</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pType:%String,pTag:%String,&schema]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pCategory = $P(pTag,":")
	Set pName = $P(pTag,":",2)

	Set schema(pType,pTag) = $G($$$vaSchemaGbl(pCategory,pType,pName))
	Quit:schema(pType,pTag)="" $$$ERROR($$$EnsErrGeneral,"No schema for segment '"_pName_"' in "_pType)

	// Build a reverse index, keyed by field number
	Set name=""  For { Set name=$O($$$vaSchemaGbl(pCategory,pType,pName,"names",name),1,i)  Quit:""=name
		Set schema(pType,pTag,i)=name
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="toEasyXML">
<Description>
Deprecated - to be removed</Description>
<Internal>1</Internal>
<FormalSpec><![CDATA[&xml:%String,id:%Integer,baseDocType:%String,&schema="",pToDevice:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#define APPEND(%x,%s) If +$G(pToDevice) { Write %s,! } Else { Do %x.WriteLine(%s) }
#define BLDSCHEMA(%t,%x,%s) Do:'$D(%s(%t,%x)) ..buildSchema(%t,%x,.%s)
#define SETTYPE(%l,%r,%b) Set %l=$S(%r[":":%r,1:%b_":"_%r)

	Set:..DocType="" ..DocType=baseDocType_":"_..Name
	$$$SETTYPE(sstype,..DocType,baseDocType)
	Set sstag   = $ZCVT($P(sstype,":",2),"O","XML")
	Set type    = $ZCVT($P(sstype,":"),"O","XML")

	$$$BLDSCHEMA("SS",sstype,schema)

	$$$APPEND(xml,"<"_sstag_" docType="""_type_""">")

	Set pData = $$$vaSegment(..ID)	
	Set FS=$E(pData,1), CS=$E(pData,2), RS=$E(pData,3), ESC=$E(pData,4), SS=$E(pData,5), data1=$E(pData,6,*)
	Set offset = $S(..Name="MSH":0,1:1)
	For i=1+offset:1:$L(data1,FS) {

		Set idx = i - offset

		// Process each field in turn
		Set data2=$P(data1,FS,i)
		If data2'="" {
			// Generate a wrapping tag for this field
			If $D(schema("SS",sstype,idx)) {
				Set fstag  = $ZCVT(schema("SS",sstype,idx),"O","XML")
				Set fsinfo = $LI(schema("SS",sstype),idx)
			} Else {
				Set fstag = sstag_"."_idx
				Set fsinfo = ""
			}

			If $LG(fsinfo,1)'="" {
				// Dig up the information for the component
				$$$SETTYPE(cstype,$LI(fsinfo,1),baseDocType)
				$$$BLDSCHEMA("DT",cstype,schema)
				Set csinfo = schema("DT",cstype)
			} Else {
				Set (cstype,csinfo)=""
			}

			// Now, look for repetitions
			For j=1:1:$L(data2,RS) {
				// Process each repetition
				Set data3=$P(data2,RS,j)
				If data3="" Continue

				If $G(cstype)'="" {
					$$$APPEND(xml,"<"_fstag_">")

					// Process each component
					For k=1:1:$L(data3,CS) {
						Set data4=$P(data3,CS,k)
						If data4="" Continue

						If $LG(csinfo,k)'="" {
							$$$SETTYPE(sctype,$LI(csinfo,k),baseDocType)
							$$$BLDSCHEMA("DS",sctype,schema)
						} Else {
							Set sctype=""
						}

						Set cstag = $ZCVT($G(schema("DT",$G(cstype,-1),k),"CS"_k),"O","XML")
						If $G(sctype)'="",data4[SS {
							$$$APPEND(xml,"<"_cstag_">")
							For l=1:1:$L(data4,SS) {
								Set data5=$P(data4,SS,l)
								If data5="" Continue

								Set sctag = $ZCVT($G(schema("DT",$G(sctype,-1),l),"SS"_l),"O","XML")
								$$$APPEND(xml,"<"_sctag_">"_$ZCVT(data5,"O","XML")_"</"_sctag_">")
							}
							$$$APPEND(xml,"</"_cstag_">")
						} Else {
							$$$APPEND(xml,"<"_cstag_">"_$ZCVT(data4,"O","XML")_"</"_cstag_">")
						}
					}
					$$$APPEND(xml,"</"_fstag_">")
				} Else {
					$$$APPEND(xml,"<"_fstag_">"_$ZCVT(data3,"O","XML")_"</"_fstag_">")
				}
			}
		}
	}
	$$$APPEND(xml,"</"_sstag_">")
]]></Implementation>
</Method>

<Method name="GetContentArray">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pContents,pMode:%String,pDocType:%String,pLevel:%Integer,pIncludeBase:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tRef=$G(pContents)
	If ("%"=$E(tRef)||("^"=$E(tRef))) {
		Set tSC=##class(EnsLib.HL7.Schema).getFieldsContentArray(.local,.pMode,$P(pDocType,":",1),$P(pDocType,":",2),$S('pLevel:0,1:pLevel+2))
		Merge @tRef=local
		Quit tSC
	} Else {
		Quit ##class(EnsLib.HL7.Schema).getFieldsContentArray(.pContents,.pMode,$P(pDocType,":",1),$P(pDocType,":",2),$S('pLevel:0,1:pLevel+2))
	}
]]></Implementation>
</Method>

<Query name="EnumerateDocTypes">
<Description><![CDATA[
Returns a list of available DocTypes for this document class. <br/>
The DocType is returned as the first column in the result set. <br/>
The <var>Category</var> parameter can be used to restrict the list. <br/>
If <var>Category</var> is: <br/>
 0 - return only DocTypes in standard categories <br/>
 + - return only DocTypes in user-defined categories <br/>
 empty - return DocTypes from all categories <br/>
 a category name - return only DocTypes in the named category <br/>
 a partial name suffixed with '%' - return only DocTypes in categories matching the partial category name <br/>
 other - return nothing <br/>
If <var>IncludeBase</var> is: <br/>
 0 - return only DocTypes defined in the current schema category itself <br/>
 1 - return all DocTypes in the current schema category's base category in addition to those defined in the current category itself <br/>]]></Description>
<Type>%Query</Type>
<FormalSpec>Category:%String="",IncludeBase:%Boolean=0</FormalSpec>
<Parameter name="CONTAINID" value="0"/>
<Parameter name="ROWSPEC" value="Type:%String"/>
</Query>

<Method name="EnumerateDocTypesExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary,Category:%String,IncludeBase:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(EnsLib.HL7.Schema).SegTypesExecute(.qHandle,.Category,0,.IncludeBase)
]]></Implementation>
</Method>

<Method name="EnumerateDocTypesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>EnumerateDocTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=##class(EnsLib.HL7.Schema).SegTypesFetch(.qHandle,.Row,.AtEnd)
	Set:""'=$G(Row) Row=$LB($LG(Row))
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnumerateDocTypesClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateDocTypesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(EnsLib.HL7.Schema).SegTypesClose(.qHandle)
]]></Implementation>
</Method>

<Query name="EnumerateTypeCategories">
<Description><![CDATA[
Returns a list of document type schema categories for the document class.<br>
The Standard parameter can be used to restrict the list.<br>
If Standard is:
 0 - return only standard categories
 + - return only user-defined categories
 empty - return all categories
 a partial category name - return only categories starting with the given category name part<br/>
 other - return nothing]]></Description>
<Type>%Query</Type>
<FormalSpec>Standard:%String=""</FormalSpec>
<Parameter name="CONTAINID" value="0"/>
<Parameter name="ROWSPEC" value="Category:%String,Description:%String,IsStandard:%Boolean,Base:%String"/>
</Query>

<Method name="EnumerateTypeCategoriesExecute">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary,Standard:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(EnsLib.HL7.Schema).TypeCategoriesExecute(.qHandle, Standard)
]]></Implementation>
</Method>

<Method name="EnumerateTypeCategoriesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>EnumerateTypeCategoriesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=##class(EnsLib.HL7.Schema).TypeCategoriesFetch(.qHandle,.Row,.AtEnd)
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnumerateTypeCategoriesClose">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>EnumerateTypeCategoriesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(EnsLib.HL7.Schema).TypeCategoriesClose(.qHandle)
]]></Implementation>
</Method>
</Class>


<Class name="EnsLib.HL7.Util.MsgBodyMethods">
<Abstract>1</Abstract>
<ClassType/>
<IncludeCode>EnsHL7,%systemInclude</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.Util.MessageBodyMethods</Super>
<System>4</System>
<TimeChanged>63920,75710</TimeChanged>
<TimeCreated>59318,79308.939</TimeCreated>

<Parameter name="DefaultHL7Ver">
<Default>2.3.1</Default>
</Parameter>

<Method name="%GetContentType">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit "text/html"
]]></Implementation>
</Method>

<Method name="%ShowContents">
<FormalSpec>pZenOutput:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	If pZenOutput {
		Do ..OutputHTMLZen()
	}
	Else {
		Do ..OutputHTML()
	}
]]></Implementation>
</Method>

<Method name="%ShowContentsHead">
<FormalSpec>pZenOutput:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	/* Styles for EDI segment display */

	If '$g(%donotoverwritestyles) {
		&html<<LINK REL="stylesheet" TYPE="text/css" HREF="csputils.css" TITLE="Standard Style" >>
	}

	&html<
<style>

/* EDI Document Table */
TABLE.EDIDocumentTable {
		border: black solid 1px; font-size: 0.8em;
		background: #DDDDFF;
		margin-left: 10px; margin-right: 10px;
		width: 10;
	}

TD.EDIDocumentTableExpandor {
		background: #D0D0FF;
		border-bottom: gray solid 1px;
		padding: 2px;
	}

TD.EDIDocumentTableSegnum {
		background: white;
		font-weight: bold;
		text-align: right;
		border-bottom: gray solid 1px;
		padding: 2px;
	}

TD.EDIDocumentTableSegid {
		background: white;
		border-bottom: gray solid 1px;
		border-right: gray solid 1px;
		padding: 2px;
	}

TD.EDIDocumentTableSegname {
		background: #D0D0FF;
		text-align: center;
		font-weight: bold;
		border-bottom: gray solid 1px;
		padding: 2px;
	}

/* -- Segment single-row Table */
TABLE.EDISegmentsTable {
		background: white;
		font-size: 0.9em;
		border-bottom: gray solid 1px;
	}

TD.EDISegmentsTableValue {
		background: white;
		padding: 2px;
	}

TD.EDISegmentsTableSeparator {
		background: white;
		padding: 2px;
	}

TD.EDISegmentsTableEmptyfield {
		background: white;
		padding: 2px;
	}
</style>
	>
]]></Implementation>
</Method>

<Method name="chooseDocType">
<FormalSpec>*pDocDesc</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tDocType=..DocType
	If ""'=tDocType && ##class(EnsLib.HL7.Schema).ElementExists("MS:"_tDocType) {
		Set pDocDesc="HL7 Message stored"
	} Else {
		Set tTypeName=..Name
		#; Try standard named version
		Set tVersionID=..TypeVersion
		Set tDocType=##class(EnsLib.HL7.Schema).ResolveSchemaTypeToDocType(tVersionID,tTypeName)
		If ##class(EnsLib.HL7.Schema).ElementExists("MS:"_tDocType) {
			Set pDocDesc="ResolveSchemaTypeToDocType( HL7 message MSH VersionID '"_tVersionID_"' & HL7 message type Name '"_tTypeName_"' )"
		} Else {
			#; Try default version
			Set tDocType=##class(EnsLib.HL7.Schema).ResolveSchemaTypeToDocType(..#DefaultHL7Ver,tTypeName)
			If ##class(EnsLib.HL7.Schema).ElementExists("MS:"_tDocType) {
				Set pDocDesc="ResolveSchemaTypeToDocType( default HL7 Version '"_..#DefaultHL7Ver_"' & HL7 message type Name '"_tTypeName_"' )"
			} Else {
				Set tDocType=""
			}
		}
	}
	Quit tDocType
]]></Implementation>
</Method>

<Method name="%DrawHTMLTable">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pObj:%RegisteredObject,&pID:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	&html<<div>>
	Do pObj.%ShowContentsHead()
	Do pObj.OutputHTML()
	&html<</div><br/>HL7 document object properties:>
	Quit ##class(%CSP.Util.AutoFormDynamic).DrawHTMLTable(pObj, .pID)
]]></Implementation>
</Method>

<Method name="%DrawHTMLForm">
<Description>
This method is called by the Management Portal to display a message-specific content editor</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pObj:%RegisteredObject,&pID:%String,pActionURL:%String="",&pButtons:%CSP.Util.FormButton,pTarget:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	&html<<br/>HL7 document content:<br/>
	<div><textarea name="%XCONT" rows="20" cols="100" style="border: 1px black solid;">>
	Do pObj.OutputToDevice(,pObj.Separators_$C(13,10))
	&html<</textarea></div></br>HL7 document object properties:>
	Set pID("XCONT")=""
	Quit ##class(%CSP.Util.AutoFormDynamic).DrawHTMLForm(pObj, .pID, pActionURL, .pButtons, pTarget)
]]></Implementation>
</Method>

<Method name="%ProcessSubmit">
<Description><![CDATA[
This method is called by the Management Portal to 
display a message-specific content editor.<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pRequest:%CSP.Request,&pID:%String="",*pErrorMsg:%String]]></FormalSpec>
<ReturnType>%RegisteredObject</ReturnType>
<Implementation><![CDATA[
	#; apply %request changes to old stored object or to new object if no old ID
	Set pErrorMsg=""
	Set tOldObj=##class(%CSP.Util.AutoFormDynamic).ProcessSubmit(pRequest, .pID, .pErrorMsg, 0)
	Quit:'$IsObject(tOldObj) $$$NULLOREF
	If ""'=tOldObj.%Id() {
		// It's a resend, not a testing request
		Kill %objlasterror
		Set tOldObj=tOldObj.%ConstructClone() ; clone it so as not to save changes to the original
		If '$IsObject(tOldObj) {
			Set tSC=$G(%objlasterror,$$$OK)
			Set pErrorMsg=pErrorMsg_" Failed to clone edited HL7 message object"
			Set:$$$ISERR(tSC) pErrorMsg=pErrorMsg_" - Status "_$$$StatusDisplayString(tSC)
			Quit $$$NULLOREF
		}
		Set tSource=tOldObj.Source_$C(13)_"; Edited copy of "_$G(pID(1))
		#; get rid of old content
		Do tOldObj.Clear()  Set tOldObj.Source=tSource
	}

	Set tData=$G(pRequest.Data("$IDXCONT",1))
	If $IsObject(tData) {
		Set tTempObj=..ImportFromLibraryStream(tData,.tSC)
	} Else {
		Set tTempObj=..ImportFromString(tData,.tSC)
	}
	If $$$ISERR(tSC)||'$IsObject(tTempObj) {
		If '$IsObject(tTempObj) {
			Set pErrorMsg=pErrorMsg_" Failed to import HL7 message text"
			Set:$$$ISERR(tSC) pErrorMsg=pErrorMsg_" - Status "_$$$StatusDisplayString(tSC)
			Quit $$$NULLOREF
		}
		Set pErrorMsg=pErrorMsg_$$$StatusDisplayString(tSC)
	}
	Set tOldObj.Separators=tTempObj.Separators
	Set tSC=tOldObj.CopyValues(tTempObj,"()","()","set","")
	If $$$ISERR(tSC) {
		Set pErrorMsg=pErrorMsg_"Failed to update HL7 message content - Status "_" "_$$$StatusDisplayString(tSC)
		Quit $$$NULLOREF
	}
	Set:$$$ISOK(tSC) tSC=tOldObj.%Save() ;  needed to prevent TempObj's segment data from dying with it.
	Quit tOldObj
]]></Implementation>
</Method>
</Class>


<Class name="EnsLib.SOAP.OutboundAdapter">
<Description>
Adapter that handles internal service requests by acting as a SOAP client to an external SOAP server.</Description>
<ClassType/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.OutboundAdapter</Super>
<System>4</System>
<TimeChanged>63920,75706</TimeChanged>
<TimeCreated>59081,38712</TimeCreated>

<Property name="WebServiceURL">
<Description><![CDATA[
Declares the live URL target location for the WebService to be invoked. If not given, the default location declared in the WebService Client class will be used. <p/>
Note that SSL will only work if the URL starts with the https:// protocol prefix.]]></Description>
<Type>%String</Type>
<InitialExpression><![CDATA["<default>"]]></InitialExpression>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="WebServiceClientClass">
<Description>
Names the Client Class that describes the WebService, generated by the SOAP Client Wizard add-in</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="SOAPCredentials">
<Description>
Names the Credentials entry containing the Username and Password values to be used for WSSecurityLogin basic authentication if needed to access the SOAP service</Description>
<Type>%String</Type>
</Property>

<Property name="Credentials">
<Description>
Names the Credentials entry containing the Username and Password values used to make the HTTP connection to the SOAP server</Description>
<Type>%String</Type>
</Property>

<Property name="SSLConfig">
<Description>
The name of an existing SSL/TLS system configuration set to use (Secure Socket Layer / Transport Layer Security, configured via the system portal's Security Management page)
Note that for this setting to take effect you must ensure that https:// is used in WebServiceURL or in the default location declared
in the WebService Client class</Description>
<Type>%String</Type>
</Property>

<Property name="SSLCheckServerIdentity">
<Description>
When making an SSL connection check the server identity in the certificate matches the name of the system we are connecting to.
This defaults to being on and matches based on the rules layed out in section 3.1 of RFC 2818.</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="ProxyServer">
<Description>
Proxy server through which to send HTTP requests, if any</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="ProxyPort">
<Description>
Proxy server port on which to send HTTP requests if using a proxy server</Description>
<Type>%Integer</Type>
<InitialExpression>80</InitialExpression>
</Property>

<Property name="ProxyHTTPS">
<Description>
Should the proxy (if any) use HTTPS to communicate with the real HTTP/HTTPS server?</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ProxyHttpTunnel">
<Description>
Should the Adapter use the HTTP CONNECT command to establish a tunnel through the proxy to the target HTTP server?</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ProxyHttpSSLConnect">
<Description>
Should the Adapter use a proxy SSL connection to the proxy (if any)?
Note: the use of SSL to the eventual endpoint is determined by the protocol part of web service's location url.</Description>
<Type>%Boolean</Type>
</Property>

<Property name="ConnectTimeout">
<Description>
Number of seconds to wait on each connection attempt</Description>
<Type>%Numeric</Type>
<InitialExpression>5</InitialExpression>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="ResponseTimeout">
<Description>
Timeout for getting a response from the remote SOAP server (the timeout for opening the connection to the server is always 5 seconds). Setting the timeout to -1 means wait forever.</Description>
<Type>%Numeric</Type>
<InitialExpression>30</InitialExpression>
<Parameter name="MINVAL" value="-1"/>
</Property>

<UDLText name="T">
<Content><![CDATA[
// Number of seconds to wait for each successive incoming TCP read following receipt of initial response data from remote SOAP server

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Property ReadTimeout As %Numeric(MAXVAL = 600, MINVAL = 0) [ InitialExpression = 5 ];

]]></Content>
</UDLText>

<Property name="HttpVersion">
<Description>
The HTTP version the Adapter should report in the HTTP request it sends to the server</Description>
<Type>%String</Type>
<InitialExpression>"1.1"</InitialExpression>
</Property>

<Parameter name="SETTINGS">
<Default>RegistryID:Basic:selector?context={Ens.ServiceRegistry.External.ContextSearch/Services?Protocols_1=SOAP},WebServiceURL:Basic,WebServiceClientClass:Basic,SOAPCredentials:Basic:credentialsSelector,Credentials:Basic:credentialsSelector,SSLConfig:Connection:sslConfigSelector,SSLCheckServerIdentity:Connection,ProxyServer:Proxy,ProxyPort:Proxy,ProxyHTTPS:Proxy,ProxyHttpTunnel:Proxy,ProxyHttpSSLConnect:Proxy,ConnectTimeout:Connection,ResponseTimeout:Connection</Default>
</Parameter>

<Property name="%Client">
<Description>
Private instance of the WebServiceClientClass</Description>
<Type>%SOAP.WebClient</Type>
</Property>

<Property name="%SOAPCredentialsObj">
<Description>
Contains the WSSecurityLogin values to be used if needed to access the SOAP service
(Parallels the %CredentialsObj property inherited from Ens.Adapter)</Description>
<Type>Ens.Config.Credentials</Type>
</Property>

<Method name="WebMethod">
<Description>
Returns a web method proxy descriptor instance that represents the named method of the SOAP service designated by the WebServiceClientClass setting.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pMethodName:%String</FormalSpec>
<ReturnType>%SOAP.ProxyDescriptor</ReturnType>
<Implementation><![CDATA[$S($IsObject(..%Client):..%Client.WebMethod(pMethodName),1:$$$NULLOREF)
]]></Implementation>
</Method>

<Method name="InvokeWithSOAPBody">
<Description>
Invoke a SOAP action by posting the whole body -- note that this will only work if the client class is %SOAP.WebRequest</Description>
<FormalSpec><![CDATA[pAction:%String,pOneWay:%Boolean=0,pRequest:%CharacterStream,&pResponse:%CharacterStream]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:'$IsObject(..%Client)||(""=..%Client.Location) $$$ERROR($$$EnsErrGeneral,"Cannot invoke action "_pAction_"; WebServiceClientClass '"_..WebServiceClientClass_"' could not be not instantiated, or the WebServiceURL Location could not be determined")
	Quit:'..%Client.%IsA("%SOAP.WebRequest") $$$ERROR($$$EnsErrGeneral,"Cannot invoke action "_pAction_" unless '"_..WebServiceClientClass_"' IsA %SOAP.WebRequest")
	If '$IsObject(..%SOAPCredentialsObj) Do ..SOAPCredentialsSet(..SOAPCredentials) Quit:'$IsObject(..%SOAPCredentialsObj) $$$ERROR($$$EnsErrNoCredentials,..SOAPCredentials)
	Do:(""'=..%SOAPCredentialsObj.Username)&&(""=..%Client.SessionCookie) ..%Client.WSSecurityLogin(..%SOAPCredentialsObj.Username,..%SOAPCredentialsObj.Password)
	Set ..%Client.SSLConfiguration=..SSLConfig
	Set ..%Client.SSLCheckServerIdentity=..SSLCheckServerIdentity
	If ""'=..SSLConfig&&("https://"'=$ZCVT($E(..%Client.Location,1,$L("https://")),"L")) $$$LOGWARNING("SSLConfig '"_..SSLConfig_"' not in effect because https is not used in location '"_..%Client.Location_"'")
	Kill %objlasterror  Set $ZT="SOAPTrap"
	
	// Delegate to %SOAP.WebRequest
	Quit ..%Client.SendSOAPBody(pAction,pOneWay,pRequest,.pResponse)

SOAPTrap
	#dim tSC As %Status
	#dim tZE As %String
	Set $ZT=""
	If ""'=$Get(%objlasterror) { Set tSC=%objlasterror }
	Else { Set tZE=$ZE,tSC=$$$ERROR($$$GeneralError,$g(tZE)) }

	Set:$$$ISERR(tSC)&&..isRetryable(tSC) ..BusinessHost.Retry = 1
	Quit tSC
]]></Implementation>
</Method>

<Method name="InvokeMethod">
<Description>
Invoke a web method defined in the designated WebServiceClientClass on the SOAP server designated by the WebServiceURL setting</Description>
<FormalSpec>pMethodName:%String,*pResult:%RegisteredObject,pArgs...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pResult  Set pResult=$$$NULLOREF
	Quit:'$IsObject(..%Client)||(""=..%Client.Location) $$$ERROR($$$EnsErrGeneral,"Cannot invoke method "_pMethodName_"; WebServiceClientClass '"_..WebServiceClientClass_"' could not be instantiated, or the WebServiceURL Location could not be determined")
	If '$IsObject(..%SOAPCredentialsObj) Do ..SOAPCredentialsSet(..SOAPCredentials) Quit:'$IsObject(..%SOAPCredentialsObj) $$$ERROR($$$EnsErrNoCredentials,..SOAPCredentials)
	Do:(""'=..%SOAPCredentialsObj.Username)&&(""=..%Client.SessionCookie) ..%Client.WSSecurityLogin(..%SOAPCredentialsObj.Username,..%SOAPCredentialsObj.Password)
	Set ..%Client.SSLConfiguration=..SSLConfig
	Set ..%Client.SSLCheckServerIdentity=..SSLCheckServerIdentity
	If ""'=..SSLConfig&&("https://"'=$ZCVT($E(..%Client.Location,1,$L("https://")),"L")) $$$LOGWARNING("SSLConfig '"_..SSLConfig_"' not in effect because https is not used in location '"_..%Client.Location_"'")
	Kill %objlasterror  Set $ZT="SOAPTrap"
	// Up to 252 args...  (254 signature limit less 2 for method invocation - oref, method).
	If ""=$$$GetClassParameter($classname(..%Client)_"."_pMethodName,"XMLRESULTNAME") {
		Do $method(..%Client,pMethodName,pArgs...)
		$$$sysTRACE("After invoke of method "_pMethodName_" with "_$G(pArgs,0)_" args and no retval")
	} Else {
		Set pResult = $method(..%Client,pMethodName,pArgs...)
		$$$sysTRACE("Got Result "_pResult_" from invoke of method "_pMethodName_" with "_$G(pArgs,0)_" args")
	}
	Quit $$$OK ; Success! any errors are reported through the SOAPTrap
SOAPTrap
	Set $ZT=""
	If ""'=$Get(%objlasterror) { Set tSC=%objlasterror }
	Else { Set tZE=$ZE,tSC=$$$ERROR($$$GeneralError,$g(tZE)) }

	Set:$$$ISERR(tSC)&&..isRetryable(tSC) ..BusinessHost.Retry = 1
	Quit tSC
]]></Implementation>
</Method>

<Method name="Invoke">
<Description>
Invoke a web method defined in the designated WebServiceClientClass on the SOAP server designated by the WebServiceURL setting.
The pWebMethod argument is a SOAP client ProxyDescriptor object that you may obtain by calling ..Adapter.WebMethod(pMethodName).
You may then set all the input argument properties of the object before calling this method and obtain the result from the object's %Result property.
Using this method instead of InvokeMethod() saves the overhead of several layers of function calls.
Note that nearly equivalent functionality is obtainable using the InvokeMethod() method by adding Parameter ARGUMENTSTYLE="message" to the class definition of the SOAP client class designated in the WebServiceClientClass setting.
The SOAP Client Wizard will add this parameter to the client class it constructs if you check the box labeled "Use unwrapped message format for document style WebMethods".</Description>
<FormalSpec>pWebMethod:%SOAP.ProxyDescriptor</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$ASSERT($$$IsdefObject(pWebMethod) && ($classname(pWebMethod)[..WebServiceClientClass_"."))
	Quit:'$IsObject(..%Client)||(""=..%Client.Location) $$$ERROR($$$EnsErrGeneral,"Cannot invoke "_$classname(pWebMethod)_"(); WebServiceClientClass '"_..WebServiceClientClass_"' could not be not instantiated, or the WebServiceURL Location could not be determined")
	$$$sysTRACE($classname(pWebMethod)_"()")

	If '$IsObject(..%SOAPCredentialsObj) Do ..SOAPCredentialsSet(..SOAPCredentials) Quit:'$IsObject(..%SOAPCredentialsObj) $$$ERROR($$$EnsErrNoCredentials,..SOAPCredentials)
	Do:(""'=..%SOAPCredentialsObj.Username)&&(""=..%Client.SessionCookie) ..%Client.WSSecurityLogin(..%SOAPCredentialsObj.Username,..%SOAPCredentialsObj.Password)
	Set ..%Client.SSLConfiguration=..SSLConfig
	Set ..%Client.SSLCheckServerIdentity=..SSLCheckServerIdentity
	If ""'=..SSLConfig&&("https://"'=$ZCVT($E(..%Client.Location,1,$L("https://")),"L")) $$$LOGWARNING("SSLConfig '"_..SSLConfig_"' not in effect because https is not used in location '"_..%Client.Location_"'")
	Kill %objlasterror  Set $ZT="SOAPTrap"

	Set tOneWay = pWebMethod.%GetParameter("SOAPONEWAY")
	Do ..%Client.InvokeClient(pWebMethod,pWebMethod.%RequestName,..getAction(pWebMethod,..WebServiceClientClass),tOneWay)
	$$$sysTRACE("Got Result "_$S(tOneWay:"",1:pWebMethod.%Result))
	Quit $$$OK	; Success! any errors are reported through the SOAPTrap
SOAPTrap
	Set $ZT=""
	If ""'=$Get(%objlasterror) { Set tSC=%objlasterror }
	Else { Set tZE=$ZE,tSC=$$$ERROR($$$GeneralError,$g(tZE)) }

	Set:$$$ISERR(tSC)&&..isRetryable(tSC) ..BusinessHost.Retry = 1
	Quit tSC
]]></Implementation>
</Method>

<Method name="isRetryable">
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<FormalSpec>pSC:%Status</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$$$StatusEquals(pSC,$$$HttpRequestConnect,$$$SOAPUnexpectedStatus,$$$CSPTimeout)
]]></Implementation>
</Method>

<Method name="getAction">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pWebMethod:%SOAP.ProxyDescriptor,pClientClassname:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tAction = pWebMethod.%GetParameter("ACTION")
	If ""=tAction {
		#; If the proxy parameter is missing, get it from the Client class
		Set method = pWebMethod.%ClassName()
		
		#; Find the Operation argument to the WebMethod call and the Action argument to the Invoke() call
		Set tAction="" For i=1:1:$$$defMemberKeyGet(pClientClassname,$$$cCLASSmethod,method,$$$cMETHimplementation) {
			Set line=$$$defMemberArrayGet(pClientClassname,$$$cCLASSmethod,method,$$$cMETHimplementation,i)
			Set line=$TR(line," "_$C(9))
			Set tAction=$P($P(line,""").Invoke($this,""",2),""",")
			#;Set pOperation=$P($P(line,"..WebMethod(""",2),""")")
			Quit:""'=tAction
		}
	}
	Quit tAction
]]></Implementation>
</Method>

<Method name="SOAPCredentialsSet">
<Description>
This method parallels the inherited CredentialsSet method used here for HTTP credentials.</Description>
<Internal>1</Internal>
<FormalSpec>pInVal:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; (Re)Set the Credentials object; do it always because we never know if the source row fields might have been updated
	#; make sure to instantiate even if re-setting to the InitialExpression string
	Set ..%SOAPCredentialsObj=$$$NULLOREF

	Set tClassname=$zobjmethod($this,"%ClassName",1) ; call subclass
	Set tClass = $$$comMemberKeyGet(tClassname,$$$cCLASSproperty,"%SOAPCredentialsObj",$$$cPROPtype)
	If ""'=tClass {
		Set tSC=##Class(Ens.Config.Credentials).GetCredentialsObj(.tObj,tClassname,tClass,pInVal)
		Set:$$$ISOK(tSC) ..%SOAPCredentialsObj=tObj
		If $$$ISOK(tSC) { Set ..%SOAPCredentialsObj=tObj }
		ElseIf '$$$StatusEquals(tSC,$$$EnsErrNoCallerCredentials) {
			$$$LOGSTATUS(tSC)
		}
	}
	Set i%SOAPCredentials=pInVal
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="CredentialsSet">
<Internal>1</Internal>
<FormalSpec>pInVal:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=##super(pInVal) Quit:$$$ISERR(tSC) tSC
	Set:$IsObject(..%Client)&&$IsObject(..%CredentialsObj) ..%Client.HttpUsername=..%CredentialsObj.Username, ..%Client.HttpPassword=..%CredentialsObj.Password
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SSLConfigSet">
<Internal>1</Internal>
<FormalSpec>pInVal:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%SSLConfig=pInVal
	Set:$IsObject(..%Client) ..%Client.SSLConfiguration=pInVal
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ProxyServerSet">
<Internal>1</Internal>
<FormalSpec>pInVal:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%ProxyServer=pInVal
	Set:$IsObject(..%Client) ..%Client.HttpProxyServer=pInVal
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ProxyPortSet">
<Internal>1</Internal>
<FormalSpec>pInVal:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%ProxyPort=pInVal
	Set:$IsObject(..%Client) ..%Client.HttpProxyPort=pInVal
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ProxyHTTPSSet">
<Internal>1</Internal>
<FormalSpec>pInVal:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%ProxyHTTPS=pInVal
	Set:$IsObject(..%Client) ..%Client.HttpProxyHTTPS=pInVal
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ConnectTimeoutSet">
<Internal>1</Internal>
<FormalSpec>pInVal:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%ConnectTimeout=pInVal
	Set:$IsObject(..%Client) ..%Client.OpenTimeout=$S(pInVal=-1:2123456789,1:pInVal)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ResponseTimeoutSet">
<Internal>1</Internal>
<FormalSpec>pInVal:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%ResponseTimeout=pInVal
	Set:$IsObject(..%Client) ..%Client.Timeout=$S(pInVal=-1:2123456789,1:pInVal)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ProxyHttpTunnelSet">
<Internal>1</Internal>
<FormalSpec>pInVal:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%ProxyHttpTunnel=pInVal
	Set:$IsObject(..%Client) ..%Client.HttpProxyTunnel=pInVal
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ProxyHttpSSLConnectSet">
<Internal>1</Internal>
<FormalSpec>pInVal:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%ProxyHttpSSLConnect=pInVal
	Set:$IsObject(..%Client) ..%Client.HttpProxySSLConnect=pInVal
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="HttpVersionSet">
<Internal>1</Internal>
<FormalSpec>pInVal:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%HttpVersion=pInVal
	Set:$IsObject(..%Client) ..%Client.HTTPVersion=pInVal
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="WebServiceURLSet">
<Internal>1</Internal>
<FormalSpec>pInVal:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%WebServiceURL=pInVal
	Set:$IsObject(..%Client) ..%Client.Location=$S($Case($ZCVT(pInVal,"L"),"":0, "<default>":0, "default":0,:1):pInVal, 1:$$$GetClassParameter(..WebServiceClientClass,"LOCATION"))
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="WebServiceClientClassSet">
<Internal>1</Internal>
<FormalSpec>pInVal:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%WebServiceClientClass=pInVal
	If ""=pInVal Set ..%Client=$$$NULLOREF  Quit $$$OK
	Kill %objlasterror  Set $ZT="NewTrap"
	Set ..%Client=$zobjclassmethod(pInVal,"%New")
	Set $ZT=""
AfterNew
	If $IsObject(..%Client) {
		If ..%Client.%Extends("%SOAP.WebClient") {
			Set ..%Client.Location=$S($Case($ZCVT(..WebServiceURL,"L"),"":0, "<default>":0, "default":0,:1):..WebServiceURL, 1:$$$GetClassParameter(pInVal,"LOCATION"))
			Set:$IsObject(..%CredentialsObj) ..%Client.HttpUsername=..%CredentialsObj.Username, ..%Client.HttpPassword=..%CredentialsObj.Password
			Set ..%Client.HttpProxyServer=..ProxyServer, ..%Client.HttpProxyPort=..ProxyPort, ..%Client.HttpProxyHTTPS=..ProxyHTTPS, ..%Client.OpenTimeout=$S(..ConnectTimeout=-1:2123456789,1:..ConnectTimeout), ..%Client.Timeout=$S(..ResponseTimeout=-1:2123456789,1:..ResponseTimeout), ..%Client.HttpProxyTunnel=..ProxyHttpTunnel, ..%Client.HttpProxySSLConnect=..ProxyHttpSSLConnect, ..%Client.HTTPVersion=..HttpVersion
		} Else {
			$$$LOGERROR("WebService Client class "_pInVal_" must be a SOAP client proxy class derived from %SOAP.WebClient")
			Set ..%Client=$$$NULLOREF
		}
	} Else {
		$$$LOGERROR("Failed to instantiate WebClient class "_pInVal_" : "_$$$StatusDisplayString(%objlasterror))
	}
	Quit $$$OK
NewTrap
	Set $ZT=""
	Set ..%Client=$$$NULLOREF
	If ""=$Get(%objlasterror) Set tZE=$ZE,%objlasterror=$$$ERROR($$$GeneralError,$g(tZE))
	GoTo AfterNew
]]></Implementation>
</Method>

<Method name="GetAddress">
<Description>
Return a human-readable target address for use in Trace messages</Description>
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..%Client.Location_$S(""=..ProxyServer:"",1:" via "_..ProxyServer_":"_..ProxyPort)
]]></Implementation>
</Method>
</Class>


<Class name="EnsLib.SQL.OutboundAdapter">
<Description>
SQL database client adapter. Executes queries against a remote database via an ODBC- or JDBC- defined DSN (Data Source Name) and retrieves resultsets and/or Stored Procedure return values and output parameters..</Description>
<ClassType/>
<IncludeCode>Ensemble</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.OutboundAdapter,EnsLib.SQL.Common</Super>
<System>4</System>
<TimeChanged>63920,75706</TimeChanged>
<TimeCreated>59081,38712</TimeCreated>
<Inheritance>right</Inheritance>

<Method name="OnInit">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; Create an instance of the SQLGateway object
	Set tSC=##super() Quit:$$$ISERR(tSC) tSC
	Set tSC=..init()  Quit:$$$ISERR(tSC) tSC
	Set:..StayConnected>0 ..KeepaliveInterval=..StayConnected
	If ..StayConnected<0 { Set tSC=..Connect(..ConnectTimeout)  If $$$ISERR(tSC) $$$LOGWARNING($$$StatusDisplayString(tSC)) } // timeout is not fatal at this point, but do log it
	Else { $$$SetJobMonitor(..BusinessHost.%ConfigName,$$$SystemName_":"_$Job,$$$eMonitorConnected,"0|"_$$$timeUTC) }
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="EnsLib.SQL.Snapshot">
<Description>
This class is a specialized result set used with the EnsLib.SQL.OutboundAdapter
Instances are returned as output from EnsLib.SQL.OutboundAdapter.ExecuteQuery().
The list of rows is a static snapshot as of the time when the query was executed</Description>
<ClassType>persistent</ClassType>
<IncludeCode>Ensemble,%xmlDOM</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%Persistent,%IResultSet,%XML.Adaptor</Super>
<System>4</System>
<TimeChanged>63920,75706</TimeChanged>
<TimeCreated>59341,12424.349712</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="FirstRow">
<Description>
The index of the first row in this Snapshot. May be set on input when calling OutboundAdapter.ExecuteQuery() or ResultSet.GetSnapshot() to cause the first n-1 rows to be discarded before populating the Snapshot.</Description>
<Type>%Integer</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="MaxRowsToGet">
<Description>
The maximum number of rows to populate this Snapshot with. May be set on input to OutboundAdapter.ExecuteQuery() or ResultSet.GetSnapshot().
Set to -1 to get all rows no matter how many.</Description>
<Type>%Integer</Type>
<InitialExpression>250</InitialExpression>
</Property>

<Property name="%GblRef">
<Description>
Location of the storage for the fields of this Snapshot.</Description>
<Type>%String</Type>
<InitialExpression>$Name($$$EnsJobLocal($this))</InitialExpression>
<Parameter name="MAXLEN" value="80"/>
</Property>

<Property name="ColCount">
<Description>
This holds the column count for this snapshot</Description>
<Type>%Integer</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="RowCount">
<Description>
This holds the row count</Description>
<Type>%Integer</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="AtEnd">
<Description>
Are we at the last row?</Description>
<Type>%Boolean</Type>
<Calculated>1</Calculated>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="%CurrentRow">
<Description>
This is the index of the 'current' row in the Snapshot. Used by the Next(), Get(), GetData(), and Rewind() methods.</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Transient>1</Transient>
</Property>

<UDLText name="T">
<Content><![CDATA[/* convert unused %AbstractResultSet properties to Transient */
]]></Content>
</UDLText>

<Property name="%Message">
<Type>%Library.String</Type>
<Transient>1</Transient>
</Property>

<Property name="%Objects">
<Type>%Library.String</Type>
<Internal>1</Internal>
<Transient>1</Transient>
<Parameter name="MAXLEN"/>
</Property>

<Property name="%Parameters">
<Type>%Library.String</Type>
<Internal>1</Internal>
<Transient>1</Transient>
<Parameter name="MAXLEN"/>
</Property>

<Property name="%rsmd">
<Type>%ResultSet.MetaData</Type>
<Internal>1</Internal>
<Private>1</Private>
<Transient>1</Transient>
</Property>

<Property name="%NextColumn">
<Type>%CacheString</Type>
<Private>1</Private>
<Transient>1</Transient>
</Property>

<Property name="%ROWCOUNT">
<Type>%Library.Integer</Type>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="%ROWID">
<Type>%String</Type>
<Transient>1</Transient>
<Parameter name="MAXLEN"/>
</Property>

<Property name="%RuntimeMode">
<Type>%Library.String</Type>
<Private>1</Private>
<Transient>1</Transient>
</Property>

<Property name="%SQLCODE">
<Type>%Library.Integer</Type>
<Transient>1</Transient>
</Property>

<Property name="%PrivateTables">
<Type>%XSQL.DS.TempTable</Type>
<Collection>array</Collection>
<Transient>1</Transient>
</Property>

<Property name="%ResultColumnCount">
<Type>%Library.Integer</Type>
<Transient>1</Transient>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="RuntimeMode">
<Type>%String</Type>
<Transient>1</Transient>
</Property>

<Method name="Clean">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$ASSERT(""=..%Id())

	#; first kill raw stream storage
	Set nRows=$G(@..%GblRef,0), nCols=$G(@..%GblRef@("ColIDs"),0) For r=1:1:nRows { For c=1:1:nCols {
		Kill:'$G(@..%GblRef@(r,c,"got"))&&$D(@..%GblRef@(r,c,"ref"),ref) @ref
	}}
	k @..%GblRef
	Set ..%CurrentRow=0
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Rewind">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..%CurrentRow = 0
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="RowCountGet">
<CodeMode>expression</CodeMode>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[$S(""=..%GblRef:0,1:$G(@..%GblRef,0))
]]></Implementation>
</Method>

<Method name="%ROWCOUNTGet">
<CodeMode>expression</CodeMode>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[..RowCountGet()
]]></Implementation>
</Method>

<Method name="ColCountGet">
<CodeMode>expression</CodeMode>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[$S(""=..%GblRef:0,1:$G(@..%GblRef@("ColIDs"),0))
]]></Implementation>
</Method>

<Method name="GetColumnCount">
<Description>
Returns the number of columns in the result set</Description>
<CodeMode>expression</CodeMode>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[..ColCountGet()
]]></Implementation>
</Method>

<Method name="AtEndGet">
<CodeMode>expression</CodeMode>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[..%CurrentRow>..RowCount
]]></Implementation>
</Method>

<Method name="Next">
<Description>
Advance the result set cursor to the next row. Returns 0 if the cursor is at the end of the result set.</Description>
<FormalSpec><![CDATA[&pSC:%Status]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set pSC=$$$OK
	Set ..%CurrentRow=..%CurrentRow+1
	Quit:..%CurrentRow'>..RowCount ..%CurrentRow
	Set ..%CurrentRow=..RowCount+1
	Quit 0
]]></Implementation>
</Method>

<Method name="%Next">
<CodeMode>call</CodeMode>
<FormalSpec><![CDATA[&pSC:%Status]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[..Next(.pSC)
]]></Implementation>
</Method>

<Method name="GetColumnName">
<Description>
Returns the name of column 'pColumn' in the result set.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColumn:%Integer=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$S(""=..%GblRef:"",1:$G(@..%GblRef@("ColNames",pColumn)))
]]></Implementation>
</Method>

<Method name="SetColNames">
<FormalSpec>pColName...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:0'=..RowCount $$$ERROR($$$GeneralError,"Snapshot must have no rows when columns are set")
	Set (@..%GblRef@("ColNames"),@..%GblRef@("ColIDs"))=pColName
	For tI=1:1:pColName {
		Set @..%GblRef@("ColNames",tI)=pColName(tI)
		Set @..%GblRef@("ColIDs",$ZCVT(pColName(tI),"L"))=tI
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetColumnID">
<CodeMode>expression</CodeMode>
<FormalSpec>pColName:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[$S(""=..%GblRef:0,1:$G(@..%GblRef@("ColIDs",$ZCVT(pColName,"L")),0))
]]></Implementation>
</Method>

<Method name="GetColumnType">
<Description>
Returns the type name of column 'pColumn' in the result set.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColumn:%Integer=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$S(""=..%GblRef:"",1:$G(@..%GblRef@("ColTypes",pColumn)))
]]></Implementation>
</Method>

<Method name="SetColTypes">
<FormalSpec>pColType...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:0'=..RowCount $$$ERROR($$$GeneralError,"Snapshot must have no rows when columns are set")
	Merge @..%GblRef@("ColTypes")=pColType
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetColumnSQLType">
<Description>
Returns the SQLtype integer of column 'pColumn' in the result set.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColumn:%Integer=0</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[$S(""=..%GblRef:"",1:$G(@..%GblRef@("ColTypes",pColumn,"int")))
]]></Implementation>
</Method>

<Method name="GetColumnIsLOB">
<Description>
Returns whether column 'pColumn' is a LOB (Stream) column.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColumn:%Integer=0</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$S(""=..%GblRef:"",1:$G(@..%GblRef@("ColTypes",pColumn,"LOB"),0))
]]></Implementation>
</Method>

<Method name="GetColumnIsBinary">
<Description>
Returns whether column 'pColumn' contains binary data.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColumn:%Integer=0</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[$S(""=..%GblRef:"",1:$G(@..%GblRef@("ColTypes",pColumn,"bin"),0))
]]></Implementation>
</Method>

<Method name="GetColumnSize">
<Description>
Returns the size of column 'pColumn' in the result set.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColumn:%Integer=0</FormalSpec>
<Implementation><![CDATA[$S(""=..%GblRef:"",1:$G(@..%GblRef@("ColSizes",pColumn)))
]]></Implementation>
</Method>

<Method name="SetColSizes">
<FormalSpec>pColSize...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:0'=..RowCount $$$ERROR($$$GeneralError,"Snapshot must have no rows when columns are set")
	Merge @..%GblRef@("ColSizes")=pColSize
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetColumnScale">
<Description>
Returns the scale of column 'pColumn' in the result set.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColumn:%Integer=0</FormalSpec>
<Implementation><![CDATA[$S(""=..%GblRef:"",1:$G(@..%GblRef@("ColScales",pColumn),0))
]]></Implementation>
</Method>

<Method name="SetColScales">
<FormalSpec>pColScale...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:0'=..RowCount $$$ERROR($$$GeneralError,"Snapshot must have no rows when columns are set")
	Merge @..%GblRef@("ColScales")=pColScale
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetColumnisNullable">
<Description>
Returns the isNullable of column 'pColumn' in the result set.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColumn:%Integer=0</FormalSpec>
<Implementation><![CDATA[$S(""=..%GblRef:"",1:$G(@..%GblRef@("ColisNuls",pColumn),1))
]]></Implementation>
</Method>

<Method name="SetColisNullable">
<FormalSpec>pColisNul...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:0'=..RowCount $$$ERROR($$$GeneralError,"Snapshot must have no rows when columns are set")
	Merge @..%GblRef@("ColisNuls")=pColisNul
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetColumnLabelName">
<Description>
Returns the LabelName of column 'pColumn' in the result set.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColumn:%Integer=0</FormalSpec>
<Implementation><![CDATA[$S(""=..%GblRef:"",1:$G(@..%GblRef@("Collabels",pColumn),..GetColumnName(pColumn)))
]]></Implementation>
</Method>

<Method name="SetColLabelName">
<FormalSpec>pCollabel...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:0'=..RowCount $$$ERROR($$$GeneralError,"Snapshot must have no rows when columns are set")
	Merge @..%GblRef@("Collabels")=pCollabel
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetColumnTableName">
<Description>
Returns the Table of column 'pColumn' in the result set.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColumn:%Integer=0</FormalSpec>
<Implementation><![CDATA[$S(""=..%GblRef:"",1:$G(@..%GblRef@("Coltables",pColumn)))
]]></Implementation>
</Method>

<Method name="SetColTableName">
<FormalSpec>pColtable...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:0'=..RowCount $$$ERROR($$$GeneralError,"Snapshot must have no rows when columns are set")
	Merge @..%GblRef@("Coltables")=pColtable
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetColumnSchemaName">
<Description>
Returns the Schema name of column 'pColumn' in the result set.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColumn:%Integer=0</FormalSpec>
<Implementation><![CDATA[$S(""=..%GblRef:"",1:$G(@..%GblRef@("Colschemas",pColumn)))
]]></Implementation>
</Method>

<Method name="SetColSchemaName">
<FormalSpec>pColschema...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:0'=..RowCount $$$ERROR($$$GeneralError,"Snapshot must have no rows when columns are set")
	Merge @..%GblRef@("Colschemas")=pColschema
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetColumnQualifier">
<Description>
Returns the Qualifier of column 'pColumn' in the result set.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColumn:%Integer=0</FormalSpec>
<Implementation><![CDATA[$S(""=..%GblRef:"",1:$G(@..%GblRef@("Colqualifiers",pColumn)))
]]></Implementation>
</Method>

<Method name="SetColQualifier">
<FormalSpec>pColqualifier...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:0'=..RowCount $$$ERROR($$$GeneralError,"Snapshot must have no rows when columns are set")
	Merge @..%GblRef@("Colqualifiers")=pColqualifier
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetColumnOptions">
<Description>
Returns the Options of column 'pColumn' in the result set.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColumn:%Integer=0</FormalSpec>
<Implementation><![CDATA[$S(""=..%GblRef:"",1:$G(@..%GblRef@("Coloptions",pColumn),$C(0,1,0,1,0,0,0,0,0,0,0,0)))
]]></Implementation>
</Method>

<Method name="SetColOptions">
<FormalSpec>pColoptions...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:0'=..RowCount $$$ERROR($$$GeneralError,"Snapshot must have no rows when columns are set")
	Merge @..%GblRef@("Coloptions")=pColoptions
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Get">
<Description>
Returns the value of the column with the name 'pColName' in the current row of the result set
Note: if the data exceeds the maximum string length then the return value will be the first 50 characters plus "..." and you should call GetStream() to get the full value.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColName:%String,pRow:%Integer=..%CurrentRow</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$G(@..%GblRef@(pRow,$G(@..%GblRef@("ColIDs",$ZCVT(pColName,"L")),0)))
]]></Implementation>
</Method>

<Method name="%Get">
<Description>
alias for Get in new result set interface</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColName:%String,pRow:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..Get(.pColName,.pRow)
]]></Implementation>
</Method>

<Method name="HasStream">
<Description>
Returns true if the named column in the current row contains stream data. In this case the complete value for the field can only be retrieved using the
GetStream() or GetDataStream() method. Otherwise the field contains simple string data that can be retrieved completely using the Get() or GetData() method.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColName:%String,pRow:%Integer=..%CurrentRow</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[..HasDataStream($G(@..%GblRef@("ColIDs",$ZCVT(pColName,"L")),0),.pRow)
]]></Implementation>
</Method>

<Method name="GetStream">
<Description><![CDATA[
Returns as a Stream the full value of the column with the name 'pColName' in the current row of the result set.
If you pass a stream object in <var>pStream</var>, the data will be appended to that stream;
otherwise the data will be returned in a new %Stream.GlobalCharacter stream object.
Note that if this method creates a Stream object for you, the Stream data is already on disk
and you are responsible for calling stream.%Delete(stream.%Oid()) to delete the persistent storage for the new stream object]]></Description>
<CodeMode>expression</CodeMode>
<FormalSpec><![CDATA[pColName:%String,&pStream:%Stream.Object=$$$NULLOREF,pRow:%Integer=..%CurrentRow]]></FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[..GetDataStream($G(@..%GblRef@("ColIDs",$ZCVT(pColName,"L")),0),.pStream,.pRow)
]]></Implementation>
</Method>

<Method name="GetDataByName">
<Description><![CDATA[
Deprecated - use <method>Get</method> method]]></Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..Get(.pColName)
]]></Implementation>
</Method>

<Method name="GetData">
<Description><![CDATA[
Returns the value of column <var>pColumn</var> in the current row of the result set.
Note: if the data exceeds the maximum string length then the return value will be the first 50 characters plus "..." and you should call GetDataStream() to get the full value.<p/>]]></Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColumn:%Integer,pRow:%Integer=..%CurrentRow</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$G(@..%GblRef@(pRow,pColumn))
]]></Implementation>
</Method>

<Method name="%GetData">
<Description>
alias for GetData in new result set interface</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColumn:%Integer,pRow:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..GetData(.pColumn,.pRow)
]]></Implementation>
</Method>

<Method name="HasDataStream">
<Description>
Returns true if the given field in the current row contains stream data. In this case the complete value for the field can only be retrieved using the
GetStream() or GetDataStream() method. Otherwise the field contains simple string data that can be retrieved completely using the Get() or GetData() method.</Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pColumn:%Integer,pRow:%Integer=..%CurrentRow</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[""'=$G(@..%GblRef@(pRow,pColumn,"ref"))
]]></Implementation>
</Method>

<Method name="GetDataStream">
<Description><![CDATA[
Returns as a Stream the full value of column <var>pColumn</var> in the current row of the result set.
If you pass a stream object in <var>pStream</var>, the data will be appended to that stream;
otherwise the data will be returned in a new %Stream.GlobalCharacter stream object.
Note that if this method creates a Stream object for you, the Stream data is already on disk
and you are responsible for calling stream.%Delete(stream.%Oid()) to delete the persistent storage for the new stream object]]></Description>
<FormalSpec><![CDATA[pColumn:%Integer,&pStream:%Stream.Object=$$$NULLOREF,pRow:%Integer=..%CurrentRow]]></FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
	Set tRef=$G(@..%GblRef@(pRow,pColumn,"ref"))
	If ""'=tRef {
		Set tSID=$P(tRef,"(",2), tSID=$E(tSID,1,*-1)
		Set tGCS=##class(%Stream.GlobalCharacter).%OpenId(tSID)
		Set tGCS=$S($G(@..%GblRef@("ColTypes",pColumn,"bin")):##class(%Stream.GlobalBinary).%OpenId(tSID), 1:##class(%Stream.GlobalCharacter).%OpenId(tSID))
		If $IsObject(pStream) { Do pStream.CopyFrom(tGCS), pStream.Rewind() }
		Else { Set pStream=tGCS  Set @..%GblRef@(pRow,pColumn,"got")=1 }
	} Else {
		Set:'$IsObject(pStream) pStream=$S($G(@..%GblRef@("ColTypes",pColumn,"bin")):##class(%Stream.GlobalBinary).%New(), 1:##class(%Stream.GlobalCharacter).%New())
		Do pStream.Write($Get(@..%GblRef@(pRow,pColumn))), pStream.Rewind()
	}
	Quit pStream
]]></Implementation>
</Method>

<Method name="GetRowList">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tList=""  For tI=1:1:..ColCount {
		Set tList=tList_$LB(..GetData(tI))
	}
	Quit tList
]]></Implementation>
</Method>

<Method name="%OnOpen">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Do ..GenerateIResultSetMetadata()
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnClose">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; kill runtime appdata Table storage if not %Save'd
	If ""=..%Id() {
	    #; first kill raw stream storage
	    Set nRows=$G(@..%GblRef,0), nCols=$G(@..%GblRef@("ColIDs"),0) For r=1:1:nRows { For c=1:1:nCols {
		    Kill:'$G(@..%GblRef@(r,c,"got"))&&$D(@..%GblRef@(r,c,"ref"),ref) @ref
	    }}
		Kill @..%GblRef
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnDelete">
<ClassMethod>1</ClassMethod>
<FormalSpec>oid:%ObjectIdentity</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; first kill raw stream storage
	New %tID,%tGblRef  Set %tID=$$$oidPrimary(oid), %tGblRef=""
	&sql(Select %GblRef Into :%tGblRef From EnsLib_SQL.Snapshot Where ID=:%tID)
	If ""'=%tGblRef && 'SQLCODE {
		Set nRows=$G(@%tGblRef,0), nCols=$G(@%tGblRef@("ColIDs"),0) For r=1:1:nRows { For c=1:1:nCols {
			Kill:'$G(@%tGblRef@(r,c,"got"))&&$D(@%tGblRef@(r,c,"ref"),ref) @ref
		}}
	}
	#; kill appdata Table storage
	Kill @%tGblRef
	Quit $$$OK
]]></Implementation>
</Method>

<Trigger name="OnDelete">
<Code><![CDATA[	#; first kill raw stream storage
	New %tID,%tGblRef  Set %tID={%%ID}, %tGblRef=""
	&sql(Select %GblRef Into :%tGblRef From EnsLib_SQL.Snapshot Where ID=:%tID)
	If ""'=%tGblRef && 'SQLCODE {
		Set nRows=$G(@%tGblRef,0), nCols=$G(@%tGblRef@("ColIDs"),0) For r=1:1:nRows { For c=1:1:nCols {
			Kill:'$G(@%tGblRef@(r,c,"got"))&&$D(@%tGblRef@(r,c,"ref"),ref) @ref
		}}
	}
	#; kill appdata Table storage
	Kill @%tGblRef
	Quit]]></Code>
<Event>DELETE</Event>
</Trigger>

<Method name="%OnAfterSave">
<FormalSpec>insert:%Boolean</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tId = ..%Id()
	If ""'=tId && (..%GblRef'=$Name($$$EnsStaticAppData($$$CurrentClass,tId))) {
		#; Move contents from runtime appdata to static(id)
		Merge $$$EnsStaticAppData($$$CurrentClass,tId)=@..%GblRef  Kill @..%GblRef
		Set ..%GblRef=$Name($$$EnsStaticAppData($$$CurrentClass,tId))
		Do ..%Save(0)
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="AddRow">
<FormalSpec>pCol...</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:pCol>..ColCount $$$ERROR($$$GeneralError,"Too many column values")
	Set i=1+$G(@..%GblRef), @..%GblRef=i
	For j=1:1:..ColCount {
		Set @..%GblRef@(i,j)=$G(pCol(j))
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="CreateFromFile">
<Description>
Creates a new Snapshot object and loads it with data from a table-formatted text file</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFilename:%String,pRowSeparator:%String,pColumnSeparator:%String,pColumnWidths:%String,pLineComment:%String,pStripPadChars:%String,pColNamesRow:%Integer,pFirstRow:%Integer,pMaxRowsToGet:%Integer,*pStatus:%Status</FormalSpec>
<ReturnType>Snapshot</ReturnType>
<Implementation><![CDATA[
	Set tSS=..%New()  $$$ASSERT($IsObject(tSS))
	Set:$D(pMaxRowsToGet) tSS.MaxRowsToGet=pMaxRowsToGet
	Set:$D(pFirstRow) tSS.FirstRow=pFirstRow
	Set pStatus=tSS.ImportFile(pFilename,.pRowSeparator,.pColumnSeparator,.pColumnWidths,.pLineComment,.pStripPadChars,.pColNamesRow)
	Quit tSS
]]></Implementation>
</Method>

<Method name="CreateFromStream">
<Description>
Creates a new Snapshot object and loads it with data from a table-formatted character stream</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIOStream:%IO.I.CharacterStream,pRowSeparator:%String,pColumnSeparator:%String,pColumnWidths:%String,pLineComment:%String,pStripPadChars:%String,pColNamesRow:%Integer,pFirstRow:%Integer,pMaxRowsToGet:%Integer,*pStatus:%Status</FormalSpec>
<ReturnType>Snapshot</ReturnType>
<Implementation><![CDATA[
	Set tSS=..%New()  $$$ASSERT($IsObject(tSS))
	Set:$D(pMaxRowsToGet) tSS.MaxRowsToGet=pMaxRowsToGet
	Set:$D(pFirstRow) tSS.FirstRow=pFirstRow
	Set pStatus=tSS.ImportFromStream(pIOStream,.pRowSeparator,.pColumnSeparator,.pColumnWidths,.pLineComment,.pStripPadChars,.pColNamesRow)
	Quit tSS
]]></Implementation>
</Method>

<Method name="ImportFile">
<FormalSpec>pFilename:%String,pRowSeparator:%String=$C(10),pColumnSeparator:%String=$C(9),pColumnWidths:%String="",pLineComment:%String="",pStripPadChars:%String=" "_$C(9),pColNamesRow:%Integer=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#define ColIdToName(%icol)	$S(%icol\26:$C($A("a")-1+(%icol\26)),1:"")_$C($A("a")-1+(%icol#26))	
	Set tIOStream=##class(%IO.FileStream).%New(pFilename)
	if '$IsObject(tIOStream)||'tIOStream.IsOpen Quit $$$ERROR($$$EnsErrGeneral,"Unable to open "_pFilename)
	Quit ..ImportFromStream(tIOStream,.pRowSeparator,.pColumnSeparator,.pColumnWidths,.pLineComment,.pStripPadChars,.pColNamesRow)
]]></Implementation>
</Method>

<Method name="ImportFromStream">
<Description>
Imports data from a table-formatted text file
- negative pRowSeparator means row length
- zero or negative pColumnSeparator means positional columns; negative pColumnSeparator gives # char columns to skip
- pColumnWidths means comma-separated list of char counts if positional, or integer column count if using column separator.
- pLineComment means a string after which the rest of a row should be ignored 
- pStripPadChars means characters to strip from the beginning and end of a field
- pColNamesRow means the index of a row that contains column names.</Description>
<FormalSpec>pIOStream:%IO.I.CharacterStream,pRowSeparator:%String=$C(10),pColumnSeparator:%String=$C(9),pColumnWidths:%String="",pLineComment:%String="",pStripPadChars:%String=" "_$C(9),pColNamesRow:%Integer=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#define ColIdToName(%icol)	$S(%icol\26:$C($A("a")-1+(%icol\26)),1:"")_$C($A("a")-1+(%icol#26))	
	Set:pIOStream.%Extends("%IO.I.CharacterStream") pIOStream=##Class(%IO.MetaCharacterStream).%New(pIOStream)

	Set:pRowSeparator>=0 pIOStream.LineTerminator=pRowSeparator
	Set tFirstRow=..FirstRow, tMaxRows=..MaxRowsToGet, tGblRef=..%GblRef

	#; Set up column widths and counts
	If pColumnSeparator=+pColumnSeparator&&(pColumnSeparator<=0) {
		Set (cols,pcols,maxcols)=$L(pColumnWidths,","), colPos=$S(0=pColumnSeparator:1,1:-pColumnSeparator)
		For columnId=1:1:cols {
			Set colWidths(columnId)=$P(pColumnWidths,",",columnId)
			Set:""=colWidths(columnId)&&(columnId<cols) colWidths(columnId)=1
		} Set colWidths=cols
	}
	Else { Set (pcols,maxcols)=+pColumnWidths, colWidths=0 }

	Set rowId=0  While 'pIOStream.AtEnd {
		If pRowSeparator<0 { set tLine=pIOStream.Read(-pRowSeparator) }
		Else { set tLine=pIOStream.ReadLine() }
		Continue:""=tLine
		Set rowId=rowId+1
		Set tStrip=$S(""=pStripPadChars:tLine,1:$ZStrip(tLine,"<>",pStripPadChars))
		Continue:(""'=pLineComment)&&(pLineComment=$E(tStrip,1,$L(pLineComment)))
		If rowId'=pColNamesRow {
			If rowId<=tFirstRow { If rowId=tFirstRow { Set tFirstRow=-1, rowId=1 } Else { Continue } }
			Quit:tMaxRows>=0&&(rowId>tMaxRows)
			Set ss=$I(@tGblRef)
		}
		Set:0=pcols cols=$L(tLine,pColumnSeparator) Set:cols>maxcols maxcols=cols
		Set f=0 For columnId=1:1:cols {
			If colWidths { Set tName=$E(tLine,colPos,$S(""'=colWidths(columnId):colPos+colWidths(columnId)-1,1:$L(tLine))), colPos=colPos+colWidths(columnId) }
			Else { Set tName=$P(tLine,pColumnSeparator,columnId) }

			If ""'=pLineComment Set f=$F(tName,pLineComment)  If f Set tName=$E(tName,1,f-$L(pLineComment)-1) Quit
			Set:pRowSeparator=$C(10)&&($E(tName,*)=$C(13)) $E(tName,$L(tName))=""
			Set:""'=pStripPadChars tName=$ZStrip(tName,"<>",pStripPadChars)
			If rowId'=pColNamesRow {
				Set @tGblRef@(ss,columnId)=tName, f=0
			} Else {
				Set:""=tName tName=$$$ColIdToName(columnId)
				Set tBase=$ZCVT(tName,"L")
				If 0=$D(@tGblRef@("ColIDs",tBase)) {
					Set @tGblRef@("ColIDs",tBase)=columnId
					Set @tGblRef@("ColNames",columnId)=tName
				} Else {
					Set tNI=2, tNameI=tBase_"_2"
					For { Quit:0=$D(@tGblRef@("ColIDs",tNameI))  Set tNI=tNI+1,tNameI=tBase_"_"_tNI }
					Set @tGblRef@("ColIDs",tBase_"_"_tNI)=columnId
					Set @tGblRef@("ColNames",columnId)=tName_"_"_tNI
				}
			}
		}
		If f {
			If rowId'=pColNamesRow {
				Set @tGblRef@(ss,columnId)=tName, f=0
			} Else {
				Set:""=tName tName=$$$ColIdToName(columnId)
				Set @tGblRef@("ColIDs",tName)=columnId, @tGblRef@("ColNames",columnId)=tName
			}
		}
	}
	If $D(@tGblRef@("ColIDs"))#10=0 { Set (@tGblRef@("ColIDs"),@tGblRef@("ColNames"))=maxcols }
	If $D(@tGblRef@("ColIDs"))\10=0 { For columnId=1:1:@tGblRef@("ColIDs") { Set tName=$$$ColIdToName(columnId), @tGblRef@("ColIDs",$ZCVT(tName,"L"))=columnId, @tGblRef@("ColNames",columnId)=tName } }
	Do ..GenerateIResultSetMetadata()
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="FromResultset">
<Description><![CDATA[
Deprecated - use <method>CreateFromResultSet</method> method]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pRS:%ResultSet</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..%New().ImportFromResultSet(.pRS)
]]></Implementation>
</Method>

<Method name="CreateFromResultSet">
<Description><![CDATA[
Creates a new Snapshot object and loads it with data from another resulset.
See <method>ImportFromResultSet</method> method.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRS:%ResultSet,pLegacyMode:%Integer=1,pODBCColumnType:%Boolean=0,pFirstRow:%Integer,pMaxRowsToGet:%Integer,*pStatus:%Status</FormalSpec>
<ReturnType>Snapshot</ReturnType>
<Implementation><![CDATA[
	Set tSS = ..%New()
	Set:$D(pMaxRowsToGet) tSS.MaxRowsToGet=pMaxRowsToGet
	Set:$D(pFirstRow) tSS.FirstRow=pFirstRow
	Set pStatus = tSS.ImportFromResultSet(.pRS,pLegacyMode,pODBCColumnType)
	Quit tSS
]]></Implementation>
</Method>

<Method name="ImportFromResultSet">
<Description>
Import a result set into a Snapshot
ResultSet classes supported: EnsLib.SQL.GatewayResultSet, %Library.ResultSet, %ResultSet.* (%Library.IResultSet) as well as the result sets in %SQL package such as %SQL.StatementResult and %SQL.ISelectResult (%SQL.IResult)
If pLegacyMode is specified as 0 then attempt first to use %GetMetadata leading to different source of meta data for legacy ResultSet class
Default is 1 which maintains previous behavior while still supporting %SQL.* and %ResultSet.* classes.
If pODBCColumnType is set to 1 then ColumntType text is set to the ODBC type column type text and not the clientType.</Description>
<FormalSpec>pRS:%ResultSet,pLegacyMode:%Integer=1,pODBCColumnType:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:pRS.%IsA("EnsLib.SQL.GatewayResultSet") pRS.GetSnapshot($this)
	Set tSC = $$$OK
	#; Save metadata
	If (pLegacyMode = 1) {
		Try {
			Set nCols=pRS.GetColumnCount()
			Set tRSClassType = 1
		} Catch ex {
			Try {
				Set nCols = pRS.%GetMetadata().columns.Count()
				Set tRSClassType = 2
			} Catch ex2 {
				Set tSC = $$$ADDSC(ex2.AsStatus(),$$$ERROR($$$EnsErrGeneral,"Import class not supported"))
			}
		}
	} ElseIf (pLegacyMode = 0) {
		Try {
			Set nCols = pRS.%GetMetadata().columns.Count()
			Set tRSClassType = 2
		} Catch ex {
			Try {
				Set nCols=pRS.GetColumnCount()
				Set tRSClassType = 1
			} Catch ex2 {
				Set tSC = $$$ADDSC(ex2.AsStatus(),$$$ERROR($$$EnsErrGeneral,"Import class not supported"))
			}
		}
	} Else {
		Set tSC = $$$ERROR($$$EnsErrGeneral,"pLegacyMode Setting not supported"_": "_pLegacyMode)
	}
	Quit:$$$ISERR(tSC) tSC

	Set tGblRef=..%GblRef, @tGblRef@("ColNames")=nCols, @tGblRef@("ColIDs")=nCols, @tGblRef@("ColTypes")=nCols, @tGblRef@("ColSizes")=nCols
	For c = 1:1:nCols {
		Set tColumn = "",tOptionString = ""
		Try {
			If (tRSClassType = 1) {
				Set tName = pRS.GetColumnName(c)
			} Else {
				Set tColumn = pRS.%GetMetadata().columns.GetAt(c)
				Set tName = tColumn.colName
				Set tODBCType = tColumn.ODBCType
				Set @tGblRef@("ColTypes",c,"int") = tODBCType
				Set @tGblRef@("ColSizes",c) = tColumn.precision
				Set @tGblRef@("ColScales",c) = tColumn.scale
				Set @tGblRef@("ColisNuls",c) = tColumn.isNullable
				Set @tGblRef@("Collabels",c) = tColumn.label
				Set @tGblRef@("Coltables",c) = tColumn.tableName
				Set @tGblRef@("Colschemas",c) = tColumn.schemaName
				Set @tGblRef@("Colqualifiers",c) = tColumn.qualifier
				Set tOptionString = $Char($Select('tColumn.isAutoIncrement:0,1:1),$Select('tColumn.isCaseSensitive:0,1:1),$Select('tColumn.isCurrency:0,1:1))
				Set tOptionString = tOptionString_$Char($Select('tColumn.isReadOnly:0,1:1),$Select('tColumn.isRowVersion:0,1:1),$Select('tColumn.isUnique:0,1:1),$Select('tColumn.isAliased:0,1:1))
				Set tOptionString = tOptionString_$Char($Select('tColumn.isExpression:0,1:1),$Select('tColumn.isHidden:0,1:1),$Select('tColumn.isIdentity:0,1:1),$Select('tColumn.isKeyColumn:0,1:1),$Select('tColumn.isRowId:0,1:1))
				Set @tGblRef@("Coloptions",c) = tOptionString
			}
		} Catch ex {
			Set tSC = ex.AsStatus()
		}
		Quit:$$$ISERR(tSC)
		
		Set @tGblRef@("ColNames",c)=tName
		Set tBase=$ZCVT(tName,"L")
		If 0=$D(@tGblRef@("ColIDs",tBase)) {
			Set @tGblRef@("ColIDs",tBase)=c
		} Else {
			Set tNI=2, tNameI=tBase_"_2"
			For { Quit:0=$D(@tGblRef@("ColIDs",tNameI))  Set tNI=tNI+1,tNameI=tBase_"_"_tNI }
			Set @tGblRef@("ColIDs",tBase_"_"_tNI)=c
		}
		Try {
			If (tRSClassType = 1) {
		    	Set tColType = pRS.GetColumnType(c)
			} Else {
				Set tColType = tColumn.clientType
			}
		} Catch ex {
			Set tSC = ex.AsStatus()
		}
		Quit:$$$ISERR(tSC)

		If (pODBCColumnType = 1) {
			If ($G(tODBCType)'="") {
				Set tColTypeWord=$Case(tODBCType
					,-7:"BIT"
					,-6:"TINYINT"
					,-5:"BIGINT"
					,-4:"LONGVARBINARY"
					,-3:"VARBINARY"
					,-2:"BINARY"
					,-1:"LONGVARCHAR"
					,1:"CHAR"
					,2:"NUMERIC"
					,3:"DECIMAL"
					,4:"INTEGER"
					,5:"SMALLINT"
					,6:"FLOAT"
					,7:"REAL"
					,8:"DOUBLE"
					,9:"DATE"
					,91:"DATE"
					,10:"TIME"
					,92:"TIME"
					,11:"TIMESTAMP"
					,93:"TIMESTAMP"
					,12:"VARCHAR"
					,:"N/A:"_tODBCType)
			} Else { Set tColTypeWord = ""}
		} Else {
			Set tColTypeWord=$Case(tColType
				,1 :"BINARY"
				,2 :"DATE"
				,3 :"DOUBLE"
				,4 :"HANDLE"
				,5 :"INTEGER"
				,6 :"LIST"
				,7 :"LONGVARCHAR"
				,8 :"TIME"
				,9 :"TIMESTAMP"
				,10:"VARCHAR"
				,11:"STATUS"
				,12:"BINARYSTREAM"
				,13:"CHARACTERSTREAM"
				,14:"NUMERIC"
				,15:"CURRENCY"
				,16:"BOOLEAN"
				,17:"OID"
				,18:"BIGINT"
				,19:"FDATE"
				,20:"FTIMESTAMP"
				,:"N/A:"_tColType)
		}
		Set @tGblRef@("ColTypes",c) = $G(tColTypeWord)
		If (tRSClassType>1) {
			Try {Do pRS.%GetMetadata().columns.%UnSwizzleAt(c)} Catch ex {}
		}
	}
	Quit:$$$ISERR(tSC) tSC

	Try {
		If (tRSClassType=1) {
	    	Merge ..%Metadata=pRS.%Metadata ; shortcut for Do ..GenerateIResultSetMetadata()
		} Else {
			Do ..GenerateIResultSetMetadata()
		}
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit:$$$ISERR(tSC) tSC

	#; Save data
	Set r=0  While pRS.%Next(.tSC) { Set r=r+1 For c = 1:1:nCols { Set @tGblRef@(r,c) = pRS.%GetData(c) } }
	Set @tGblRef=r
	Quit tSC
]]></Implementation>
</Method>

<Method name="XMLExportInternal">
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//(topArg As %Library.String = "Snapshot", fmt As %Library.String, namespaces As %XML.Namespaces, attrsArg As %Library.String, createId As %Library.String, typeAttr As %Library.String, oreflist As %Library.String, idlist As %Library.String, currentIndent As %Library.String, local As %Library.Boolean)
	Set:""=$G(topArg) topArg="Snapshot"
	New nCols,nRows,tName,tType,tSize,c,r,tValue,tChunk
	Set nCols=..ColCount, nRows=..RowCount
	Write "<"_topArg_" Rows='"_nRows_"' FirstRow='"_..FirstRow_"'>",!
	If nCols {
		Write "<Columns Count='"_nCols_"'>"
		For c=1:1:nCols {
			Set tName=..GetColumnName(c), tType=..GetColumnType(c), tSize=..GetColumnSize(c)
			Write "<col ID='"_c_"' Name='"_tName_"'"_$S(""=tType:"",1:" Type='"_tType_"'")_$S(""=tSize:"",1:" Size='"_tSize_"'")_"/>"
		}
		Write "</Columns>",!

		#; Write rows
		For r=1:1:nRows {
			Write "<Row Num='"_r_"'>"
			For c=1:1:nCols { Write "<col ID='"_c_"'>"
				If ..HasDataStream(c,r) {
					Write "<![CDATA[" Do ..GetDataStream(c,r).OutputToDevice()  Write "]]]]><![CDATA[>"
				} Else {
					Set tValue=..GetData(c,r)
					While ""'=tValue {
						Set tChunk=$E(tValue,1,1000), tValue=$E(tValue,1001,*)
						Write $ZCVT(tChunk,"O","XML")
					}
				}
				Write "</col>"
			}
			Write "</Row>",!
		}
	}
	Write "</"_topArg_">",!
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="XMLImportInternal">
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 //(tag As %Library.String, fmt As %Library.String, namespace As %Library.String, handler As %XML.Document, nodeArg As %Library.Integer, idlist As %Library.String, keynameattr As %Library.String, list As %Library.ListOfObjects)
 New sc,node,nsIndex,child,ref,data
 Set sc=1
 Set $ztrap="XMLImportTrap"
 Set nsIndex=$select($get(namespace)="":"",1:$get(@tree@("ns",namespace)))
 If tag="" Set tag="Snapshot"
 If ($$$xmlGetNodeType(tree,nodeArg)'="e")||(tag'=@tree@(nodeArg)) Set ref=nodeArg Goto XMLImportMalformed
 If encoded {
   If $data(@tree@(nodeArg,"a","id")) Set idlist(nodeArg)=$this
 }
 If $get(@tree@(nodeArg,"nil"),0) Quit 1
 Set sc=$$XMLImportElements(nodeArg)
XMLImportExit Quit sc
XMLImportElements(node)
 Set child=""
XMLLOOP For  { Set child=$order(@tree@(node,"c",child)) If (child="")||($$$xmlGetNodeType(tree,child)'="w") Quit }
 If child="" {
	Do ..GenerateIResultSetMetadata()
	Quit sc
 }
 Set tag=@tree@(child)
 Set ref=child
 If $$$xmlGetNodeType(tree,ref)'="e" Goto XMLImportMalformed
 If tag="FirstRow" {
   If ($get(namespace)'="")&&'$case(@tree@(ref,"u"),"":1,nsIndex:1,:0) Goto XMLImportNS
   If encoded&&$$XMLImportId() {
     Set data=idlist(ref)
   } Else { Goto:'sc XMLImportExit
     If $get(@tree@(ref,"nil"),0) { Set data=""
     } Else {
           Set data=$order(@tree@(ref,"c",""))
           If $order(@tree@(ref,"c",data))'="" {
             Set data="" Goto XMLImportErr
           } ElseIf data'="" { Goto:$$$xmlGetNodeType(tree,data)="e" XMLImportErr Set data=@tree@(data) }
           Set data=$zstrip(data,"<>W",$c(13,10)) If data'="" /*Set data=##class(EnsLib.SQL.Snapshot).FirstRowXSDToLogical(data)*/ Goto:data="" XMLImportErr /*Goto:('##class(EnsLib.SQL.Snapshot).FirstRowIsValid(data)) XMLImportErr*/
     }
     If encoded&&($data(@tree@(ref,"a","id"))) Set idlist(ref)=data
   }
   Set i%FirstRow=data
   Goto XMLLOOP }
 If tag="MaxRowsToGet" {
   If ($get(namespace)'="")&&'$case(@tree@(ref,"u"),"":1,nsIndex:1,:0) Goto XMLImportNS
   If encoded&&$$XMLImportId() {
     Set data=idlist(ref)
   } Else { Goto:'sc XMLImportExit
     If $get(@tree@(ref,"nil"),0) { Set data=""
     } Else {
           Set data=$order(@tree@(ref,"c",""))
           If $order(@tree@(ref,"c",data))'="" {
             Set data="" Goto XMLImportErr
           } ElseIf data'="" { Goto:$$$xmlGetNodeType(tree,data)="e" XMLImportErr Set data=@tree@(data) }
           Set data=$zstrip(data,"<>W",$c(13,10)) If data'="" Set data=##class(EnsLib.SQL.Snapshot).MaxRowsToGetXSDToLogical(data) Goto:data="" XMLImportErr Goto:('##class(EnsLib.SQL.Snapshot).MaxRowsToGetIsValid(data)) XMLImportErr
     }
     If encoded&&($data(@tree@(ref,"a","id"))) Set idlist(ref)=data
   }
   Set i%MaxRowsToGet=data
   Goto XMLLOOP }
 If tag="_GblRef" {
   If ($get(namespace)'="")&&'$case(@tree@(ref,"u"),"":1,nsIndex:1,:0) Goto XMLImportNS
   If encoded&&$$XMLImportId() {
     Set data=idlist(ref)
   } Else { Goto:'sc XMLImportExit
     If $get(@tree@(ref,"nil"),0) { Set data=""
     } Else {
           Set data=$order(@tree@(ref,"c",""))
           If $order(@tree@(ref,"c",data))'="" {
             Set data="" If '##class(%XML.ImportHandler).SerializeNode(tree,ref,0,0,.data) Goto XMLImportErr
           } ElseIf data'="" { Goto:$$$xmlGetNodeType(tree,data)="e" XMLImportErr Set data=@tree@(data) }
           If data'="" Goto:('##class(EnsLib.SQL.Snapshot).%GblRefIsValid(data)) XMLImportErr
           If data="" Set data=$c(0)
     }
     If encoded&&($data(@tree@(ref,"a","id"))) Set idlist(ref)=data
   }
   Set i%%GblRef=data
   Goto XMLLOOP }
 If tag="ColCount" {
   If ($get(namespace)'="")&&'$case(@tree@(ref,"u"),"":1,nsIndex:1,:0) Goto XMLImportNS
   Goto XMLLOOP }
 If tag="RowCount" {
   If ($get(namespace)'="")&&'$case(@tree@(ref,"u"),"":1,nsIndex:1,:0) Goto XMLImportNS
   Goto XMLLOOP }
 If tag="AtEnd" {
   If ($get(namespace)'="")&&'$case(@tree@(ref,"u"),"":1,nsIndex:1,:0) Goto XMLImportNS
   Goto XMLLOOP }
 If tag="_CurrentRow" {
   If ($get(namespace)'="")&&'$case(@tree@(ref,"u"),"":1,nsIndex:1,:0) Goto XMLImportNS
   If encoded&&$$XMLImportId() {
     Set data=idlist(ref)
   } Else { Goto:'sc XMLImportExit
     If $get(@tree@(ref,"nil"),0) { Set data=""
     } Else {
           Set data=$order(@tree@(ref,"c",""))
           If $order(@tree@(ref,"c",data))'="" {
             Set data="" Goto XMLImportErr
           } ElseIf data'="" { Goto:$$$xmlGetNodeType(tree,data)="e" XMLImportErr Set data=@tree@(data) }
           Set data=$zstrip(data,"<>W",$c(13,10)) If data'="" /*Set data=##class(EnsLib.SQL.Snapshot).%CurrentRowXSDToLogical(data)*/ Goto:data="" XMLImportErr /*Goto:('##class(EnsLib.SQL.Snapshot).%CurrentRowIsValid(data)) XMLImportErr*/
     }
     If encoded&&($data(@tree@(ref,"a","id"))) Set idlist(ref)=data
   }
   Set i%%CurrentRow=data
   Goto XMLLOOP }
 Goto XMLImportBadTag
XMLImportBadTag Quit $$Error^%apiOBJ(6237,tag)
XMLImportBadType Quit $$Error^%apiOBJ(6277,class,tag)
XMLImportErr
 Set data=$order(@tree@(ref,"c",""))
 If (data'="") {
   If $$$xmlGetNodeType(tree,data)'="e" {
     Quit $$Error^%apiOBJ(6232,@tree@(ref),$extract(@tree@(data),1,200))
   } Else {
     Quit $$Error^%apiOBJ(6253,@tree@(ref),@tree@(data))
   }
 } Else {
   Quit $$Error^%apiOBJ(6252,@tree@(ref))
 }
XMLImportIdErr Set sc=$$Error^%apiOBJ(6236,id,@tree@(ref)) Quit sc
XMLImportMalformed Set sc=$$Error^%apiOBJ($select($$$xmlGetNodeType(tree,ref)="e":6233,1:6254),@tree@(ref)) Quit sc
XMLImportNS Set sc=$$Error^%apiOBJ(6235,@tree@(ref)) Quit sc
XMLImportTrap Set $ztrap=""
 If $ZE["<CLASS DOES NOT EXIST>" Goto XMLImportBadTag
 Quit $$Error^%apiOBJ(5002,$ZE)
XMLImportId() ;
 If $data(@(tree)@(ref,"a","href")) {
   Set id=$get(@(tree)@(ref,"a","href"))
   If $extract(id)="#" {
     Set tmp=$get(@(tree)@("id",$extract(id,2,*))) If tmp="" Goto XMLImportIdErr
     Set ref=tmp
   }
 } ElseIf $data(@(tree)@(ref,"a","ref")) , ($select($get(@(tree)@(ref,"a","ref","u"))="":"",1:$get(@(tree)@("ns#",@(tree)@(ref,"a","ref","u"))))="http://www.w3.org/2003/05/soap-encoding") {
   Set id=$get(@(tree)@(ref,"a","ref"))
   Set tmp=$get(@(tree)@("id",id)) If tmp="" Goto XMLImportIdErr
   Set ref=tmp
 } ElseIf '$data(@(tree)@(ref,"a","id")) {
   Quit 0
 }
 Quit $data(idlist(ref))
]]></Implementation>
</Method>

<Method name="GenerateIResultSetMetadata">
<Implementation><![CDATA[
 // %protocol version 41 metadata
	Set tColCount=..ColCount
	Set ..%Metadata = $LB(tColCount) // # of SELECT columns
	For i=1:1:tColCount {
		Set tName=..GetColumnName(i)
		Set ..%Metadata = ..%Metadata_$LB(tName				 // 			1) Name
										, ..GetColumnSQLType(i) // 			2) ODBC Type
										, ..GetColumnSize(i) // 			3) Precision
										, ..GetColumnScale(i) // 			4) Scale 
										, ..GetColumnisNullable(i) //		5) NULLABLE (integer) ;jgm
										, ..GetColumnLabelName(i) //		6) Column Label (same as Name)
 										, ..GetColumnTableName(i) //		7) Column Table Name
 										, ..GetColumnSchemaName(i) //		8) Column Schema Name
										, ..GetColumnQualifier(i) //		9) Column Qualifier Name - NULL
										, ..GetColumnOptions(i)  // 		10) $Char(1)/$Char(0) string / $Extract position:
										)
						 // 				1)  isAutoIncrement
						 // 				2)  isCaseSensitive
						 // 				3)  isCurrency
						 // 				4)  IsReadOnly
						 // 				5)  IsRowVersion
						 // 				6)  IsUnique
						 // 				7)  IsAliased
						 // 				8)  IsExpression
						 // 				9)  IsHidden
						 // 				10) IsIdentity
						 // 				11) IsKeyColumn
						 // 			    12) IsRowid		// DPV3092
	}
	Set ..%Metadata = ..%Metadata_$LB(0) // # of Parameters
 // 		j+1 - k:  <For each Parameter>
 // 			1) ODBC Type
 // 			2) Precision
 // 			3) Scale
 // 			4) NULLABLE
 // 				5) colName
 // 				6) colType
]]></Implementation>
</Method>

<Method name="GetInfo">
<FormalSpec>extoption</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	/*
	New %sc,colinfo,extinfo,i,idinfo,paraminfo,QHandle
	Merge QHandle=i%QHandle
	Set extoption=$Get(extoption,0),extinfo=""
	Set %sc=$zobjclassmethod(i%ClassName,i%QueryName_"GetInfo",.colinfo,.paraminfo,.idinfo,.QHandle,$Get(extoption,0),.extinfo)
	Kill i%QHandle,i%ColIndex Merge i%QHandle=QHandle
	If $$$ISERR(%sc) Set i%ColIndex=0,i%ColInfo="",i%ParamInfo="",i%IdInfo="",i%ColExtInfo="" Quit %sc
	Set i%ColInfo=colinfo,i%ParamInfo=paraminfo,i%IdInfo=idinfo,i%HasInfo=1,i%ColIndex=$listlength(colinfo)
	If $ll(extinfo) { Set i%ColExtInfo=$List(extinfo,2),i%StatementType=$List(extinfo,1) }
	Set:extoption i%HasExtInfo=1
	For i=1:1:i%ColIndex Set i%ColIndex(i)=$list($list(colinfo,i))
	Quit %sc
	*/
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetODBCInfo">
<FormalSpec><![CDATA[&colinfo:%List,&parminfo:%List]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	/*
	Merge QHandle=i%QHandle
	Set sc=$zobjclassmethod(i%ClassName,i%QueryName_"GetODBCInfo",.colinfo,.parminfo,.QHandle)
	Kill i%QHandle Merge i%QHandle=QHandle
	Quit sc
	*/
	Quit 0
]]></Implementation>
</Method>

<Method name="GetColumnExtInfo">
<Description><![CDATA[
Returns the name of column <var>n</var> in the result set.]]></Description>
<CodeMode>expression</CodeMode>
<FormalSpec>n:%Integer</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[""
]]></Implementation>
</Method>

<Method name="QueryIsValid">
<Description><![CDATA[
Returns true (1) if the ClassName and QueryName properties of this 
<nobr><b>%ResultSet</b></nobr> object refer to a valid class query. 
Otherwise it returns false (0).]]></Description>
<CodeMode>expression</CodeMode>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[0
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^EnsLib.S.SnapshotD</DataLocation>
<DefaultData>SnapshotDefaultData</DefaultData>
<IdLocation>^EnsLib.S.SnapshotD</IdLocation>
<IndexLocation>^EnsLib.S.SnapshotI</IndexLocation>
<StreamLocation>^EnsLib.S.SnapshotS</StreamLocation>
<ExtentSize>100000</ExtentSize>
<Data name="SnapshotDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>%Dummy</Value>
</Value>
<Value name="3">
<Value>%GblRef</Value>
</Value>
<Value name="4">
<Value>FirstRow</Value>
</Value>
<Value name="5">
<Value>MaxRowsToGet</Value>
</Value>
</Data>
</Storage>
</Class>


<Routine name="EnsUtil" type="INC" timestamp="63920,75708"><![CDATA[
 
#if $G(^Ens.Debug("BreakOnAssert"),0)
#define ENSDEBUG
#endif
 
#ifdef ENSDEBUG
#define ASSERTNOLOG(%condition)  If '(%condition) { Write !,"Assert Condition Failed: "_##quote(%condition)  BREAK }
#else
#define ASSERTNOLOG(%condition)  If '(%condition) { throw ##Class(Ens.AssertException).%New("NoLog") }
#endif
 
#; Macros to get current class and method at compile time. 
#define CurrentClass         $classname()
#define CurrentMethod        ##safeexpression(""""_$get(%methodname)_"""")
#define ClassSQLTable(%c)    ($$$comClassKeyGet(%c,$$$cCLASSsqlschemaname)_"."_$$$comClassKeyGet(%c,$$$cCLASSsqltablename))
 
#; Current Timestamp in ODBC format
#define timeUTCtoUTCH(%utc)  $zdatetimeh(%utc,3,,,,,,,,0)
#define timeUTCHtoUTC(%utch) $zdatetime(%utch,3,,3)
#define timeUTC              $zdatetime($ztimestamp,3,,3)
#define timeUTCH             $ztimestamp
#define timeLocal            ##class(Ens.DataType.UTC).LogicalToOdbc($$$timeUTC)
#define timeUTCtoLocal(%utc) ##class(Ens.DataType.UTC).LogicalToOdbc(%utc)
#define timeLocaltoUTC(%utc) ##class(Ens.DataType.UTC).OdbcToLogical(%utc)
#define timeCmp(%t2,%t1)     $$HorologCmp^EnsUtil($$$timeUTCtoUTCH(%t2),$$$timeUTCtoUTCH(%t1))
#define timeDiff(%t2,%t1)    $$HorologDiff^EnsUtil($$$timeUTCtoUTCH(%t2),$$$timeUTCtoUTCH(%t1))
#define timeHDiff(%t2,%t1)   $$HorologDiff^EnsUtil(%t2,%t1)
#define timeAddSecs(%t,%s)   $$$timeUTCHtoUTC($$HorologAddSecs^EnsUtil($$$timeUTCtoUTCH(%t),%s))
 
#; Get a Class Parameter from a class
#define GetClassParameter(%cls,%parm) $$$comMemberKeyGet(%cls,$$$cCLASSparameter,%parm,$$$cPARAMdefault)
#define GetPropertyParameter(%cls,%prop,%parm) $$$comMemberArrayGet(%cls,$$$cCLASSproperty,%prop,$$$cPROPparameter,%parm)

#; Test if object variable is defined and not Null
#define IsdefObject(%obj)           ($Data(%obj)#2&&$IsObject(%obj))
 
#; Test if an I/O device name indicates it is a terminal device
#define IsTerminalDevice(%io)       $S($e(%io,1,5)="/dev/":$lf($lb("pts","tty"),$e($p(%io,"/",3),1,3)),1:$lf($lb("TRM","TNT","TNA"),$tr(%io,"0123456789|:.")))
 
#; DisplayString macros
#def1arg StatusText(%args)          $$GetOneStatusText^%apiOBJ(%args)
#def1arg StatusDisplayString(%args) $$getAllErrorTexts^EnsUtil(%args)
#def1arg StatusEquals(%args)        ##safeexpression($$macroStatusEquals^%occMsgXML(%literalargs))
 
#define PAD(%s,%l) $Extract($Reverse($Justify($Reverse(%s),%l)),1,%l)
#define NUM(%i,%l) $Translate($Justify(%i,%l)," ","0")
 
#define AND(%l,%r) $ZBoolean(%l\1,%r\1,1)
#define OR(%l,%r)  $ZBoolean(%l\1,%r\1,7)
#define XOR(%l,%r) $ZBoolean(%l\1,%r\1,6)
 
#define OBJCOUNT(%var)   Set %var=0 do {Set o="" for { Set o=$zobjnext(o) Quit:o=""  Set %var=%var+1}} while 0
 
#ifndef envEnsembleRoot
#define envEnsembleRoot  $get(^SourceRoot($ZU(5)),$get(^%qSourceRoot($ZU(5)),$get(^%SYS("SourceRoot",$ZU(5)))))
#endif
 
#ifndef envEnsembleDir
#define envEnsembleDir   $select($$$envEnsembleRoot'="":$$$envEnsembleRoot,1:"m:/")
#endif
 
#; Localization macro to retrieve localized strings in domain EnsColumns
#define GetLocalizedName(%name)  $$FormatMessage^%occMessages("","EnsColumns",%name,%name)

]]></Routine>


<Routine name="Ensemble" type="INC" timestamp="63804,36789.604095"><![CDATA[
#include %occInclude
#include %occErrors
#;
#define EnsMajorVersion $system.Version.GetMajor()
#define EnsMinorVersion $system.Version.GetMinor()
#;
#if $G(^Ens.Debug("BreakOnAssert"),0)
#define ENSDEBUG
#endif
#;
#; Global value lookups
#define GblConfigName           $G($$$EnsJobStatus($$$SystemName,$Job,$$$eJobGuestConfigName),$G($$$EnsJobStatus($$$SystemName,$Job,$$$eJobStartConfigName)))
#;
#; Job-Local values
#define staticCachedObject(%name)   $$$EnsJobLocal("CachedObject",$$$EnsRuntime("CheckSum"),%name)
#define staticCachedChecksum(%name) $$$EnsJobLocal("CachedChecksum",$$$EnsRuntime("CheckSum"),%name)
#;
#define ConfigTypeName(%t)      $Case(%t, $$$eHostTypeUnknown:"Unknown", $$$eHostTypeService:"BusinessService", $$$eHostTypeProcess:"BusinessProcess", $$$eHostTypeOperation:"BusinessOperation", $$$eHostTypeActor:"Actor", :"Unknown")
#;
#define JobConfigName           $S($D($$$EnsJobLocal("ConfigName")):$G($$$EnsJobLocal("GuestConfigName"),$$$EnsJobLocal("ConfigName")),1:$$$GblConfigName)
#define JobKey                  $S($D($$$EnsJobLocal("JobKey"),xJK):xJK,1:$ZStrip($Job,"*E'N"))
#define JobSessionId            $$$EnsJobLocal("SessionId")
#define JobCurrentHeaderId      $$$EnsJobLocal("CurrentHeaderId")
#define JobTraceDevice          $$$EnsJobLocal("TraceDevice")
#define JobSuperSession 		$$$EnsJobLocal("SuperSession")
#;
#define DoArchive               $G($$$EnsJobLocal("ArchiveFlags"))
#;
#define DoTrace                 $S($D($$$EnsJobLocal("DoTrace")):$$$EnsJobLocal("DoTrace"),1:##class(Ens.Util.Trace).DoTrace())
#;
#ifdef ENSDEBUG
#define ASSERT(%condition)      If '(%condition) { $$$LOGASSERT("Assert Condition Failed: "_##quote(%condition)) BREAK }
#else
#define NODEBUG
#define ASSERT(%condition)		If '(%condition) { $$$LOGASSERT("Assert Condition Failed: "_##quote(%condition))  throw ##Class(Ens.AssertException).%New() }
#endif
#define TRACE(%arg)             $$$catTRACE("user",%arg)
#define sysTRACE(%arg)          $$$catTRACE("system",%arg)
#define catTRACE(%cat,%arg)     Do:$$$DoTrace ##class(Ens.Util.Trace).WriteTrace(%cat,$$$CurrentClass,$$$CurrentMethod,%arg)
#;
#define newlogLevelFatal        1
#define newlogLevelError        2
#define newlogLevelWarning      3
#define newlogLevelConfig       4
#define newlogLevelInfo         5
#define newlogLevelUserTrace    6
#define newlogLevelSysTrace     7
#define newLOG(%level,%cat,%msg) Do:(%level'>$g(^Ens.Debug("log"))) ##class(Ens.Util.Log).newLog($$$CurrentClass,$$$CurrentMethod,%level,%cat,%msg) 
#;
#define LOGSTATUS(%status)      Do ##class(Ens.Util.Log).LogStatus($$$CurrentClass,$$$CurrentMethod,%status)
#define LOGASSERT(%arg)         Do ##class(Ens.Util.Log).LogAssert($$$CurrentClass,$$$CurrentMethod,%arg)
#define LOGERROR(%arg)          Do ##class(Ens.Util.Log).LogError($$$CurrentClass,$$$CurrentMethod,%arg)
#define LOGWARNING(%arg)        Do ##class(Ens.Util.Log).LogWarning($$$CurrentClass,$$$CurrentMethod,%arg)
#define LOGALERT(%arg)          Do ##class(Ens.Util.Log).LogAlert($$$CurrentClass,$$$CurrentMethod,%arg)
#define LOGINFO(%arg)           Do ##class(Ens.Util.Log).LogInfo($$$CurrentClass,$$$CurrentMethod,%arg)
#;
#def1arg EnsError(%args)        ##class(Ens.Util.Error).EnsError($$$CurrentClass,$$$CurrentMethod,##safeexpression($$macroERRORArgList^%occMsgXML(%literalargs,1)))
#define  EnsSystemError         ##class(Ens.Util.Error).EnsSystemError($$$CurrentClass,$$$CurrentMethod)
#define  SystemError            ##class(Ens.Util.Error).ExceptionStatus()
#def1arg SystemErrorType(%t)    ##class(Ens.Util.Error).ExceptionStatus(%t)
#;
#; Abstract Base IO Log macros
#define abNEWIOLOGENTRY(%base,%isin,%sc,%txt,%meth,%obj) Do:%base.ArchiveIO %base.NewIOLogEntry(%isin,%sc,%txt,%meth,%base.%SessionId,%obj)
#define abSAVEIOLOGENTRY(%base,%sc,%txt,%obj)   Do:$IsObject(%base.IOLogEntry) %base.SaveIOLogEntry(%sc,%txt,%obj)
#define abCLOSEIOLOGENTRY(%base,%sc,%txt,%obj)  Do:$IsObject(%base.IOLogEntry) %base.CloseIOLogEntry(%sc,%txt,%obj)
#;
#; IO Log macros for Business Operation & Business Service
#define NEWINIOLOGENTRY(%sc,%txt,%obj)        $$$abNEWIOLOGENTRY(.,1,%sc,%txt,$$$CurrentMethod,%obj)
#define NEWOUTIOLOGENTRY(%sc,%txt,%meth,%obj) $$$abNEWIOLOGENTRY(.,0,%sc,%txt,%meth,%obj)
#define SAVEIOLOGENTRY(%sc,%txt,%obj)         Do:$IsObject(..IOLogEntry) ..SaveIOLogEntry(%sc,%txt,%obj)
#define CLOSEIOLOGENTRY(%sc,%txt,%obj)        Do:$IsObject(..IOLogEntry) ..CloseIOLogEntry(%sc,%txt,%obj)
#;define SAVEIOLOGENTRY(%sc,%txt,%obj)        $$$abSAVEIOLOGENTRY(.,%sc,%txt,%obj}
#;define CLOSEIOLOGENTRY(%sc,%txt,%obj)       $$$abCLOSEIOLOGENTRY(.,%sc,%txt,%obj)
#;
#; IO Log macros for Inbound & Outbound Adapters
#define ANEWINIOLOGENTRY(%sc,%txt,%obj)  $$$abNEWIOLOGENTRY(..BusinessHost,1,%sc,%txt,$$$CurrentMethod,%obj)
#define ANEWOUTIOLOGENTRY(%sc,%txt,%obj) $$$abNEWIOLOGENTRY(..BusinessHost,0,%sc,%txt,$$$CurrentMethod,%obj)
#define ASAVEIOLOGENTRY(%sc,%txt,%obj)   Do:$IsObject(..BusinessHost.IOLogEntry) ..BusinessHost.SaveIOLogEntry(%sc,%txt,%obj)
#define ACLOSEIOLOGENTRY(%sc,%txt,%obj)  Do:$IsObject(..BusinessHost.IOLogEntry) ..BusinessHost.CloseIOLogEntry(%sc,%txt,%obj)
#;
#define WEBTRACE(%msg)     If ($IsObject($G(%response))) { Write %msg,! Do %response.Flush() }
#define SysWebTrace(%s)    $$$sysTRACE(%s)
#;
#define SystemName         "sys"
#;
#def1arg EnsConfig(%subs)     $$$EnsJobLocal("Config",%subs)
#def1arg EnsDebug(%subs)      $$$EnsJobLocal("Debug",%subs)
#define EnsRuntime            ^Ens.Runtime
#define EnsQueue              ^Ens.Queue
#define EnsJobLock            ^Ens.JobLock
#define EnsJobStatusStarted   ^Ens.JobStatus
#define EnsJobStatusRoot      ^CacheTemp.EnsJobStatus
#define KillAllEnsJobStatus   Kill $$$EnsJobStatusRoot($namespace)
#def1arg EnsJobStatus(%args)  $$$EnsJobStatusRoot($namespace,%args)
#define EnsActiveMessage    ^Ens.ActiveMessage
#define EnsJobRequest       ^Ens.JobRequest
#define EnsSuspended        ^Ens.Suspended
#define EnsSuspendedAppData ^Ens.SuspendedAppData
#define EnsJobLocal         %Ensemble
#;
#define EnsCrashedMessage(%msgid) $$$EnsRuntime("CrashedMessage",%msgid)
#;
#define EnsRuntimeAppDataRoot     ^CacheTemp.EnsRuntimeAppData
#define KillAllEnsRuntimeAppData  Kill $$$EnsRuntimeAppDataRoot($namespace)
#def1arg EnsRuntimeAppData(%args) $$$EnsRuntimeAppDataRoot($namespace,%args)
#define EnsStaticAppData          ^Ens.AppData
#;
#define EnsAlarm                  ^Ens.Alarm
#;
#define DispatchNameToConfigName(%dispatchname)        $$$EnsRuntime("DispatchName",%dispatchname)
#;
#define ConfigRoot(%configname)                        $$$EnsRuntime("ConfigItem",%configname)
#define ConfigClassName(%configname)                   $$$EnsRuntime("ConfigItem",%configname,"ClassName")
#define ConfigOnTaskClassName(%configname)             $$$EnsRuntime("ConfigItem",%configname,"OnTaskClassName")
#define ConfigQueueName(%configname)                   $$$EnsRuntime("ConfigItem",%configname,"QueueName")
#define ConfigIsEnabled(%configname)                   $$$EnsRuntime("ConfigItem",%configname,"IsEnabled")
#define ConfigChecksum(%configname)                    $$$EnsRuntime("ConfigItem",%configname,"Checksum")
#define ConfigRunAsJob(%configname)                    $$$EnsRuntime("ConfigItem",%configname,"Job")
#define ConfigId(%configname)                          $$$EnsRuntime("ConfigItem",%configname,"%Id")
#define ConfigBusinessType(%configname)                $$$EnsRuntime("ConfigItem",%configname,"BusinessType")
#define ConfigInactivityTimeout(%configname)           $$$EnsRuntime("ConfigItem",%configname,"InactivityTimeout")
#define ConfigPoolSize(%configname)                    $$$EnsRuntime("ConfigItem",%configname,"PoolSize")
#define ConfigSchedule(%configname)                    $$$EnsRuntime("ConfigItem",%configname,"Schedule")
#define ConfigTrace(%configname)                       $$$EnsRuntime("ConfigItem",$S(""=%configname:"%Production",1:%configname),"Trace")
#define ConfigSettingRoot(%configname)                 $$$EnsRuntime("ConfigItem",%configname,"Setting")
#define ConfigSetting(%configname,%target,%name)       $$$EnsRuntime("ConfigItem",%configname,"Setting",%target,%name)
#define ConfigProdSetting(%name)                       $$$EnsRuntime("ConfigItem","%Production","Setting",%name)
#define ConfigSessionQueueName(%configname,%sessionid) $$$EnsRuntime("ConfigItem",%configname,"QueueName",%sessionid)
#define getConfigQueueName(%configname,%sessionid)     $get($$$EnsRuntime("ConfigItem",%configname,"QueueName",$s(%sessionid'="":%sessionid,1:"*")),$get($$$EnsRuntime("ConfigItem",%configname,"QueueName")))
#;
#include EnsConstants
#include EnsErrors
#include EnsUtil
#;
#; Status & Counter macros
#;
#; Global used to hold monitor status and counters
#; Do not use these macros except in the macro definitions in this file
#define EnsHostMonitorRoot     ^CacheTemp.EnsHostMonitor
#define EnsHostCounterRoot     ^CacheTemp.EnsHostCounter
#define EnsJobMonitorRoot      ^CacheTemp.EnsJobMonitor
#define EnsLogMonitorRoot      ^CacheTemp.EnsLogMonitor
#;
#; Host Monitor macros
#def1arg OrderHostMonitor(%arg)               $order($$$EnsHostMonitorRoot($namespace,%arg))
#define  KillAllHostMonitor                   Kill $$$EnsHostMonitorRoot($namespace)
#def1arg KillHostMonitor(%host)               Kill $$$EnsHostMonitorRoot($namespace,%host)
#define  SetHostMonitor(%host,%prop,%val)     Set $$$EnsHostMonitorRoot($namespace,%host,%prop)=%val,$$$EnsHostMonitorRoot($namespace,%host,$$$eMonitorLastActivity)=$$$timeUTC
#define  RegisterHostMonitorJob(%host,%job)   Set $$$EnsHostMonitorRoot($namespace,%host,$$$eMonitorJob,%job)="",$$$EnsHostMonitorRoot($namespace,%host,$$$eMonitorLastActivity)=$$$timeUTC
#define  GetHostMonitor(%host,%prop)          $G($$$EnsHostMonitorRoot($namespace,%host,%prop))
#;
#; Counter macros
#def1arg OrderHostCounter(%args)              $order($$$EnsHostCounterRoot($namespace,%args))
#define  KillAllHostCounter                   Kill $$$EnsHostCounterRoot($namespace)
#define  KillHostCounter(%host,%day,%slot)    Kill $$$EnsHostCounterRoot($namespace,%host,%day,%slot)
#; count of host actions over time split into intervals
#define  IncHostCounterTime(%host)            Set tUTCH=$$$timeUTCH If $I($$$EnsHostMonitorRoot($namespace,%host,$$$eMonitorCount)),$I($$$EnsHostCounterRoot($namespace,%host,+tUTCH,$P(tUTCH,",",2)\$$$EnsCounterInterval)) {} $$$SetHostMonitor(%host,$$$eMonitorStatus,"OK")
#define  GetHostCounter(%host,%day,%slot)     $G($$$EnsHostCounterRoot($namespace,%host,%day,%slot))
#;
#; Total Host counter
#define EnsHostCounterTotalsRoot		     	^CacheTemp.EnsHostTotals
#def1arg EnsHostCounterTotals(%args)		     $$$EnsHostCounterTotalsRoot($namespace,%args)
#;
#; Job Monitor macros
#def1arg OrderJobMonitor(%arg)                $order($$$EnsJobMonitorRoot($namespace,%arg))
#define  EnsJobMonitorNode(%job)              $$$EnsJobMonitorRoot($namespace,%job)
#define  KillAllJobMonitor                    Kill $$$EnsJobMonitorRoot($namespace)
#define  KillJobMonitor(%job)                 Kill $$$EnsJobMonitorRoot($namespace,%job)
#define  SetJobMonitor(%host,%job,%prop,%val) Set $$$EnsJobMonitorRoot($namespace,%job,%host,%prop)=%val,$$$EnsJobMonitorRoot($namespace,%job,%host,$$$eMonitorLastActivity)=$$$timeUTC
#define  GetJobMonitor(%host,%job,%prop)      $G($$$EnsJobMonitorRoot($namespace,%job,%host,%prop))
#; count of total actions since job was started
#define  IncJobCounterTime(%host,%job)        If $I($$$EnsJobMonitorRoot($namespace,%job,%host,$$$eMonitorCount)) {} $$$SetJobMonitor(%host,%job,$$$eMonitorStatus,"OK")
#;
#; Log Monitor macros
#def1arg OrderLogMonitor(%arg)                $order($$$EnsLogMonitor($namespace,%arg))
#define  KillAllLogMonitor                    Kill $$$EnsLogMonitorRoot($namespace)
#define  KillLogMonitor(%type)                Kill $$$EnsLogMonitorRoot($namespace,%type)
#define  SetLogMonitor(%type,%prop,%val)      Set $$$EnsLogMonitorRoot($namespace,%type,%prop)=%val,$$$EnsLogMonitorRoot($namespace,%type,$$$eMonitorLastActivity)=$$$timeUTC
#define  GetLogMonitor(%type,%prop)           $G($$$EnsLogMonitorRoot($namespace,%type,%prop))
#define  IncLogCounter(%host)                 If $I($$$EnsLogMonitorRoot($namespace,%host,$$$eMonitorCount)) {} $$$SetLogMonitor(%host,$$$eMonitorStatus,"OK")
#;
#; Size (in seconds) of the interval used by host activity counter
#define EnsCounterInterval           10
#;
#; Queue Name macros
#define queueIsPrivateQueue(%name)   ($e(%name,1)="_")
#define queueIsNotSyncQueue(%name)   ($e(%name,1,10)'="_SyncCall:")
#define queueSyncCallQueueName       ("_SyncCall:"_$job)
#define queueSystemSignalQueueName   ("_SystemSignal:"_$job)
#define queueBusinessDuplexQueueName ("_BusinessDuplex:"_$job_":"_..%PrivateSessionId)
#;
#; local mirror config var change-index macros
#define EnsMirrorIndex               $ZU(35,1)
#define EnsMirrorIndexInc            $ZU(35,1,1)
#define EnsMirrorIndexReset          Do $ZU(35,1,1-$ZU(35,1))
#;
#; MsgBank config change index macros
#define EnsMsgBankIndex              $ZU(35,2)
#define EnsMsgBankIndexInc           $ZU(35,2,1)
#define EnsMsgBankIndexReset         Do $ZU(35,2,1-$ZU(35,2))
#;
#; Synchronous Commit Set/Clear macros - sync on outermost nested SyncCommitClear() (nesting not to be coded within a single method / stack frame)
#define SyncCommitSet(%t)            Set:$G($$$EnsConfig("SyncCommit",$G($$$EnsJobLocal("ConfigName"),"%Production")),$G($$$EnsConfig("SyncCommit"),0)) %t=$I($$$EnsJobLocal("SyncCommitDepth"))
#define SyncCommitClear(%t)          If $G(%t)>0 { Set $$$EnsJobLocal("SyncCommitDepth")=%t-1  Do:%t=1 ##class(%SYS.Journal.System).Sync() }
#define SyncCommitNow                Do:$G($$$EnsConfig("SyncCommit",$G($$$EnsJobLocal("ConfigName"),"%Production")),$G($$$EnsConfig("SyncCommit"),0)) ##class(%SYS.Journal.System).Sync()
#;
#; Auditing
#;
#define AuditModifyProductionConfig(%prod,%item,%actions)       ##class(Ens.Util.Auditing).AuditModifyProductionConfig(%prod,%item,%actions)
#define AuditModifySchema(%schema,%actions)                     ##class(Ens.Util.Auditing).AuditModifySchema(%schema,%actions)
#define AuditStartStopProduction(%prod,%action)                 ##class(Ens.Util.Auditing).AuditStartStopProduction(%prod,%action)
#define AuditViewMessage(%source,%headerId,%bodyClass,%bodyId)  ##class(Ens.Util.Auditing).AuditViewMessage(%source,%headerId,%bodyClass,%bodyId)
#;
#; BPL Helpers
#define ThrowFault(%s)  Set ..%Context.%LastFault=%s,status=$$$ERROR($$$EnsErrBPLThrownFault,%s) ZT "THRO"
#;
#; Production Modification checks and flags
#define EnsProdSettings                    %EnsProdSettings
#define EnsProdSettingsProperty(%prop)     $$$EnsProdSettings(%prop)
#define EnsProdSettingsOref(%oref)         $$$EnsProdSettings("orefs",+(%oref))
#define EnsProdSettingsModified            +$get($$$EnsProdSettings)
#define	EnsProdSettingsSetModified(%flag)  Set $$$EnsProdSettings = ''(%flag)
#;
#; Core counter macros
#define EnsProdModCounterRoot        ^CacheTemp.EnsProdModCounter
#define EnsProdModCounter             $$$EnsProdModCounterRoot($namespace)
#define EnsProdModCounterGet         $get($$$EnsProdModCounter)
#define EnsProdModCounterInc         $increment($$$EnsProdModCounter)
#define EnsProdModCounterIncAndGet   ($increment($$$EnsProdModCounter)-1)
#define EnsProdModCounterKill        Kill $$$EnsProdModCounter
#;
#; Active location macros
#define EnsProdModActiveRoot   ^CacheTemp.EnsProdModActive
#define EnsProdModActive       $$$EnsProdModActiveRoot($namespace)
#define EnsProdModActiveGet    $get($$$EnsProdModActive)
#define EnsProdModActiveInc    $increment($$$EnsProdModActive)
#define EnsProdModActiveKill   Kill $$$EnsProdModActive
#;
#; Active/Counter comparison macros
#define EnsProdModNoChanges    ($get($$$EnsProdModActive,-1) = $get($$$EnsProdModCounter,-2))
#define EnsProdModChanged      ('$$$EnsProdModNoChanges)
#;
#; Metrics macros
#define EnsMetricsRoot		^CacheTemp.EnsMetrics
#def1arg EnsMetrics(%args)	$$$EnsMetricsRoot($namespace,%args)
#define KillAllEnsMetrics	Kill $$$EnsMetricsRoot($namespace)
#;
#; Used to control if inProc request persisted.
#define EnsInProcPersist	$$$EnsJobLocal("InProc","Persist")
#;
#; Maintaining EnsJobLocal Cached in CSP Gateway job
#define EnsLocalCacheRoot		%EnsembleCached
#def1arg EnsLocalCache(%args)	$$$EnsLocalCacheRoot(%args)
#;Statistics recording
#; See Ens.Util.Statistics.cls
#; 3 types of metrics counter and aggregate duration will be stored in:
#;Count of messages within time slot:  $$$StatsPersistCountersRoot($namespace~$job,day,timeslot,configtype: bs/bo/bp,configname,user dimension e.g. enterpriseid <value>,count)
#;Total duration for messages within time slot:  $$$StatsPersistCountersRoot($namespace~$job,day,timeslot,configtype: bs/bo/bp,configname,user dimension e.g. enterpriseid <value>,duration)
#;Total queuing time for messages within time slot:  $$$StatsPersistCountersRoot($namespace~$job,day,timeslot,configtype: bs/bo/bp,configname,user dimension e.g. enterpriseid <value>,queue)
#def1arg StatsPersistCountersRoot(%args)	^CacheTemp.EnsStatsCounters(%args)
#def1arg StatsPersistCounters(%args)		$$$StatsPersistCountersRoot($namespace_"~"_$Job,%args)
#;Stats held in memory at: 
#def1arg StatsRootData(%args) 				$$$EnsJobLocal("Stats","Host",%args)
#;Used to indicate we have started collecting and as the basis for duration calc.
#define StatsStart(%configname)				$$$StatsRootData(%configname,0)
#;Used to store the QueueTime.
#define StatsQueueDuration(%configname)		$$$StatsRootData(%configname,"QueueDuration")
#;User dimension name/value:
#define StatsUserDimension(%configname)		$$$StatsRootData(%configname,"UserDimension")
#;Cannot be null since used as a subscript.
#define StatsDefaultDimension				"-"
#;
#;MsgBank TCP Service counters.
#define EnsMsgBankRoot							^CacheTemp.EnsMsgBank
#define EnsMsgBankHandShake						$$$EnsMsgBankRoot($namespace,"HandShake")
#def1arg EnsMsgBankConnections(%args)			$$$EnsMsgBankRoot($namespace,%args)
#;
]]></Routine>


<Class name="Goodwill.BPL.SyncPatient.Context">
<Description>
This class is generated by the Goodwill.BPL.SyncPatient BPL class.
This class should not be edited or modified in any way.
Do not make direct use of this class in your application.</Description>
<ClassType>persistent</ClassType>
<CompileAfter>Goodwill.BPL.SyncPatient</CompileAfter>
<IncludeCode/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BP.Context</Super>
<TimeChanged>63946,41970.01253</TimeChanged>
<TimeCreated>63946,41103.891845</TimeCreated>
<GeneratedBy>Ens.BPL.Compiler.CLS</GeneratedBy>

<Property name="Patient2EMRReq">
<Type>Goodwill.Message.SyncPatient2EMRReq</Type>
</Property>

<Property name="Patient2LISReq">
<Type>Goodwill.Message.SyncPatient2LISReq</Type>
</Property>

<Property name="tempResponse">
<Type>%String</Type>
<Parameter name="MAXLEN" value="50"/>
</Property>

<Property name="tempResponse2">
<Type>%String</Type>
<Parameter name="MAXLEN" value="50"/>
</Property>

<Method name="OnResponse1">
<Description>
Response Handler for call to SyncPatient2EMR</Description>
<FormalSpec>process:Ens.BusinessProcess,context:Ens.BP.Context,request:EnsLib.HL7.Message,response:Ens.StringResponse,callrequest:Goodwill.Message.SyncPatient2EMRReq,callresponse:Ens.StringResponse,callname:%String</FormalSpec>
<Language>cache</Language>
<PublicList>process,context</PublicList>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Set $ZT="Trap",status=$$$OK do {
 Set status=$$$OK,context.tempResponse=callresponse.StringValue
 If $$$ISERR(status) Quit
 } while (0)
Exit Quit status
Trap Set $ZT="",status=##class(Ens.Util.Error).EnsSystemError("Goodwill.BPL.SyncPatient.Thread1","OnResponse1")
 Goto Exit
]]></Implementation>
</Method>

<Method name="OnResponse2">
<Description>
Response Handler for call to Goodwill.Operation.SyncPatient2LISSQL</Description>
<FormalSpec>process:Ens.BusinessProcess,context:Ens.BP.Context,request:EnsLib.HL7.Message,response:Ens.StringResponse,callrequest:Goodwill.Message.SyncPatient2LISReq,callresponse:Ens.StringResponse,callname:%String</FormalSpec>
<Language>cache</Language>
<PublicList>process,context</PublicList>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Set $ZT="Trap",status=$$$OK do {
 Set status=$$$OK,context.tempResponse2=callresponse.StringValue
 If $$$ISERR(status) Quit
 } while (0)
Exit Quit status
Trap Set $ZT="",status=##class(Ens.Util.Error).EnsSystemError("Goodwill.BPL.SyncPatient.Thread1","OnResponse2")
 Goto Exit
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>ContextDefaultData1</DefaultData>
<Data name="ContextDefaultData1">
<Structure>listnode</Structure>
<Subscript>"Context"</Subscript>
<Value name="1">
<Value>Patient2EMRReq</Value>
</Value>
<Value name="2">
<Value>Patient2LISReq</Value>
</Value>
<Value name="3">
<Value>tempResponse</Value>
</Value>
<Value name="4">
<Value>tempResponse2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Goodwill.BPL.SyncPatient.Thread1">
<Description>
This class is generated by the Goodwill.BPL.SyncPatient BPL class.
This class should not be edited or modified in any way.
Do not make direct use of this class in your application.</Description>
<ClassType>persistent</ClassType>
<CompileAfter>Goodwill.BPL.SyncPatient</CompileAfter>
<IncludeCode/>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BP.Thread</Super>
<TimeChanged>63946,41970.125629</TimeChanged>
<TimeCreated>63946,41969.024157</TimeCreated>
<GeneratedBy>Ens.BPL.Compiler.CLS</GeneratedBy>

<Method name="S1">
<FormalSpec>process:Ens.BusinessProcess,context:Ens.BP.Context,synctimedout:%Boolean,syncresponses:%ArrayOfObjects(ELEMENTTYPE="%Library.Persistent"),request:%Library.Persistent,response:%Library.Persistent</FormalSpec>
<Language>cache</Language>
<PublicList>process,context</PublicList>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Set $ZT="Trap",status=$$$OK do {
 Set iscTemp=context.Patient2EMRReq
 Set status=$classmethod("Goodwill.DTL.PatientHIS2EMRHL7","Transform",request,.iscTemp,"")
 If $$$ISERR(status) Quit
 Set context.Patient2EMRReq=iscTemp
 Set iscTemp=context.Patient2LISReq
 Set status=$classmethod("Goodwill.DTL.Patient2LISHL7","Transform",request,.iscTemp,"")
 If $$$ISERR(status) Quit
 Set context.Patient2LISReq=iscTemp
 #; --- Begin Call SyncPatient2EMR ---
 #; --- Begin Request ---
 Set callrequest=##class(Goodwill.Message.SyncPatient2EMRReq).%New()
 If '$IsObject(callrequest) Set status=%objlasterror Quit
 Set status=$$$OK,callrequest=context.Patient2EMRReq
 If $$$ISERR(status) Quit
 Set status=..MakeAsyncCall("OnResponse1","SyncPatient2EMR",callrequest,"SyncPatient2EMR",1,0,"SyncPatient2EMR",1)
 If $$$ISERR(status) Quit
 Kill callrequest
 #; --- End Request ---
 #; --- End Call SyncPatient2EMR ---
 Do ..%PendingResponses.Clear(),..%SyncResponses.Clear()
 Set ..%SyncTimedOut=0,..%PendingTimeout="",..%PendingAlarmHandle="",..%SyncName=""
 If ..%Process.IsResponsePending("SyncPatient2EMR") Do ..%PendingResponses.SetAt("","SyncPatient2EMR")
 If ..%PendingResponses.Count()=0 {
    Set ..%NextState="S3"
 } else {
    Set ..%NextState="S2",..%Wait=1
 }
 } while (0)
Exit Quit ..ManageState(status)
Trap Set $ZT="",status=..ManageStatus(status,"S1") Goto Exit
]]></Implementation>
</Method>

<Method name="S2">
<FormalSpec>process:Ens.BusinessProcess,context:Ens.BP.Context,synctimedout:%Boolean,syncresponses:%ArrayOfObjects(ELEMENTTYPE="%Library.Persistent"),request:%Library.Persistent,response:%Library.Persistent</FormalSpec>
<Language>cache</Language>
<PublicList>process,context</PublicList>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Set $ZT="Trap",status=$$$OK do {
 If ..%PendingResponses.Count()=0 {
    Set ..%NextState="S3"
 } else {
    Set ..%NextState="S2",..%Wait=1
 }
 } while (0)
Exit Quit ..ManageState(status)
Trap Set $ZT="",status=..ManageStatus(status,"S2") Goto Exit
]]></Implementation>
</Method>

<Method name="S3">
<FormalSpec>process:Ens.BusinessProcess,context:Ens.BP.Context,synctimedout:%Boolean,syncresponses:%ArrayOfObjects(ELEMENTTYPE="%Library.Persistent"),request:%Library.Persistent,response:%Library.Persistent</FormalSpec>
<Language>cache</Language>
<PublicList>process,context</PublicList>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Set $ZT="Trap",status=$$$OK do {
 #; --- Begin Call SyncPatientLIS ---
 #; --- Begin Request ---
 Set callrequest=##class(Goodwill.Message.SyncPatient2LISReq).%New()
 If '$IsObject(callrequest) Set status=%objlasterror Quit
 Set status=$$$OK,callrequest=context.Patient2LISReq
 If $$$ISERR(status) Quit
 Set status=..MakeAsyncCall("OnResponse2","Goodwill.Operation.SyncPatient2LISSQL",callrequest,"SyncPatientLIS",1,0,"SyncPatientLIS",1)
 If $$$ISERR(status) Quit
 Kill callrequest
 #; --- End Request ---
 #; --- End Call SyncPatientLIS ---
 Do ..%PendingResponses.Clear(),..%SyncResponses.Clear()
 Set ..%SyncTimedOut=0,..%PendingTimeout="",..%PendingAlarmHandle="",..%SyncName=""
 If ..%Process.IsResponsePending("SyncPatientLIS") Do ..%PendingResponses.SetAt("","SyncPatientLIS")
 If ..%PendingResponses.Count()=0 {
    Set ..%NextState="S5"
 } else {
    Set ..%NextState="S4",..%Wait=1
 }
 } while (0)
Exit Quit ..ManageState(status)
Trap Set $ZT="",status=..ManageStatus(status,"S3") Goto Exit
]]></Implementation>
</Method>

<Method name="S4">
<FormalSpec>process:Ens.BusinessProcess,context:Ens.BP.Context,synctimedout:%Boolean,syncresponses:%ArrayOfObjects(ELEMENTTYPE="%Library.Persistent"),request:%Library.Persistent,response:%Library.Persistent</FormalSpec>
<Language>cache</Language>
<PublicList>process,context</PublicList>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Set $ZT="Trap",status=$$$OK do {
 If ..%PendingResponses.Count()=0 {
    Set ..%NextState="S5"
 } else {
    Set ..%NextState="S4",..%Wait=1
 }
 } while (0)
Exit Quit ..ManageState(status)
Trap Set $ZT="",status=..ManageStatus(status,"S4") Goto Exit
]]></Implementation>
</Method>

<Method name="S5">
<FormalSpec>process:Ens.BusinessProcess,context:Ens.BP.Context,synctimedout:%Boolean,syncresponses:%ArrayOfObjects(ELEMENTTYPE="%Library.Persistent"),request:%Library.Persistent,response:%Library.Persistent</FormalSpec>
<Language>cache</Language>
<PublicList>process,context</PublicList>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Set $ZT="Trap",status=$$$OK do {
 Set status=$$$OK,response.StringValue=context.tempResponse_","_context.tempResponse2
 If $$$ISERR(status) Quit
 Do process.ClearAllPendingResponses()
 Set ..%NextState="Stop"
 } while (0)
Exit Quit ..ManageState(status)
Trap Set $ZT="",status=..ManageStatus(status,"S5") Goto Exit
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
</Storage>
</Class>


<Class name="Goodwill.BPL.SyncPatient">
<Description>
</Description>
<Super>Ens.BusinessProcessBPL</Super>
<TimeChanged>63946,41966.987774</TimeChanged>
<TimeCreated>63946,41100.656825</TimeCreated>

<XData name="BPL">
<Description>
BPL Definition</Description>
<XMLNamespace>http://www.intersystems.com/bpl</XMLNamespace>
<Data><![CDATA[
<process language='objectscript' request='EnsLib.HL7.Message' response='Ens.StringResponse' height='2000' width='2000' >
<context>
<property name='Patient2EMRReq' type='Goodwill.Message.SyncPatient2EMRReq' instantiate='0' />
<property name='Patient2LISReq' type='Goodwill.Message.SyncPatient2LISReq' instantiate='0' />
<property name='tempResponse' type='%String' instantiate='0' >
<parameters>
<parameter name='MAXLEN'  value='50' />
</parameters>
</property>
<property name='tempResponse2' type='%String' instantiate='0' >
<parameters>
<parameter name='MAXLEN'  value='50' />
</parameters>
</property>
</context>
<sequence xend='204' yend='773' >
<transform name='Patient2EMRDTL' class='Goodwill.DTL.PatientHIS2EMRHL7' source='request' target='context.Patient2EMRReq' xpos='200' ypos='250' />
<transform name='Patient2LISDTL' class='Goodwill.DTL.Patient2LISHL7' source='request' target='context.Patient2LISReq' xpos='200' ypos='350' />
<call name='SyncPatient2EMR' target='SyncPatient2EMR' async='0' xpos='200' ypos='450' >
<request type='Goodwill.Message.SyncPatient2EMRReq' >
<assign property="callrequest" value="context.Patient2EMRReq" action="set" />
</request>
<response type='Ens.StringResponse' >
<assign property="context.tempResponse" value="callresponse.StringValue" action="set" />
</response>
</call>
<call name='SyncPatientLIS' target='Goodwill.Operation.SyncPatient2LISSQL' async='0' xpos='200' ypos='550' >
<request type='Goodwill.Message.SyncPatient2LISReq' >
<assign property="callrequest" value="context.Patient2LISReq" action="set" />
</request>
<response type='Ens.StringResponse' >
<assign property="context.tempResponse2" value="callresponse.StringValue" action="set" />
</response>
</call>
<assign name="Generate Response" property="response.StringValue" value="context.tempResponse_&quot;,&quot;_context.tempResponse2" action="set" xpos='452' ypos='632' />
</sequence>
</process>
]]></Data>
</XData>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
</Storage>
</Class>


<Class name="Goodwill.DTL.Patient2LISHL7">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>63946,39635.670751</TimeChanged>
<TimeCreated>63946,39147.477396</TimeCreated>
<DependsOn>EnsLib.HL7.Message,Goodwill.Message.SyncPatient2LISReq</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<Parameter name="TREATEMPTYREPEATINGFIELDASNULL">
<Default>0</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='EnsLib.HL7.Message' targetClass='Goodwill.Message.SyncPatient2LISReq' sourceDocType='2.3.1:ADT_A01' create='new' language='objectscript' >
<assign value='source.{PID:PatientIdentifierList().ID}' property='target.PatientID' action='set' />
<assign value='source.{PID:PatientName().familylastname.familyname}' property='target.Name' action='set' />
<assign value='source.{PID:PatientName().givenname}' property='target.Name' action='set' />
<assign value='..Lookup("GenderLIS",source.{PID:Sex})' property='target.XB' action='set' />
<assign value='"未输入"' property='target.Occupation' action='set' />
<assign value='source.{PID:DateTimeOfBirth}' property='target.DOB' action='set' />
</transform>
]]></Data>
</XData>
</Class>


<Class name="Goodwill.DTL.PatientHIS2EMRHL7">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>63946,38278.856926</TimeChanged>
<TimeCreated>63946,37099.331373</TimeCreated>
<DependsOn>EnsLib.HL7.Message,Goodwill.Message.SyncPatient2EMRReq</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<Parameter name="TREATEMPTYREPEATINGFIELDASNULL">
<Default>0</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='EnsLib.HL7.Message' targetClass='Goodwill.Message.SyncPatient2EMRReq' sourceDocType='2.3.1:ADT_A01' create='new' language='objectscript' >
<assign value='..Lookup("GenderEMR",source.{PID:Sex})' property='target.Gender' action='set' />
<assign value='source.{PID:PatientName().familylastname.familyname}_","_source.{PID:PatientName().givenname}' property='target.Name' action='set' />
<assign value='source.{PID:PatientIdentifierList().ID}' property='target.PatientID' action='set' />
<assign value='source.{PID:DateTimeOfBirth}' property='target.DOB' action='set' />
</transform>
]]></Data>
</XData>
</Class>


<Class name="Goodwill.Message.SyncPatient2EMRReq">
<Description>
Sync Patient to EMR, Request</Description>
<Super>Ens.Request</Super>
<TimeChanged>63945,55321.078659</TimeChanged>
<TimeCreated>63945,52252.138914</TimeCreated>

<Property name="PatientID">
<Description>
Patient ID</Description>
<Type>%String</Type>
<Required>1</Required>
</Property>

<Index name="PatientIDIndex">
<Properties>PatientID</Properties>
<Unique>1</Unique>
</Index>

<Property name="Name">
<Description>
Patient Name</Description>
<Type>%String</Type>
</Property>

<Property name="Gender">
<Description>
Patient Gender</Description>
<Type>%String</Type>
<SqlFieldName>XB</SqlFieldName>
<Parameter name="VALUELIST" value=",M,F,U"/>
</Property>

<Property name="DOB">
<Description>
Date of Birth</Description>
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>SyncPatient2EMRReqDefaultData</DefaultData>
<Data name="SyncPatient2EMRReqDefaultData">
<Subscript>"SyncPatient2EMRReq"</Subscript>
<Value name="1">
<Value>PatientID</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="3">
<Value>Gender</Value>
</Value>
<Value name="4">
<Value>DOB</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Goodwill.Message.SyncPatient2LISReq">
<Super>Ens.Request</Super>
<TimeChanged>63945,60621.727492</TimeChanged>
<TimeCreated>63945,57662.459106</TimeCreated>

<Property name="PatientID">
<Type>%String</Type>
</Property>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="XB">
<Type>%String</Type>
<Parameter name="VALUELIST" value=",男,女"/>
</Property>

<Property name="DOB">
<Type>%String</Type>
</Property>

<Property name="Occupation">
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>SyncPatient2LISReqDefaultData</DefaultData>
<Data name="SyncPatient2LISReqDefaultData">
<Subscript>"SyncPatient2LISReq"</Subscript>
<Value name="1">
<Value>PatientID</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="3">
<Value>XB</Value>
</Value>
<Value name="4">
<Value>Occupation</Value>
</Value>
<Value name="5">
<Value>DOB</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Goodwill.Operation.HIS2EMRSoap">
<Super>Ens.BusinessOperation</Super>
<TimeChanged>63945,56044.682455</TimeChanged>
<TimeCreated>63945,52768.507377</TimeCreated>

<Parameter name="ADAPTER">
<Default>EnsLib.SOAP.OutboundAdapter</Default>
</Parameter>

<Property name="Adapter">
<Type>EnsLib.SOAP.OutboundAdapter</Type>
</Property>

<Parameter name="INVOCATION">
<Default>Queue</Default>
</Parameter>

<Method name="SyncPatient">
<Description>
Copy patient information to EMR using SOAP</Description>
<FormalSpec>pRequest:Goodwill.Message.SyncPatient2EMRReq,*pResponse:Ens.StringResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	//set tSC = ..Adapter.InvokeMethod("Registration",.Result,pRequest.PatientID,pRequest.Name,pRequest.Gender,pRequest.DOB)
	set soapclient = ##class(Goodwill.Soap.Proxy.RegistrationSoap).%New()
	set result = soapclient.Registration(pRequest.PatientID,pRequest.Name,pRequest.Gender,pRequest.DOB)
	set pResponse = ##class(Ens.StringResponse).%New()
	set pResponse.StringValue = result
	Quit $$$OK
]]></Implementation>
</Method>

<XData name="MessageMap">
<Data><![CDATA[
<MapItems>
	<MapItem MessageType="Goodwill.Message.SyncPatient2EMRReq"> 
		<Method>SyncPatient</Method>
	</MapItem>
</MapItems>
]]></Data>
</XData>
</Class>


<Class name="Goodwill.Operation.SyncPatient2LISSQL">
<Super>Ens.BusinessOperation</Super>
<TimeChanged>63946,49568.27914</TimeChanged>
<TimeCreated>63945,59012.634853</TimeCreated>

<Parameter name="ADAPTER">
<Default>EnsLib.SQL.OutboundAdapter</Default>
</Parameter>

<Property name="Adapter">
<Type>EnsLib.SQL.OutboundAdapter</Type>
</Property>

<Parameter name="INVOCATION">
<Default>Queue</Default>
</Parameter>

<Method name="Registration">
<FormalSpec>pRequest:Goodwill.Message.SyncPatient2LISReq,*pResponse:Ens.StringResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set sqlString = "insert into sample.Patient"_
	" fields(DOB,Name,Occupation,PatientID,XB)"_
	" values(?,?,?,?,?)"
	//set ^log = sqlString
	set tSC = ..Adapter.ExecuteUpdate(.rows, sqlString,
	$SYSTEM.SQL.CONVERT($ZDH(pRequest.DOB,5),"SQL_VARCHAR","SQL_DATE"),
	pRequest.Name,
	pRequest.Occupation,
	pRequest.PatientID,
	pRequest.XB)
	//w sqlString,!
	do $SYSTEM.Status.DisplayError(tSC)
	Q:$$$ISERR(tSC) tSC
	set pResponse = ##Class(Ens.StringResponse).%New()
	set pResponse.StringValue = rows_"条记录已插入!(LIS)"
	Quit $$$OK
]]></Implementation>
</Method>

<XData name="MessageMap">
<Data><![CDATA[
<MapItems>
	<MapItem MessageType="Goodwill.Message.SyncPatient2LISReq"> 
		<Method>Registration</Method>
	</MapItem>
	<MapItem MessageType="Ens.StringRequest"> 
		<Method>CheckPatient</Method>
	</MapItem>
</MapItems>
]]></Data>
</XData>

<Method name="CheckPatient">
<FormalSpec><![CDATA[PatientID:Ens.StringRequest,&pResponse:Ens.StringResponse]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set sqlString = "select count(*) as pCount from sample.Patient where patientid=?"
	set tSC = ..Adapter.ExecuteQuery(.result,sqlString,PatientID.StringValue)
	w !,tSC,!
	Quit:tSC'=1 tSC
	set tSC = result.Next()
	Quit:tSC'=1 tSC
	
	set count=result.GetDataByName("pCount")
	w count,!
	set pResponse = ##class(Ens.StringResponse).%New()
	set pResponse.StringValue=count
	Quit $$$OK
]]></Implementation>
</Method>
</Class>




<Class name="Goodwill.Service.GetPatientFromCRM">
<Super>Ens.BusinessService</Super>
<TimeChanged>63946,50682.18001</TimeChanged>
<TimeCreated>63946,49879.475959</TimeCreated>

<Parameter name="ADAPTER">
<Default>EnsLib.SQL.InboundAdapter</Default>
</Parameter>

<Method name="OnProcessInput">
<FormalSpec>pInput:EnsLib.SQL.Snapshot,*pOutput:%RegisteredObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set request = ##class(Goodwill.Message.SyncPatient2EMRReq).%New()
	
	set request.PatientID = pInput.GetDataByName("ID")
	set request.Name = pInput.GetDataByName("Name")
	set request.Gender = pInput.GetDataByName("Gender")
	set request.DOB = pInput.GetDataByName("DOB")
	
	set tSC = ..SendRequestSync("SyncPatient2EMR",request,.pOutput)
	//set tSC = ..SendRequestAsync("",request,.pOutput)
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Goodwill.Soap.Proxy.RegistrationSoap">
<ProcedureBlock>1</ProcedureBlock>
<Super>%SOAP.WebClient</Super>
<TimeChanged>63945,55663.906074</TimeChanged>
<TimeCreated>63945,55663.904076</TimeCreated>

<Method name="Registration">
<Final>1</Final>
<FormalSpec>PID:%String,Name:%String,Gender:%String,DOB:%String</FormalSpec>
<ProcedureBlock>1</ProcedureBlock>
<ReturnType>%String</ReturnType>
<WebMethod>1</WebMethod>
<SoapBindingStyle>document</SoapBindingStyle>
<SoapBodyUse>literal</SoapBodyUse>
<Implementation><![CDATA[ Quit ..WebMethod("Registration").Invoke($this,"http://tempuri.org/SimEMR.Patient.Registration",.PID,.Name,.Gender,.DOB)
]]></Implementation>
</Method>

<Parameter name="LOCATION">
<Description>
This is the URL used to access the web service.</Description>
<Default>http://localhost:57772/csp/samples/SimEMR.Patient.cls</Default>
</Parameter>

<Parameter name="NAMESPACE">
<Description>
This is the namespace used by the Service</Description>
<Default>http://tempuri.org</Default>
</Parameter>

<Parameter name="OUTPUTTYPEATTRIBUTE">
<Description>
Use xsi:type attribute for literal types.</Description>
<Default>1</Default>
</Parameter>

<Parameter name="SECURITYIN">
<Description>
Determines handling of Security header.</Description>
<Default>ALLOW</Default>
</Parameter>

<Parameter name="SERVICENAME">
<Description>
This is the name of the Service</Description>
<Default>Registration</Default>
</Parameter>

<Parameter name="SOAPVERSION">
<Description>
This is the SOAP version supported by the service.</Description>
<Default>1.1</Default>
</Parameter>
</Class>


<Class name="Goodwill.Training">
<Super>Ens.Production</Super>
<TimeChanged>63946,52200.608737</TimeChanged>
<TimeCreated>63945,51205.721081</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Goodwill.Training" TestingEnabled="true" LogGeneralTraceEvents="false">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Item Name="SyncPatient2EMR" Category="" ClassName="Goodwill.Operation.HIS2EMRSoap" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="WebServiceURL"><![CDATA[http://localhost:57772/csp/samples/%25SOAP.WebServiceInvoke.cls?CLS=SimEMR.Patient&OP=Registration]]]]><![CDATA[></Setting>
  </Item>
  <Item Name="Goodwill.Operation.SyncPatient2LISSQL" Category="" ClassName="Goodwill.Operation.SyncPatient2LISSQL" PoolSize="1" Enabled="true" Foreground="true" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="DSN">ENSEMBLE Samples</Setting>
    <Setting Target="Adapter" Name="Credentials">EMR</Setting>
    <Setting Target="Host" Name="ArchiveIO">1</Setting>
  </Item>
  <Item Name="Goodwill.BPL.SyncPatient" Category="" ClassName="Goodwill.BPL.SyncPatient" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
  </Item>
  <Item Name="SyncPatientService" Category="" ClassName="EnsLib.HL7.Service.FileService" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="ArchivePath">C:\HL7\Archive</Setting>
    <Setting Target="Adapter" Name="Charset">utf-8</Setting>
    <Setting Target="Adapter" Name="FilePath">C:\HL7\In</Setting>
    <Setting Target="Host" Name="TargetConfigNames">Goodwill.BPL.SyncPatient</Setting>
  </Item>
  <Item Name="Goodwill.Service.GetPatientFromCRM" Category="" ClassName="Goodwill.Service.GetPatientFromCRM" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="Credentials">EMR</Setting>
    <Setting Target="Adapter" Name="DSN">ENSEMBLE Samples</Setting>
    <Setting Target="Adapter" Name="Query"><![CDATA[select * from sample.person where ID>?]]]]><![CDATA[></Setting>
    <Setting Target="Adapter" Name="Parameters"><![CDATA[&%LastKey]]]]><![CDATA[></Setting>
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Project name="Project1" LastModified="2016-02-22 16:20:59.565837">
  <Items>
    <ProjectItem name="Goodwill" type="PKG"></ProjectItem>
  </Items>
</Project>
</Export>
